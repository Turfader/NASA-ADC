1671464299
3 3
12 libp3linmath 4 Ns0b 12 panda3d.core 
1594
2011 11 MathNumbers 0 260 3605 24 MathNumbers::MathNumbers 0 2 1 2 0
112
inline MathNumbers::MathNumbers(void) = default;
inline MathNumbers::MathNumbers(MathNumbers const &) = default;

2012 12 ~MathNumbers 0 516 3605 25 MathNumbers::~MathNumbers 0 0 0
32
MathNumbers::~MathNumbers(void);

2013 9 deg_2_rad 0 1 0 9 deg_2_rad 0 2 1921 1922 0
67
inline double deg_2_rad(double f);
inline float deg_2_rad(float f);

2014 9 rad_2_deg 0 1 0 9 rad_2_deg 0 2 1923 1924 0
67
inline double rad_2_deg(double f);
inline float rad_2_deg(float f);

2015 10 LVecBase2f 0 260 3606 22 LVecBase2f::LVecBase2f 0 4 3 4 5 6 22
/**
 *
 */

/**
 *
 */
205
inline LVecBase2f::LVecBase2f(void) = default;
inline LVecBase2f::LVecBase2f(float fill_value);
inline LVecBase2f::LVecBase2f(float x, float y);
inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default;

2016 12 operator new 0 4 3606 24 LVecBase2f::operator new 0 1 7 0
124
inline void *LVecBase2f::operator new(std::size_t size);
inline void *LVecBase2f::operator new(std::size_t size, void *ptr);

2017 15 operator delete 0 4 3606 27 LVecBase2f::operator delete 0 0 0
108
inline void LVecBase2f::operator delete(void *ptr);
inline void LVecBase2f::operator delete(void *, void *);

2018 12 validate_ptr 0 4 3606 24 LVecBase2f::validate_ptr 0 0 0
61
static inline bool LVecBase2f::validate_ptr(void const *ptr);

2019 10 operator = 0 4 3606 22 LVecBase2f::operator = 0 2 8 9 0
119
void LVecBase2f::operator =(LVecBase2f const &copy) = default;
void LVecBase2f::operator =(float fill_value) = default;

2020 4 zero 0 4 3606 16 LVecBase2f::zero 0 1 10 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2f const &LVecBase2f::zero(void);

2021 6 unit_x 0 4 3606 18 LVecBase2f::unit_x 0 1 11 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_x(void);

2022 6 unit_y 0 4 3606 18 LVecBase2f::unit_y 0 1 12 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_y(void);

2023 10 __reduce__ 0 4 3606 22 LVecBase2f::__reduce__ 0 1 13 0
62
inline PyObject *LVecBase2f::__reduce__(PyObject *self) const;

2024 11 __getattr__ 0 4 3606 23 LVecBase2f::__getattr__ 0 1 14 0
93
inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2025 11 __setattr__ 0 4 3606 23 LVecBase2f::__setattr__ 0 1 15 0
99
inline int LVecBase2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2026 11 operator [] 0 4 3606 23 LVecBase2f::operator [] 0 2 16 17 10
/**
 *
 */
96
inline float LVecBase2f::operator [](int i) const;
inline float &LVecBase2f::operator [](int i);

2027 4 size 0 4 3606 16 LVecBase2f::size 0 1 18 0
44
static constexpr int LVecBase2f::size(void);

2028 6 is_nan 0 4 3606 18 LVecBase2f::is_nan 0 1 19 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2f::is_nan(void) const;

2029 8 get_cell 0 4 3606 20 LVecBase2f::get_cell 0 1 20 10
/**
 *
 */
47
inline float LVecBase2f::get_cell(int i) const;

2030 8 set_cell 0 4 3606 20 LVecBase2f::set_cell 0 1 21 10
/**
 *
 */
53
inline void LVecBase2f::set_cell(int i, float value);

2031 5 get_x 0 4 3606 17 LVecBase2f::get_x 0 1 22 10
/**
 *
 */
43
inline float LVecBase2f::get_x(void) const;

2032 5 get_y 0 4 3606 17 LVecBase2f::get_y 0 1 23 10
/**
 *
 */
43
inline float LVecBase2f::get_y(void) const;

2033 5 set_x 0 4 3606 17 LVecBase2f::set_x 0 1 24 10
/**
 *
 */
43
inline void LVecBase2f::set_x(float value);

2034 5 set_y 0 4 3606 17 LVecBase2f::set_y 0 1 25 10
/**
 *
 */
43
inline void LVecBase2f::set_y(float value);

2035 11 add_to_cell 0 4 3606 23 LVecBase2f::add_to_cell 0 1 26 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase2f::add_to_cell(int i, float value);

2036 5 add_x 0 4 3606 17 LVecBase2f::add_x 0 1 27 10
/**
 *
 */
43
inline void LVecBase2f::add_x(float value);

2037 5 add_y 0 4 3606 17 LVecBase2f::add_y 0 1 28 10
/**
 *
 */
43
inline void LVecBase2f::add_y(float value);

2038 8 get_data 0 4 3606 20 LVecBase2f::get_data 0 1 29 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
53
inline float const *LVecBase2f::get_data(void) const;

2039 18 get_num_components 0 4 3606 30 LVecBase2f::get_num_components 0 1 30 0
58
static constexpr int LVecBase2f::get_num_components(void);

2040 4 fill 0 4 3606 16 LVecBase2f::fill 0 1 31 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase2f::fill(float fill_value);

2041 3 set 0 4 3606 15 LVecBase2f::set 0 1 32 10
/**
 *
 */
46
inline void LVecBase2f::set(float x, float y);

2042 3 dot 0 4 3606 15 LVecBase2f::dot 0 1 33 10
/**
 *
 */
60
inline float LVecBase2f::dot(LVecBase2f const &other) const;

2043 14 length_squared 0 4 3606 26 LVecBase2f::length_squared 0 1 34 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase2f::length_squared(void) const;

2044 6 length 0 4 3606 18 LVecBase2f::length 0 1 35 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase2f::length(void) const;

2045 9 normalize 0 4 3606 21 LVecBase2f::normalize 0 1 36 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2f::normalize(void);

2046 10 normalized 0 4 3606 22 LVecBase2f::normalized 0 1 37 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2f LVecBase2f::normalized(void) const;

2047 7 project 0 4 3606 19 LVecBase2f::project 0 1 38 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const;

2048 10 operator < 0 4 3606 22 LVecBase2f::operator < 0 1 39 0
66
inline bool LVecBase2f::operator <(LVecBase2f const &other) const;

2049 11 operator == 0 4 3606 23 LVecBase2f::operator == 0 1 40 0
67
inline bool LVecBase2f::operator ==(LVecBase2f const &other) const;

2050 11 operator != 0 4 3606 23 LVecBase2f::operator != 0 1 41 0
67
inline bool LVecBase2f::operator !=(LVecBase2f const &other) const;

2051 10 compare_to 0 4 3606 22 LVecBase2f::compare_to 0 2 42 43 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase2f::compare_to(LVecBase2f const &other) const;
inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const;

2052 8 get_hash 0 4 3606 20 LVecBase2f::get_hash 0 2 44 45 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase2f::get_hash(void) const;
inline std::size_t LVecBase2f::get_hash(float threshold) const;

2053 8 add_hash 0 4 3606 20 LVecBase2f::add_hash 0 2 46 47 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase2f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const;

2054 13 generate_hash 0 4 3606 25 LVecBase2f::generate_hash 0 2 48 49 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2055 10 operator - 0 68 3606 22 LVecBase2f::operator - 0 1 50 0
53
inline LVecBase2f LVecBase2f::operator -(void) const;

2056 10 operator + 0 4 3606 22 LVecBase2f::operator + 0 1 51 0
72
inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &other) const;

2057 10 operator - 0 4 3606 22 LVecBase2f::operator - 0 1 52 0
72
inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &other) const;

2058 10 operator * 0 4 3606 22 LVecBase2f::operator * 0 1 53 0
61
inline LVecBase2f LVecBase2f::operator *(float scalar) const;

2059 10 operator / 0 4 3606 22 LVecBase2f::operator / 0 1 54 0
61
inline LVecBase2f LVecBase2f::operator /(float scalar) const;

2060 11 operator += 0 4 3606 23 LVecBase2f::operator += 0 1 55 0
61
inline void LVecBase2f::operator +=(LVecBase2f const &other);

2061 11 operator -= 0 4 3606 23 LVecBase2f::operator -= 0 1 56 0
61
inline void LVecBase2f::operator -=(LVecBase2f const &other);

2062 11 operator *= 0 4 3606 23 LVecBase2f::operator *= 0 1 57 0
50
inline void LVecBase2f::operator *=(float scalar);

2063 11 operator /= 0 4 3606 23 LVecBase2f::operator /= 0 1 58 0
50
inline void LVecBase2f::operator /=(float scalar);

2064 18 componentwise_mult 0 4 3606 30 LVecBase2f::componentwise_mult 0 1 59 10
/**
 *
 */
68
inline void LVecBase2f::componentwise_mult(LVecBase2f const &other);

2065 12 __floordiv__ 0 4 3606 24 LVecBase2f::__floordiv__ 0 1 60 0
78
inline PyObject *LVecBase2f::__floordiv__(PyObject *self, float scalar) const;

2066 13 __ifloordiv__ 0 4 3606 25 LVecBase2f::__ifloordiv__ 0 1 61 0
73
inline PyObject *LVecBase2f::__ifloordiv__(PyObject *self, float scalar);

2067 7 __pow__ 0 4 3606 19 LVecBase2f::__pow__ 0 1 62 0
75
inline PyObject *LVecBase2f::__pow__(PyObject *self, float exponent) const;

2068 8 __ipow__ 0 4 3606 20 LVecBase2f::__ipow__ 0 1 63 0
70
inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent);

2069 9 __round__ 0 4 3606 21 LVecBase2f::__round__ 0 1 64 0
55
inline PyObject *LVecBase2f::__round__(PyObject *self);

2070 9 __floor__ 0 4 3606 21 LVecBase2f::__floor__ 0 1 65 0
55
inline PyObject *LVecBase2f::__floor__(PyObject *self);

2071 8 __ceil__ 0 4 3606 20 LVecBase2f::__ceil__ 0 1 66 0
54
inline PyObject *LVecBase2f::__ceil__(PyObject *self);

2072 4 fmax 0 4 3606 16 LVecBase2f::fmax 0 1 67 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const;

2073 4 fmin 0 4 3606 16 LVecBase2f::fmin 0 1 68 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const;

2074 12 almost_equal 0 4 3606 24 LVecBase2f::almost_equal 0 2 69 70 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const;
inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const;

2075 6 output 0 4 3606 18 LVecBase2f::output 0 1 71 10
/**
 *
 */
56
inline void LVecBase2f::output(std::ostream &out) const;

2076 8 __repr__ 0 4 3606 20 LVecBase2f::__repr__ 0 1 72 0
52
inline std::string LVecBase2f::__repr__(void) const;

2077 20 write_datagram_fixed 0 4 3606 32 LVecBase2f::write_datagram_fixed 0 1 73 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const;

2078 19 read_datagram_fixed 0 4 3606 31 LVecBase2f::read_datagram_fixed 0 1 74 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source);

2079 14 write_datagram 0 4 3606 26 LVecBase2f::write_datagram 0 1 75 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2f::write_datagram(Datagram &destination) const;

2080 13 read_datagram 0 4 3606 25 LVecBase2f::read_datagram 0 1 76 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2f::read_datagram(DatagramIterator &source);

2081 14 get_class_type 0 4 3606 26 LVecBase2f::get_class_type 0 1 77 0
51
static TypeHandle LVecBase2f::get_class_type(void);

2082 11 ~LVecBase2f 0 516 3606 23 LVecBase2f::~LVecBase2f 0 0 0
30
LVecBase2f::~LVecBase2f(void);

2083 10 LVecBase2d 0 260 3609 22 LVecBase2d::LVecBase2d 0 4 78 79 80 81 22
/**
 *
 */

/**
 *
 */
208
inline LVecBase2d::LVecBase2d(void) = default;
inline LVecBase2d::LVecBase2d(double fill_value);
inline LVecBase2d::LVecBase2d(double x, double y);
inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default;

2084 12 operator new 0 4 3609 24 LVecBase2d::operator new 0 1 82 0
124
inline void *LVecBase2d::operator new(std::size_t size);
inline void *LVecBase2d::operator new(std::size_t size, void *ptr);

2085 15 operator delete 0 4 3609 27 LVecBase2d::operator delete 0 0 0
108
inline void LVecBase2d::operator delete(void *ptr);
inline void LVecBase2d::operator delete(void *, void *);

2086 12 validate_ptr 0 4 3609 24 LVecBase2d::validate_ptr 0 0 0
61
static inline bool LVecBase2d::validate_ptr(void const *ptr);

2087 10 operator = 0 4 3609 22 LVecBase2d::operator = 0 2 83 84 0
120
void LVecBase2d::operator =(LVecBase2d const &copy) = default;
void LVecBase2d::operator =(double fill_value) = default;

2088 4 zero 0 4 3609 16 LVecBase2d::zero 0 1 85 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2d const &LVecBase2d::zero(void);

2089 6 unit_x 0 4 3609 18 LVecBase2d::unit_x 0 1 86 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_x(void);

2090 6 unit_y 0 4 3609 18 LVecBase2d::unit_y 0 1 87 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_y(void);

2091 10 __reduce__ 0 4 3609 22 LVecBase2d::__reduce__ 0 1 88 0
62
inline PyObject *LVecBase2d::__reduce__(PyObject *self) const;

2092 11 __getattr__ 0 4 3609 23 LVecBase2d::__getattr__ 0 1 89 0
93
inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2093 11 __setattr__ 0 4 3609 23 LVecBase2d::__setattr__ 0 1 90 0
99
inline int LVecBase2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2094 11 operator [] 0 4 3609 23 LVecBase2d::operator [] 0 2 91 92 10
/**
 *
 */
98
inline double LVecBase2d::operator [](int i) const;
inline double &LVecBase2d::operator [](int i);

2095 4 size 0 4 3609 16 LVecBase2d::size 0 1 93 0
44
static constexpr int LVecBase2d::size(void);

2096 6 is_nan 0 4 3609 18 LVecBase2d::is_nan 0 1 94 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2d::is_nan(void) const;

2097 8 get_cell 0 4 3609 20 LVecBase2d::get_cell 0 1 95 10
/**
 *
 */
48
inline double LVecBase2d::get_cell(int i) const;

2098 8 set_cell 0 4 3609 20 LVecBase2d::set_cell 0 1 96 10
/**
 *
 */
54
inline void LVecBase2d::set_cell(int i, double value);

2099 5 get_x 0 4 3609 17 LVecBase2d::get_x 0 1 97 10
/**
 *
 */
44
inline double LVecBase2d::get_x(void) const;

2100 5 get_y 0 4 3609 17 LVecBase2d::get_y 0 1 98 10
/**
 *
 */
44
inline double LVecBase2d::get_y(void) const;

2101 5 set_x 0 4 3609 17 LVecBase2d::set_x 0 1 99 10
/**
 *
 */
44
inline void LVecBase2d::set_x(double value);

2102 5 set_y 0 4 3609 17 LVecBase2d::set_y 0 1 100 10
/**
 *
 */
44
inline void LVecBase2d::set_y(double value);

2103 11 add_to_cell 0 4 3609 23 LVecBase2d::add_to_cell 0 1 101 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase2d::add_to_cell(int i, double value);

2104 5 add_x 0 4 3609 17 LVecBase2d::add_x 0 1 102 10
/**
 *
 */
44
inline void LVecBase2d::add_x(double value);

2105 5 add_y 0 4 3609 17 LVecBase2d::add_y 0 1 103 10
/**
 *
 */
44
inline void LVecBase2d::add_y(double value);

2106 8 get_data 0 4 3609 20 LVecBase2d::get_data 0 1 104 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
54
inline double const *LVecBase2d::get_data(void) const;

2107 18 get_num_components 0 4 3609 30 LVecBase2d::get_num_components 0 1 105 0
58
static constexpr int LVecBase2d::get_num_components(void);

2108 4 fill 0 4 3609 16 LVecBase2d::fill 0 1 106 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase2d::fill(double fill_value);

2109 3 set 0 4 3609 15 LVecBase2d::set 0 1 107 10
/**
 *
 */
48
inline void LVecBase2d::set(double x, double y);

2110 3 dot 0 4 3609 15 LVecBase2d::dot 0 1 108 10
/**
 *
 */
61
inline double LVecBase2d::dot(LVecBase2d const &other) const;

2111 14 length_squared 0 4 3609 26 LVecBase2d::length_squared 0 1 109 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase2d::length_squared(void) const;

2112 6 length 0 4 3609 18 LVecBase2d::length 0 1 110 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase2d::length(void) const;

2113 9 normalize 0 4 3609 21 LVecBase2d::normalize 0 1 111 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2d::normalize(void);

2114 10 normalized 0 4 3609 22 LVecBase2d::normalized 0 1 112 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2d LVecBase2d::normalized(void) const;

2115 7 project 0 4 3609 19 LVecBase2d::project 0 1 113 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const;

2116 10 operator < 0 4 3609 22 LVecBase2d::operator < 0 1 114 0
66
inline bool LVecBase2d::operator <(LVecBase2d const &other) const;

2117 11 operator == 0 4 3609 23 LVecBase2d::operator == 0 1 115 0
67
inline bool LVecBase2d::operator ==(LVecBase2d const &other) const;

2118 11 operator != 0 4 3609 23 LVecBase2d::operator != 0 1 116 0
67
inline bool LVecBase2d::operator !=(LVecBase2d const &other) const;

2119 10 compare_to 0 4 3609 22 LVecBase2d::compare_to 0 2 117 118 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase2d::compare_to(LVecBase2d const &other) const;
inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const;

2120 8 get_hash 0 4 3609 20 LVecBase2d::get_hash 0 2 119 120 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase2d::get_hash(void) const;
inline std::size_t LVecBase2d::get_hash(double threshold) const;

2121 8 add_hash 0 4 3609 20 LVecBase2d::add_hash 0 2 121 122 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase2d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const;

2122 13 generate_hash 0 4 3609 25 LVecBase2d::generate_hash 0 2 123 124 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2123 10 operator - 0 68 3609 22 LVecBase2d::operator - 0 1 125 0
53
inline LVecBase2d LVecBase2d::operator -(void) const;

2124 10 operator + 0 4 3609 22 LVecBase2d::operator + 0 1 126 0
72
inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &other) const;

2125 10 operator - 0 4 3609 22 LVecBase2d::operator - 0 1 127 0
72
inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &other) const;

2126 10 operator * 0 4 3609 22 LVecBase2d::operator * 0 1 128 0
62
inline LVecBase2d LVecBase2d::operator *(double scalar) const;

2127 10 operator / 0 4 3609 22 LVecBase2d::operator / 0 1 129 0
62
inline LVecBase2d LVecBase2d::operator /(double scalar) const;

2128 11 operator += 0 4 3609 23 LVecBase2d::operator += 0 1 130 0
61
inline void LVecBase2d::operator +=(LVecBase2d const &other);

2129 11 operator -= 0 4 3609 23 LVecBase2d::operator -= 0 1 131 0
61
inline void LVecBase2d::operator -=(LVecBase2d const &other);

2130 11 operator *= 0 4 3609 23 LVecBase2d::operator *= 0 1 132 0
51
inline void LVecBase2d::operator *=(double scalar);

2131 11 operator /= 0 4 3609 23 LVecBase2d::operator /= 0 1 133 0
51
inline void LVecBase2d::operator /=(double scalar);

2132 18 componentwise_mult 0 4 3609 30 LVecBase2d::componentwise_mult 0 1 134 10
/**
 *
 */
68
inline void LVecBase2d::componentwise_mult(LVecBase2d const &other);

2133 12 __floordiv__ 0 4 3609 24 LVecBase2d::__floordiv__ 0 1 135 0
79
inline PyObject *LVecBase2d::__floordiv__(PyObject *self, double scalar) const;

2134 13 __ifloordiv__ 0 4 3609 25 LVecBase2d::__ifloordiv__ 0 1 136 0
74
inline PyObject *LVecBase2d::__ifloordiv__(PyObject *self, double scalar);

2135 7 __pow__ 0 4 3609 19 LVecBase2d::__pow__ 0 1 137 0
76
inline PyObject *LVecBase2d::__pow__(PyObject *self, double exponent) const;

2136 8 __ipow__ 0 4 3609 20 LVecBase2d::__ipow__ 0 1 138 0
71
inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent);

2137 9 __round__ 0 4 3609 21 LVecBase2d::__round__ 0 1 139 0
55
inline PyObject *LVecBase2d::__round__(PyObject *self);

2138 9 __floor__ 0 4 3609 21 LVecBase2d::__floor__ 0 1 140 0
55
inline PyObject *LVecBase2d::__floor__(PyObject *self);

2139 8 __ceil__ 0 4 3609 20 LVecBase2d::__ceil__ 0 1 141 0
54
inline PyObject *LVecBase2d::__ceil__(PyObject *self);

2140 4 fmax 0 4 3609 16 LVecBase2d::fmax 0 1 142 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const;

2141 4 fmin 0 4 3609 16 LVecBase2d::fmin 0 1 143 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const;

2142 12 almost_equal 0 4 3609 24 LVecBase2d::almost_equal 0 2 144 145 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const;
inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const;

2143 6 output 0 4 3609 18 LVecBase2d::output 0 1 146 10
/**
 *
 */
56
inline void LVecBase2d::output(std::ostream &out) const;

2144 8 __repr__ 0 4 3609 20 LVecBase2d::__repr__ 0 1 147 0
52
inline std::string LVecBase2d::__repr__(void) const;

2145 20 write_datagram_fixed 0 4 3609 32 LVecBase2d::write_datagram_fixed 0 1 148 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const;

2146 19 read_datagram_fixed 0 4 3609 31 LVecBase2d::read_datagram_fixed 0 1 149 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source);

2147 14 write_datagram 0 4 3609 26 LVecBase2d::write_datagram 0 1 150 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2d::write_datagram(Datagram &destination) const;

2148 13 read_datagram 0 4 3609 25 LVecBase2d::read_datagram 0 1 151 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2d::read_datagram(DatagramIterator &source);

2149 14 get_class_type 0 4 3609 26 LVecBase2d::get_class_type 0 1 152 0
51
static TypeHandle LVecBase2d::get_class_type(void);

2150 11 ~LVecBase2d 0 516 3609 23 LVecBase2d::~LVecBase2d 0 0 0
30
LVecBase2d::~LVecBase2d(void);

2151 10 LVecBase2i 0 260 3612 22 LVecBase2i::LVecBase2i 0 4 153 154 155 156 22
/**
 *
 */

/**
 *
 */
199
inline LVecBase2i::LVecBase2i(void) = default;
inline LVecBase2i::LVecBase2i(int fill_value);
inline LVecBase2i::LVecBase2i(int x, int y);
inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default;

2152 12 operator new 0 4 3612 24 LVecBase2i::operator new 0 1 157 0
124
inline void *LVecBase2i::operator new(std::size_t size);
inline void *LVecBase2i::operator new(std::size_t size, void *ptr);

2153 15 operator delete 0 4 3612 27 LVecBase2i::operator delete 0 0 0
108
inline void LVecBase2i::operator delete(void *ptr);
inline void LVecBase2i::operator delete(void *, void *);

2154 12 validate_ptr 0 4 3612 24 LVecBase2i::validate_ptr 0 0 0
61
static inline bool LVecBase2i::validate_ptr(void const *ptr);

2155 10 operator = 0 4 3612 22 LVecBase2i::operator = 0 2 158 159 0
117
void LVecBase2i::operator =(LVecBase2i const &copy) = default;
void LVecBase2i::operator =(int fill_value) = default;

2156 4 zero 0 4 3612 16 LVecBase2i::zero 0 1 160 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2i const &LVecBase2i::zero(void);

2157 6 unit_x 0 4 3612 18 LVecBase2i::unit_x 0 1 161 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_x(void);

2158 6 unit_y 0 4 3612 18 LVecBase2i::unit_y 0 1 162 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_y(void);

2159 10 __reduce__ 0 4 3612 22 LVecBase2i::__reduce__ 0 1 163 0
62
inline PyObject *LVecBase2i::__reduce__(PyObject *self) const;

2160 11 __getattr__ 0 4 3612 23 LVecBase2i::__getattr__ 0 1 164 0
93
inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2161 11 __setattr__ 0 4 3612 23 LVecBase2i::__setattr__ 0 1 165 0
99
inline int LVecBase2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2162 11 operator [] 0 4 3612 23 LVecBase2i::operator [] 0 2 166 167 10
/**
 *
 */
92
inline int LVecBase2i::operator [](int i) const;
inline int &LVecBase2i::operator [](int i);

2163 4 size 0 4 3612 16 LVecBase2i::size 0 1 168 0
44
static constexpr int LVecBase2i::size(void);

2164 6 is_nan 0 4 3612 18 LVecBase2i::is_nan 0 1 169 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2i::is_nan(void) const;

2165 8 get_cell 0 4 3612 20 LVecBase2i::get_cell 0 1 170 10
/**
 *
 */
45
inline int LVecBase2i::get_cell(int i) const;

2166 8 set_cell 0 4 3612 20 LVecBase2i::set_cell 0 1 171 10
/**
 *
 */
51
inline void LVecBase2i::set_cell(int i, int value);

2167 5 get_x 0 4 3612 17 LVecBase2i::get_x 0 1 172 10
/**
 *
 */
41
inline int LVecBase2i::get_x(void) const;

2168 5 get_y 0 4 3612 17 LVecBase2i::get_y 0 1 173 10
/**
 *
 */
41
inline int LVecBase2i::get_y(void) const;

2169 5 set_x 0 4 3612 17 LVecBase2i::set_x 0 1 174 10
/**
 *
 */
41
inline void LVecBase2i::set_x(int value);

2170 5 set_y 0 4 3612 17 LVecBase2i::set_y 0 1 175 10
/**
 *
 */
41
inline void LVecBase2i::set_y(int value);

2171 11 add_to_cell 0 4 3612 23 LVecBase2i::add_to_cell 0 1 176 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase2i::add_to_cell(int i, int value);

2172 5 add_x 0 4 3612 17 LVecBase2i::add_x 0 1 177 10
/**
 *
 */
41
inline void LVecBase2i::add_x(int value);

2173 5 add_y 0 4 3612 17 LVecBase2i::add_y 0 1 178 10
/**
 *
 */
41
inline void LVecBase2i::add_y(int value);

2174 8 get_data 0 4 3612 20 LVecBase2i::get_data 0 1 179 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
51
inline int const *LVecBase2i::get_data(void) const;

2175 18 get_num_components 0 4 3612 30 LVecBase2i::get_num_components 0 1 180 0
58
static constexpr int LVecBase2i::get_num_components(void);

2176 4 fill 0 4 3612 16 LVecBase2i::fill 0 1 181 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase2i::fill(int fill_value);

2177 3 set 0 4 3612 15 LVecBase2i::set 0 1 182 10
/**
 *
 */
42
inline void LVecBase2i::set(int x, int y);

2178 3 dot 0 4 3612 15 LVecBase2i::dot 0 1 183 10
/**
 *
 */
58
inline int LVecBase2i::dot(LVecBase2i const &other) const;

2179 14 length_squared 0 4 3612 26 LVecBase2i::length_squared 0 1 184 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase2i::length_squared(void) const;

2180 10 operator < 0 4 3612 22 LVecBase2i::operator < 0 1 185 0
66
inline bool LVecBase2i::operator <(LVecBase2i const &other) const;

2181 11 operator == 0 4 3612 23 LVecBase2i::operator == 0 1 186 0
67
inline bool LVecBase2i::operator ==(LVecBase2i const &other) const;

2182 11 operator != 0 4 3612 23 LVecBase2i::operator != 0 1 187 0
67
inline bool LVecBase2i::operator !=(LVecBase2i const &other) const;

2183 10 compare_to 0 4 3612 22 LVecBase2i::compare_to 0 1 188 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase2i::compare_to(LVecBase2i const &other) const;

2184 8 get_hash 0 4 3612 20 LVecBase2i::get_hash 0 1 189 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase2i::get_hash(void) const;

2185 8 add_hash 0 4 3612 20 LVecBase2i::add_hash 0 1 190 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase2i::add_hash(std::size_t hash) const;

2186 13 generate_hash 0 4 3612 25 LVecBase2i::generate_hash 0 1 191 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase2i::generate_hash(ChecksumHashGenerator &hashgen) const;

2187 10 operator - 0 68 3612 22 LVecBase2i::operator - 0 1 192 0
53
inline LVecBase2i LVecBase2i::operator -(void) const;

2188 10 operator + 0 4 3612 22 LVecBase2i::operator + 0 1 193 0
72
inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &other) const;

2189 10 operator - 0 4 3612 22 LVecBase2i::operator - 0 1 194 0
72
inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &other) const;

2190 10 operator * 0 4 3612 22 LVecBase2i::operator * 0 1 195 0
59
inline LVecBase2i LVecBase2i::operator *(int scalar) const;

2191 10 operator / 0 4 3612 22 LVecBase2i::operator / 0 1 196 0
59
inline LVecBase2i LVecBase2i::operator /(int scalar) const;

2192 11 operator += 0 4 3612 23 LVecBase2i::operator += 0 1 197 0
61
inline void LVecBase2i::operator +=(LVecBase2i const &other);

2193 11 operator -= 0 4 3612 23 LVecBase2i::operator -= 0 1 198 0
61
inline void LVecBase2i::operator -=(LVecBase2i const &other);

2194 11 operator *= 0 4 3612 23 LVecBase2i::operator *= 0 1 199 0
48
inline void LVecBase2i::operator *=(int scalar);

2195 11 operator /= 0 4 3612 23 LVecBase2i::operator /= 0 1 200 0
48
inline void LVecBase2i::operator /=(int scalar);

2196 18 componentwise_mult 0 4 3612 30 LVecBase2i::componentwise_mult 0 1 201 10
/**
 *
 */
68
inline void LVecBase2i::componentwise_mult(LVecBase2i const &other);

2197 12 __floordiv__ 0 4 3612 24 LVecBase2i::__floordiv__ 0 1 202 0
76
inline PyObject *LVecBase2i::__floordiv__(PyObject *self, int scalar) const;

2198 13 __ifloordiv__ 0 4 3612 25 LVecBase2i::__ifloordiv__ 0 1 203 0
71
inline PyObject *LVecBase2i::__ifloordiv__(PyObject *self, int scalar);

2199 7 __pow__ 0 4 3612 19 LVecBase2i::__pow__ 0 1 204 0
73
inline PyObject *LVecBase2i::__pow__(PyObject *self, int exponent) const;

2200 8 __ipow__ 0 4 3612 20 LVecBase2i::__ipow__ 0 1 205 0
68
inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent);

2201 9 __round__ 0 4 3612 21 LVecBase2i::__round__ 0 1 206 0
55
inline PyObject *LVecBase2i::__round__(PyObject *self);

2202 9 __floor__ 0 4 3612 21 LVecBase2i::__floor__ 0 1 207 0
55
inline PyObject *LVecBase2i::__floor__(PyObject *self);

2203 8 __ceil__ 0 4 3612 20 LVecBase2i::__ceil__ 0 1 208 0
54
inline PyObject *LVecBase2i::__ceil__(PyObject *self);

2204 4 fmax 0 4 3612 16 LVecBase2i::fmax 0 1 209 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const;

2205 4 fmin 0 4 3612 16 LVecBase2i::fmin 0 1 210 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const;

2206 12 almost_equal 0 4 3612 24 LVecBase2i::almost_equal 0 2 211 212 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const;
inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const;

2207 6 output 0 4 3612 18 LVecBase2i::output 0 1 213 10
/**
 *
 */
56
inline void LVecBase2i::output(std::ostream &out) const;

2208 8 __repr__ 0 4 3612 20 LVecBase2i::__repr__ 0 1 214 0
52
inline std::string LVecBase2i::__repr__(void) const;

2209 20 write_datagram_fixed 0 4 3612 32 LVecBase2i::write_datagram_fixed 0 1 215 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const;

2210 19 read_datagram_fixed 0 4 3612 31 LVecBase2i::read_datagram_fixed 0 1 216 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source);

2211 14 write_datagram 0 4 3612 26 LVecBase2i::write_datagram 0 1 217 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2i::write_datagram(Datagram &destination) const;

2212 13 read_datagram 0 4 3612 25 LVecBase2i::read_datagram 0 1 218 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2i::read_datagram(DatagramIterator &source);

2213 14 get_class_type 0 4 3612 26 LVecBase2i::get_class_type 0 1 219 0
51
static TypeHandle LVecBase2i::get_class_type(void);

2214 11 ~LVecBase2i 0 516 3612 23 LVecBase2i::~LVecBase2i 0 0 0
30
LVecBase2i::~LVecBase2i(void);

2215 9 LVector2f 0 260 3615 20 LVector2f::LVector2f 0 5 220 221 222 223 224 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
249
inline LVector2f::LVector2f(void) = default;
inline LVector2f::LVector2f(LVecBase2f const &copy);
inline LVector2f::LVector2f(float fill_value);
inline LVector2f::LVector2f(float x, float y);
inline LVector2f::LVector2f(LVector2f const &) = default;

2216 11 __getattr__ 0 4 3615 22 LVector2f::__getattr__ 0 1 225 0
92
inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2217 11 __setattr__ 0 4 3615 22 LVector2f::__setattr__ 0 1 226 0
98
inline int LVector2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2218 4 zero 0 4 3615 15 LVector2f::zero 0 1 227 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2f const &LVector2f::zero(void);

2219 6 unit_x 0 4 3615 17 LVector2f::unit_x 0 1 228 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2f const &LVector2f::unit_x(void);

2220 6 unit_y 0 4 3615 17 LVector2f::unit_y 0 1 229 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2f const &LVector2f::unit_y(void);

2221 10 operator - 0 68 3615 21 LVector2f::operator - 0 1 230 0
51
inline LVector2f LVector2f::operator -(void) const;

2222 10 operator + 0 4 3615 21 LVector2f::operator + 0 2 231 232 0
141
inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator +(LVector2f const &other) const;

2223 10 operator - 0 4 3615 21 LVector2f::operator - 0 2 233 234 0
141
inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator -(LVector2f const &other) const;

2224 10 operator * 0 4 3615 21 LVector2f::operator * 0 1 235 0
59
inline LVector2f LVector2f::operator *(float scalar) const;

2225 10 operator / 0 4 3615 21 LVector2f::operator / 0 1 236 0
59
inline LVector2f LVector2f::operator /(float scalar) const;

2226 10 normalized 0 4 3615 21 LVector2f::normalized 0 1 237 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2f LVector2f::normalized(void) const;

2227 7 project 0 4 3615 18 LVector2f::project 0 1 238 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2f LVector2f::project(LVecBase2f const &onto) const;

2228 16 signed_angle_rad 0 4 3615 27 LVector2f::signed_angle_rad 0 1 239 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_rad(LVector2f const &other) const;

2229 16 signed_angle_deg 0 4 3615 27 LVector2f::signed_angle_deg 0 1 240 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_deg(LVector2f const &other) const;

2230 8 __repr__ 0 4 3615 19 LVector2f::__repr__ 0 1 241 0
51
inline std::string LVector2f::__repr__(void) const;

2231 14 get_class_type 0 4 3615 25 LVector2f::get_class_type 0 1 242 0
50
static TypeHandle LVector2f::get_class_type(void);

2232 10 ~LVector2f 0 516 3615 21 LVector2f::~LVector2f 0 0 0
28
LVector2f::~LVector2f(void);

2233 9 LVector2d 0 260 3616 20 LVector2d::LVector2d 0 5 243 244 245 246 247 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
252
inline LVector2d::LVector2d(void) = default;
inline LVector2d::LVector2d(LVecBase2d const &copy);
inline LVector2d::LVector2d(double fill_value);
inline LVector2d::LVector2d(double x, double y);
inline LVector2d::LVector2d(LVector2d const &) = default;

2234 11 __getattr__ 0 4 3616 22 LVector2d::__getattr__ 0 1 248 0
92
inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2235 11 __setattr__ 0 4 3616 22 LVector2d::__setattr__ 0 1 249 0
98
inline int LVector2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2236 4 zero 0 4 3616 15 LVector2d::zero 0 1 250 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2d const &LVector2d::zero(void);

2237 6 unit_x 0 4 3616 17 LVector2d::unit_x 0 1 251 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2d const &LVector2d::unit_x(void);

2238 6 unit_y 0 4 3616 17 LVector2d::unit_y 0 1 252 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2d const &LVector2d::unit_y(void);

2239 10 operator - 0 68 3616 21 LVector2d::operator - 0 1 253 0
51
inline LVector2d LVector2d::operator -(void) const;

2240 10 operator + 0 4 3616 21 LVector2d::operator + 0 2 254 255 0
141
inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator +(LVector2d const &other) const;

2241 10 operator - 0 4 3616 21 LVector2d::operator - 0 2 256 257 0
141
inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator -(LVector2d const &other) const;

2242 10 operator * 0 4 3616 21 LVector2d::operator * 0 1 258 0
60
inline LVector2d LVector2d::operator *(double scalar) const;

2243 10 operator / 0 4 3616 21 LVector2d::operator / 0 1 259 0
60
inline LVector2d LVector2d::operator /(double scalar) const;

2244 10 normalized 0 4 3616 21 LVector2d::normalized 0 1 260 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2d LVector2d::normalized(void) const;

2245 7 project 0 4 3616 18 LVector2d::project 0 1 261 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2d LVector2d::project(LVecBase2d const &onto) const;

2246 16 signed_angle_rad 0 4 3616 27 LVector2d::signed_angle_rad 0 1 262 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_rad(LVector2d const &other) const;

2247 16 signed_angle_deg 0 4 3616 27 LVector2d::signed_angle_deg 0 1 263 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_deg(LVector2d const &other) const;

2248 8 __repr__ 0 4 3616 19 LVector2d::__repr__ 0 1 264 0
51
inline std::string LVector2d::__repr__(void) const;

2249 14 get_class_type 0 4 3616 25 LVector2d::get_class_type 0 1 265 0
50
static TypeHandle LVector2d::get_class_type(void);

2250 10 ~LVector2d 0 516 3616 21 LVector2d::~LVector2d 0 0 0
28
LVector2d::~LVector2d(void);

2251 9 LVector2i 0 260 3617 20 LVector2i::LVector2i 0 5 266 267 268 269 270 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
243
inline LVector2i::LVector2i(void) = default;
inline LVector2i::LVector2i(LVecBase2i const &copy);
inline LVector2i::LVector2i(int fill_value);
inline LVector2i::LVector2i(int x, int y);
inline LVector2i::LVector2i(LVector2i const &) = default;

2252 11 __getattr__ 0 4 3617 22 LVector2i::__getattr__ 0 1 271 0
92
inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2253 11 __setattr__ 0 4 3617 22 LVector2i::__setattr__ 0 1 272 0
98
inline int LVector2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2254 4 zero 0 4 3617 15 LVector2i::zero 0 1 273 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2i const &LVector2i::zero(void);

2255 6 unit_x 0 4 3617 17 LVector2i::unit_x 0 1 274 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2i const &LVector2i::unit_x(void);

2256 6 unit_y 0 4 3617 17 LVector2i::unit_y 0 1 275 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2i const &LVector2i::unit_y(void);

2257 10 operator - 0 68 3617 21 LVector2i::operator - 0 1 276 0
51
inline LVector2i LVector2i::operator -(void) const;

2258 10 operator + 0 4 3617 21 LVector2i::operator + 0 2 277 278 0
141
inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator +(LVector2i const &other) const;

2259 10 operator - 0 4 3617 21 LVector2i::operator - 0 2 279 280 0
141
inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator -(LVector2i const &other) const;

2260 10 operator * 0 4 3617 21 LVector2i::operator * 0 1 281 0
57
inline LVector2i LVector2i::operator *(int scalar) const;

2261 10 operator / 0 4 3617 21 LVector2i::operator / 0 1 282 0
57
inline LVector2i LVector2i::operator /(int scalar) const;

2262 8 __repr__ 0 4 3617 19 LVector2i::__repr__ 0 1 283 0
51
inline std::string LVector2i::__repr__(void) const;

2263 14 get_class_type 0 4 3617 25 LVector2i::get_class_type 0 1 284 0
50
static TypeHandle LVector2i::get_class_type(void);

2264 10 ~LVector2i 0 516 3617 21 LVector2i::~LVector2i 0 0 0
28
LVector2i::~LVector2i(void);

2265 8 LPoint2f 0 260 3618 18 LPoint2f::LPoint2f 0 5 285 286 287 288 289 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
238
inline LPoint2f::LPoint2f(void) = default;
inline LPoint2f::LPoint2f(LVecBase2f const &copy);
inline LPoint2f::LPoint2f(float fill_value);
inline LPoint2f::LPoint2f(float x, float y);
inline LPoint2f::LPoint2f(LPoint2f const &) = default;

2266 11 __getattr__ 0 4 3618 21 LPoint2f::__getattr__ 0 1 290 0
91
inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2267 11 __setattr__ 0 4 3618 21 LPoint2f::__setattr__ 0 1 291 0
97
inline int LPoint2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2268 4 zero 0 4 3618 14 LPoint2f::zero 0 1 292 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2f const &LPoint2f::zero(void);

2269 6 unit_x 0 4 3618 16 LPoint2f::unit_x 0 1 293 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2f const &LPoint2f::unit_x(void);

2270 6 unit_y 0 4 3618 16 LPoint2f::unit_y 0 1 294 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2f const &LPoint2f::unit_y(void);

2271 10 operator - 0 68 3618 20 LPoint2f::operator - 0 1 295 0
49
inline LPoint2f LPoint2f::operator -(void) const;

2272 10 operator + 0 4 3618 20 LPoint2f::operator + 0 2 296 297 0
138
inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const;
inline LPoint2f LPoint2f::operator +(LVector2f const &other) const;

2273 10 operator - 0 4 3618 20 LPoint2f::operator - 0 3 298 299 300 0
206
inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const;
inline LVector2f LPoint2f::operator -(LPoint2f const &other) const;
inline LPoint2f LPoint2f::operator -(LVector2f const &other) const;

2274 10 operator * 0 4 3618 20 LPoint2f::operator * 0 1 301 0
57
inline LPoint2f LPoint2f::operator *(float scalar) const;

2275 10 operator / 0 4 3618 20 LPoint2f::operator / 0 1 302 0
57
inline LPoint2f LPoint2f::operator /(float scalar) const;

2276 10 normalized 0 4 3618 20 LPoint2f::normalized 0 1 303 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2f LPoint2f::normalized(void) const;

2277 7 project 0 4 3618 17 LPoint2f::project 0 1 304 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const;

2278 8 __repr__ 0 4 3618 18 LPoint2f::__repr__ 0 1 305 0
50
inline std::string LPoint2f::__repr__(void) const;

2279 14 get_class_type 0 4 3618 24 LPoint2f::get_class_type 0 1 306 0
49
static TypeHandle LPoint2f::get_class_type(void);

2280 9 ~LPoint2f 0 516 3618 19 LPoint2f::~LPoint2f 0 0 0
26
LPoint2f::~LPoint2f(void);

2281 8 LPoint2d 0 260 3619 18 LPoint2d::LPoint2d 0 5 307 308 309 310 311 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
241
inline LPoint2d::LPoint2d(void) = default;
inline LPoint2d::LPoint2d(LVecBase2d const &copy);
inline LPoint2d::LPoint2d(double fill_value);
inline LPoint2d::LPoint2d(double x, double y);
inline LPoint2d::LPoint2d(LPoint2d const &) = default;

2282 11 __getattr__ 0 4 3619 21 LPoint2d::__getattr__ 0 1 312 0
91
inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2283 11 __setattr__ 0 4 3619 21 LPoint2d::__setattr__ 0 1 313 0
97
inline int LPoint2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2284 4 zero 0 4 3619 14 LPoint2d::zero 0 1 314 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2d const &LPoint2d::zero(void);

2285 6 unit_x 0 4 3619 16 LPoint2d::unit_x 0 1 315 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2d const &LPoint2d::unit_x(void);

2286 6 unit_y 0 4 3619 16 LPoint2d::unit_y 0 1 316 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2d const &LPoint2d::unit_y(void);

2287 10 operator - 0 68 3619 20 LPoint2d::operator - 0 1 317 0
49
inline LPoint2d LPoint2d::operator -(void) const;

2288 10 operator + 0 4 3619 20 LPoint2d::operator + 0 2 318 319 0
138
inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const;
inline LPoint2d LPoint2d::operator +(LVector2d const &other) const;

2289 10 operator - 0 4 3619 20 LPoint2d::operator - 0 3 320 321 322 0
206
inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const;
inline LVector2d LPoint2d::operator -(LPoint2d const &other) const;
inline LPoint2d LPoint2d::operator -(LVector2d const &other) const;

2290 10 operator * 0 4 3619 20 LPoint2d::operator * 0 1 323 0
58
inline LPoint2d LPoint2d::operator *(double scalar) const;

2291 10 operator / 0 4 3619 20 LPoint2d::operator / 0 1 324 0
58
inline LPoint2d LPoint2d::operator /(double scalar) const;

2292 10 normalized 0 4 3619 20 LPoint2d::normalized 0 1 325 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2d LPoint2d::normalized(void) const;

2293 7 project 0 4 3619 17 LPoint2d::project 0 1 326 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const;

2294 8 __repr__ 0 4 3619 18 LPoint2d::__repr__ 0 1 327 0
50
inline std::string LPoint2d::__repr__(void) const;

2295 14 get_class_type 0 4 3619 24 LPoint2d::get_class_type 0 1 328 0
49
static TypeHandle LPoint2d::get_class_type(void);

2296 9 ~LPoint2d 0 516 3619 19 LPoint2d::~LPoint2d 0 0 0
26
LPoint2d::~LPoint2d(void);

2297 8 LPoint2i 0 260 3620 18 LPoint2i::LPoint2i 0 5 329 330 331 332 333 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
232
inline LPoint2i::LPoint2i(void) = default;
inline LPoint2i::LPoint2i(LVecBase2i const &copy);
inline LPoint2i::LPoint2i(int fill_value);
inline LPoint2i::LPoint2i(int x, int y);
inline LPoint2i::LPoint2i(LPoint2i const &) = default;

2298 11 __getattr__ 0 4 3620 21 LPoint2i::__getattr__ 0 1 334 0
91
inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2299 11 __setattr__ 0 4 3620 21 LPoint2i::__setattr__ 0 1 335 0
97
inline int LPoint2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2300 4 zero 0 4 3620 14 LPoint2i::zero 0 1 336 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2i const &LPoint2i::zero(void);

2301 6 unit_x 0 4 3620 16 LPoint2i::unit_x 0 1 337 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2i const &LPoint2i::unit_x(void);

2302 6 unit_y 0 4 3620 16 LPoint2i::unit_y 0 1 338 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2i const &LPoint2i::unit_y(void);

2303 10 operator - 0 68 3620 20 LPoint2i::operator - 0 1 339 0
49
inline LPoint2i LPoint2i::operator -(void) const;

2304 10 operator + 0 4 3620 20 LPoint2i::operator + 0 2 340 341 0
138
inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const;
inline LPoint2i LPoint2i::operator +(LVector2i const &other) const;

2305 10 operator - 0 4 3620 20 LPoint2i::operator - 0 3 342 343 344 0
206
inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const;
inline LVector2i LPoint2i::operator -(LPoint2i const &other) const;
inline LPoint2i LPoint2i::operator -(LVector2i const &other) const;

2306 10 operator * 0 4 3620 20 LPoint2i::operator * 0 1 345 0
55
inline LPoint2i LPoint2i::operator *(int scalar) const;

2307 10 operator / 0 4 3620 20 LPoint2i::operator / 0 1 346 0
55
inline LPoint2i LPoint2i::operator /(int scalar) const;

2308 8 __repr__ 0 4 3620 18 LPoint2i::__repr__ 0 1 347 0
50
inline std::string LPoint2i::__repr__(void) const;

2309 14 get_class_type 0 4 3620 24 LPoint2i::get_class_type 0 1 348 0
49
static TypeHandle LPoint2i::get_class_type(void);

2310 9 ~LPoint2i 0 516 3620 19 LPoint2i::~LPoint2i 0 0 0
26
LPoint2i::~LPoint2i(void);

2311 10 LVecBase3f 0 260 3621 22 LVecBase3f::LVecBase3f 0 5 349 350 351 352 353 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
278
inline LVecBase3f::LVecBase3f(void) = default;
inline LVecBase3f::LVecBase3f(float fill_value);
inline LVecBase3f::LVecBase3f(float x, float y, float z);
inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z);
inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default;

2312 12 operator new 0 4 3621 24 LVecBase3f::operator new 0 1 354 0
124
inline void *LVecBase3f::operator new(std::size_t size);
inline void *LVecBase3f::operator new(std::size_t size, void *ptr);

2313 15 operator delete 0 4 3621 27 LVecBase3f::operator delete 0 0 0
108
inline void LVecBase3f::operator delete(void *ptr);
inline void LVecBase3f::operator delete(void *, void *);

2314 12 validate_ptr 0 4 3621 24 LVecBase3f::validate_ptr 0 0 0
61
static inline bool LVecBase3f::validate_ptr(void const *ptr);

2315 10 operator = 0 4 3621 22 LVecBase3f::operator = 0 2 355 356 0
119
void LVecBase3f::operator =(LVecBase3f const &copy) = default;
void LVecBase3f::operator =(float fill_value) = default;

2316 4 zero 0 4 3621 16 LVecBase3f::zero 0 1 357 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3f const &LVecBase3f::zero(void);

2317 6 unit_x 0 4 3621 18 LVecBase3f::unit_x 0 1 358 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_x(void);

2318 6 unit_y 0 4 3621 18 LVecBase3f::unit_y 0 1 359 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_y(void);

2319 6 unit_z 0 4 3621 18 LVecBase3f::unit_z 0 1 360 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_z(void);

2320 10 __reduce__ 0 4 3621 22 LVecBase3f::__reduce__ 0 1 361 0
62
inline PyObject *LVecBase3f::__reduce__(PyObject *self) const;

2321 11 __getattr__ 0 4 3621 23 LVecBase3f::__getattr__ 0 1 362 0
93
inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2322 11 __setattr__ 0 4 3621 23 LVecBase3f::__setattr__ 0 1 363 0
99
inline int LVecBase3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2323 11 operator [] 0 4 3621 23 LVecBase3f::operator [] 0 2 364 365 10
/**
 *
 */
96
inline float LVecBase3f::operator [](int i) const;
inline float &LVecBase3f::operator [](int i);

2324 4 size 0 4 3621 16 LVecBase3f::size 0 1 366 0
44
static constexpr int LVecBase3f::size(void);

2325 6 is_nan 0 4 3621 18 LVecBase3f::is_nan 0 1 367 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3f::is_nan(void) const;

2326 8 get_cell 0 4 3621 20 LVecBase3f::get_cell 0 1 368 10
/**
 *
 */
47
inline float LVecBase3f::get_cell(int i) const;

2327 5 get_x 0 4 3621 17 LVecBase3f::get_x 0 1 369 10
/**
 *
 */
43
inline float LVecBase3f::get_x(void) const;

2328 5 get_y 0 4 3621 17 LVecBase3f::get_y 0 1 370 10
/**
 *
 */
43
inline float LVecBase3f::get_y(void) const;

2329 5 get_z 0 4 3621 17 LVecBase3f::get_z 0 1 371 10
/**
 *
 */
43
inline float LVecBase3f::get_z(void) const;

2330 8 set_cell 0 4 3621 20 LVecBase3f::set_cell 0 1 372 10
/**
 *
 */
53
inline void LVecBase3f::set_cell(int i, float value);

2331 5 set_x 0 4 3621 17 LVecBase3f::set_x 0 1 373 10
/**
 *
 */
43
inline void LVecBase3f::set_x(float value);

2332 5 set_y 0 4 3621 17 LVecBase3f::set_y 0 1 374 10
/**
 *
 */
43
inline void LVecBase3f::set_y(float value);

2333 5 set_z 0 4 3621 17 LVecBase3f::set_z 0 1 375 10
/**
 *
 */
43
inline void LVecBase3f::set_z(float value);

2334 6 get_xy 0 4 3621 18 LVecBase3f::get_xy 0 1 376 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xy(void) const;

2335 6 get_xz 0 4 3621 18 LVecBase3f::get_xz 0 1 377 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xz(void) const;

2336 6 get_yz 0 4 3621 18 LVecBase3f::get_yz 0 1 378 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_yz(void) const;

2337 11 add_to_cell 0 4 3621 23 LVecBase3f::add_to_cell 0 1 379 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase3f::add_to_cell(int i, float value);

2338 5 add_x 0 4 3621 17 LVecBase3f::add_x 0 1 380 10
/**
 *
 */
43
inline void LVecBase3f::add_x(float value);

2339 5 add_y 0 4 3621 17 LVecBase3f::add_y 0 1 381 10
/**
 *
 */
43
inline void LVecBase3f::add_y(float value);

2340 5 add_z 0 4 3621 17 LVecBase3f::add_z 0 1 382 10
/**
 *
 */
43
inline void LVecBase3f::add_z(float value);

2341 8 get_data 0 4 3621 20 LVecBase3f::get_data 0 1 383 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase3f::get_data(void) const;

2342 18 get_num_components 0 4 3621 30 LVecBase3f::get_num_components 0 1 384 0
58
static constexpr int LVecBase3f::get_num_components(void);

2343 4 fill 0 4 3621 16 LVecBase3f::fill 0 1 385 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase3f::fill(float fill_value);

2344 3 set 0 4 3621 15 LVecBase3f::set 0 1 386 10
/**
 *
 */
55
inline void LVecBase3f::set(float x, float y, float z);

2345 3 dot 0 4 3621 15 LVecBase3f::dot 0 1 387 10
/**
 *
 */
60
inline float LVecBase3f::dot(LVecBase3f const &other) const;

2346 14 length_squared 0 4 3621 26 LVecBase3f::length_squared 0 1 388 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase3f::length_squared(void) const;

2347 6 length 0 4 3621 18 LVecBase3f::length 0 1 389 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase3f::length(void) const;

2348 9 normalize 0 4 3621 21 LVecBase3f::normalize 0 1 390 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3f::normalize(void);

2349 10 normalized 0 4 3621 22 LVecBase3f::normalized 0 1 391 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3f LVecBase3f::normalized(void) const;

2350 7 project 0 4 3621 19 LVecBase3f::project 0 1 392 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const;

2351 5 cross 0 4 3621 17 LVecBase3f::cross 0 1 393 10
/**
 *
 */
67
inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const;

2352 10 operator < 0 4 3621 22 LVecBase3f::operator < 0 1 394 0
66
inline bool LVecBase3f::operator <(LVecBase3f const &other) const;

2353 11 operator == 0 4 3621 23 LVecBase3f::operator == 0 1 395 0
67
inline bool LVecBase3f::operator ==(LVecBase3f const &other) const;

2354 11 operator != 0 4 3621 23 LVecBase3f::operator != 0 1 396 0
67
inline bool LVecBase3f::operator !=(LVecBase3f const &other) const;

2355 20 get_standardized_hpr 0 4 3621 32 LVecBase3f::get_standardized_hpr 0 1 397 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const;

2356 10 compare_to 0 4 3621 22 LVecBase3f::compare_to 0 2 398 399 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase3f::compare_to(LVecBase3f const &other) const;
inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const;

2357 8 get_hash 0 4 3621 20 LVecBase3f::get_hash 0 2 400 401 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase3f::get_hash(void) const;
inline std::size_t LVecBase3f::get_hash(float threshold) const;

2358 8 add_hash 0 4 3621 20 LVecBase3f::add_hash 0 2 402 403 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase3f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const;

2359 13 generate_hash 0 4 3621 25 LVecBase3f::generate_hash 0 2 404 405 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2360 10 operator - 0 68 3621 22 LVecBase3f::operator - 0 1 406 0
53
inline LVecBase3f LVecBase3f::operator -(void) const;

2361 10 operator + 0 4 3621 22 LVecBase3f::operator + 0 1 407 0
72
inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &other) const;

2362 10 operator - 0 4 3621 22 LVecBase3f::operator - 0 1 408 0
72
inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &other) const;

2363 10 operator * 0 4 3621 22 LVecBase3f::operator * 0 1 409 0
61
inline LVecBase3f LVecBase3f::operator *(float scalar) const;

2364 10 operator / 0 4 3621 22 LVecBase3f::operator / 0 1 410 0
61
inline LVecBase3f LVecBase3f::operator /(float scalar) const;

2365 11 operator += 0 4 3621 23 LVecBase3f::operator += 0 1 411 0
61
inline void LVecBase3f::operator +=(LVecBase3f const &other);

2366 11 operator -= 0 4 3621 23 LVecBase3f::operator -= 0 1 412 0
61
inline void LVecBase3f::operator -=(LVecBase3f const &other);

2367 11 operator *= 0 4 3621 23 LVecBase3f::operator *= 0 1 413 0
50
inline void LVecBase3f::operator *=(float scalar);

2368 11 operator /= 0 4 3621 23 LVecBase3f::operator /= 0 1 414 0
50
inline void LVecBase3f::operator /=(float scalar);

2369 18 componentwise_mult 0 4 3621 30 LVecBase3f::componentwise_mult 0 1 415 10
/**
 *
 */
68
inline void LVecBase3f::componentwise_mult(LVecBase3f const &other);

2370 12 __floordiv__ 0 4 3621 24 LVecBase3f::__floordiv__ 0 1 416 0
78
inline PyObject *LVecBase3f::__floordiv__(PyObject *self, float scalar) const;

2371 13 __ifloordiv__ 0 4 3621 25 LVecBase3f::__ifloordiv__ 0 1 417 0
73
inline PyObject *LVecBase3f::__ifloordiv__(PyObject *self, float scalar);

2372 7 __pow__ 0 4 3621 19 LVecBase3f::__pow__ 0 1 418 0
75
inline PyObject *LVecBase3f::__pow__(PyObject *self, float exponent) const;

2373 8 __ipow__ 0 4 3621 20 LVecBase3f::__ipow__ 0 1 419 0
70
inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent);

2374 9 __round__ 0 4 3621 21 LVecBase3f::__round__ 0 1 420 0
55
inline PyObject *LVecBase3f::__round__(PyObject *self);

2375 9 __floor__ 0 4 3621 21 LVecBase3f::__floor__ 0 1 421 0
55
inline PyObject *LVecBase3f::__floor__(PyObject *self);

2376 8 __ceil__ 0 4 3621 20 LVecBase3f::__ceil__ 0 1 422 0
54
inline PyObject *LVecBase3f::__ceil__(PyObject *self);

2377 4 fmax 0 4 3621 16 LVecBase3f::fmax 0 1 423 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const;

2378 4 fmin 0 4 3621 16 LVecBase3f::fmin 0 1 424 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const;

2379 10 cross_into 0 4 3621 22 LVecBase3f::cross_into 0 1 425 10
/**
 *
 */
60
inline void LVecBase3f::cross_into(LVecBase3f const &other);

2380 12 almost_equal 0 4 3621 24 LVecBase3f::almost_equal 0 2 426 427 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const;
inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const;

2381 6 output 0 4 3621 18 LVecBase3f::output 0 1 428 10
/**
 *
 */
56
inline void LVecBase3f::output(std::ostream &out) const;

2382 8 __repr__ 0 4 3621 20 LVecBase3f::__repr__ 0 1 429 0
52
inline std::string LVecBase3f::__repr__(void) const;

2383 20 write_datagram_fixed 0 4 3621 32 LVecBase3f::write_datagram_fixed 0 1 430 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const;

2384 19 read_datagram_fixed 0 4 3621 31 LVecBase3f::read_datagram_fixed 0 1 431 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source);

2385 14 write_datagram 0 4 3621 26 LVecBase3f::write_datagram 0 1 432 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3f::write_datagram(Datagram &destination) const;

2386 13 read_datagram 0 4 3621 25 LVecBase3f::read_datagram 0 1 433 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3f::read_datagram(DatagramIterator &source);

2387 14 get_class_type 0 4 3621 26 LVecBase3f::get_class_type 0 1 434 0
51
static TypeHandle LVecBase3f::get_class_type(void);

2388 11 ~LVecBase3f 0 516 3621 23 LVecBase3f::~LVecBase3f 0 0 0
30
LVecBase3f::~LVecBase3f(void);

2389 10 LVecBase3d 0 260 3623 22 LVecBase3d::LVecBase3d 0 5 435 436 437 438 439 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
283
inline LVecBase3d::LVecBase3d(void) = default;
inline LVecBase3d::LVecBase3d(double fill_value);
inline LVecBase3d::LVecBase3d(double x, double y, double z);
inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z);
inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default;

2390 12 operator new 0 4 3623 24 LVecBase3d::operator new 0 1 440 0
124
inline void *LVecBase3d::operator new(std::size_t size);
inline void *LVecBase3d::operator new(std::size_t size, void *ptr);

2391 15 operator delete 0 4 3623 27 LVecBase3d::operator delete 0 0 0
108
inline void LVecBase3d::operator delete(void *ptr);
inline void LVecBase3d::operator delete(void *, void *);

2392 12 validate_ptr 0 4 3623 24 LVecBase3d::validate_ptr 0 0 0
61
static inline bool LVecBase3d::validate_ptr(void const *ptr);

2393 10 operator = 0 4 3623 22 LVecBase3d::operator = 0 2 441 442 0
120
void LVecBase3d::operator =(LVecBase3d const &copy) = default;
void LVecBase3d::operator =(double fill_value) = default;

2394 4 zero 0 4 3623 16 LVecBase3d::zero 0 1 443 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3d const &LVecBase3d::zero(void);

2395 6 unit_x 0 4 3623 18 LVecBase3d::unit_x 0 1 444 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_x(void);

2396 6 unit_y 0 4 3623 18 LVecBase3d::unit_y 0 1 445 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_y(void);

2397 6 unit_z 0 4 3623 18 LVecBase3d::unit_z 0 1 446 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_z(void);

2398 10 __reduce__ 0 4 3623 22 LVecBase3d::__reduce__ 0 1 447 0
62
inline PyObject *LVecBase3d::__reduce__(PyObject *self) const;

2399 11 __getattr__ 0 4 3623 23 LVecBase3d::__getattr__ 0 1 448 0
93
inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2400 11 __setattr__ 0 4 3623 23 LVecBase3d::__setattr__ 0 1 449 0
99
inline int LVecBase3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2401 11 operator [] 0 4 3623 23 LVecBase3d::operator [] 0 2 450 451 10
/**
 *
 */
98
inline double LVecBase3d::operator [](int i) const;
inline double &LVecBase3d::operator [](int i);

2402 4 size 0 4 3623 16 LVecBase3d::size 0 1 452 0
44
static constexpr int LVecBase3d::size(void);

2403 6 is_nan 0 4 3623 18 LVecBase3d::is_nan 0 1 453 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3d::is_nan(void) const;

2404 8 get_cell 0 4 3623 20 LVecBase3d::get_cell 0 1 454 10
/**
 *
 */
48
inline double LVecBase3d::get_cell(int i) const;

2405 5 get_x 0 4 3623 17 LVecBase3d::get_x 0 1 455 10
/**
 *
 */
44
inline double LVecBase3d::get_x(void) const;

2406 5 get_y 0 4 3623 17 LVecBase3d::get_y 0 1 456 10
/**
 *
 */
44
inline double LVecBase3d::get_y(void) const;

2407 5 get_z 0 4 3623 17 LVecBase3d::get_z 0 1 457 10
/**
 *
 */
44
inline double LVecBase3d::get_z(void) const;

2408 8 set_cell 0 4 3623 20 LVecBase3d::set_cell 0 1 458 10
/**
 *
 */
54
inline void LVecBase3d::set_cell(int i, double value);

2409 5 set_x 0 4 3623 17 LVecBase3d::set_x 0 1 459 10
/**
 *
 */
44
inline void LVecBase3d::set_x(double value);

2410 5 set_y 0 4 3623 17 LVecBase3d::set_y 0 1 460 10
/**
 *
 */
44
inline void LVecBase3d::set_y(double value);

2411 5 set_z 0 4 3623 17 LVecBase3d::set_z 0 1 461 10
/**
 *
 */
44
inline void LVecBase3d::set_z(double value);

2412 6 get_xy 0 4 3623 18 LVecBase3d::get_xy 0 1 462 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xy(void) const;

2413 6 get_xz 0 4 3623 18 LVecBase3d::get_xz 0 1 463 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xz(void) const;

2414 6 get_yz 0 4 3623 18 LVecBase3d::get_yz 0 1 464 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_yz(void) const;

2415 11 add_to_cell 0 4 3623 23 LVecBase3d::add_to_cell 0 1 465 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase3d::add_to_cell(int i, double value);

2416 5 add_x 0 4 3623 17 LVecBase3d::add_x 0 1 466 10
/**
 *
 */
44
inline void LVecBase3d::add_x(double value);

2417 5 add_y 0 4 3623 17 LVecBase3d::add_y 0 1 467 10
/**
 *
 */
44
inline void LVecBase3d::add_y(double value);

2418 5 add_z 0 4 3623 17 LVecBase3d::add_z 0 1 468 10
/**
 *
 */
44
inline void LVecBase3d::add_z(double value);

2419 8 get_data 0 4 3623 20 LVecBase3d::get_data 0 1 469 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase3d::get_data(void) const;

2420 18 get_num_components 0 4 3623 30 LVecBase3d::get_num_components 0 1 470 0
58
static constexpr int LVecBase3d::get_num_components(void);

2421 4 fill 0 4 3623 16 LVecBase3d::fill 0 1 471 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase3d::fill(double fill_value);

2422 3 set 0 4 3623 15 LVecBase3d::set 0 1 472 10
/**
 *
 */
58
inline void LVecBase3d::set(double x, double y, double z);

2423 3 dot 0 4 3623 15 LVecBase3d::dot 0 1 473 10
/**
 *
 */
61
inline double LVecBase3d::dot(LVecBase3d const &other) const;

2424 14 length_squared 0 4 3623 26 LVecBase3d::length_squared 0 1 474 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase3d::length_squared(void) const;

2425 6 length 0 4 3623 18 LVecBase3d::length 0 1 475 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase3d::length(void) const;

2426 9 normalize 0 4 3623 21 LVecBase3d::normalize 0 1 476 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3d::normalize(void);

2427 10 normalized 0 4 3623 22 LVecBase3d::normalized 0 1 477 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3d LVecBase3d::normalized(void) const;

2428 7 project 0 4 3623 19 LVecBase3d::project 0 1 478 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const;

2429 5 cross 0 4 3623 17 LVecBase3d::cross 0 1 479 10
/**
 *
 */
67
inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const;

2430 10 operator < 0 4 3623 22 LVecBase3d::operator < 0 1 480 0
66
inline bool LVecBase3d::operator <(LVecBase3d const &other) const;

2431 11 operator == 0 4 3623 23 LVecBase3d::operator == 0 1 481 0
67
inline bool LVecBase3d::operator ==(LVecBase3d const &other) const;

2432 11 operator != 0 4 3623 23 LVecBase3d::operator != 0 1 482 0
67
inline bool LVecBase3d::operator !=(LVecBase3d const &other) const;

2433 20 get_standardized_hpr 0 4 3623 32 LVecBase3d::get_standardized_hpr 0 1 483 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const;

2434 10 compare_to 0 4 3623 22 LVecBase3d::compare_to 0 2 484 485 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase3d::compare_to(LVecBase3d const &other) const;
inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const;

2435 8 get_hash 0 4 3623 20 LVecBase3d::get_hash 0 2 486 487 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase3d::get_hash(void) const;
inline std::size_t LVecBase3d::get_hash(double threshold) const;

2436 8 add_hash 0 4 3623 20 LVecBase3d::add_hash 0 2 488 489 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase3d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const;

2437 13 generate_hash 0 4 3623 25 LVecBase3d::generate_hash 0 2 490 491 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2438 10 operator - 0 68 3623 22 LVecBase3d::operator - 0 1 492 0
53
inline LVecBase3d LVecBase3d::operator -(void) const;

2439 10 operator + 0 4 3623 22 LVecBase3d::operator + 0 1 493 0
72
inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &other) const;

2440 10 operator - 0 4 3623 22 LVecBase3d::operator - 0 1 494 0
72
inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &other) const;

2441 10 operator * 0 4 3623 22 LVecBase3d::operator * 0 1 495 0
62
inline LVecBase3d LVecBase3d::operator *(double scalar) const;

2442 10 operator / 0 4 3623 22 LVecBase3d::operator / 0 1 496 0
62
inline LVecBase3d LVecBase3d::operator /(double scalar) const;

2443 11 operator += 0 4 3623 23 LVecBase3d::operator += 0 1 497 0
61
inline void LVecBase3d::operator +=(LVecBase3d const &other);

2444 11 operator -= 0 4 3623 23 LVecBase3d::operator -= 0 1 498 0
61
inline void LVecBase3d::operator -=(LVecBase3d const &other);

2445 11 operator *= 0 4 3623 23 LVecBase3d::operator *= 0 1 499 0
51
inline void LVecBase3d::operator *=(double scalar);

2446 11 operator /= 0 4 3623 23 LVecBase3d::operator /= 0 1 500 0
51
inline void LVecBase3d::operator /=(double scalar);

2447 18 componentwise_mult 0 4 3623 30 LVecBase3d::componentwise_mult 0 1 501 10
/**
 *
 */
68
inline void LVecBase3d::componentwise_mult(LVecBase3d const &other);

2448 12 __floordiv__ 0 4 3623 24 LVecBase3d::__floordiv__ 0 1 502 0
79
inline PyObject *LVecBase3d::__floordiv__(PyObject *self, double scalar) const;

2449 13 __ifloordiv__ 0 4 3623 25 LVecBase3d::__ifloordiv__ 0 1 503 0
74
inline PyObject *LVecBase3d::__ifloordiv__(PyObject *self, double scalar);

2450 7 __pow__ 0 4 3623 19 LVecBase3d::__pow__ 0 1 504 0
76
inline PyObject *LVecBase3d::__pow__(PyObject *self, double exponent) const;

2451 8 __ipow__ 0 4 3623 20 LVecBase3d::__ipow__ 0 1 505 0
71
inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent);

2452 9 __round__ 0 4 3623 21 LVecBase3d::__round__ 0 1 506 0
55
inline PyObject *LVecBase3d::__round__(PyObject *self);

2453 9 __floor__ 0 4 3623 21 LVecBase3d::__floor__ 0 1 507 0
55
inline PyObject *LVecBase3d::__floor__(PyObject *self);

2454 8 __ceil__ 0 4 3623 20 LVecBase3d::__ceil__ 0 1 508 0
54
inline PyObject *LVecBase3d::__ceil__(PyObject *self);

2455 4 fmax 0 4 3623 16 LVecBase3d::fmax 0 1 509 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const;

2456 4 fmin 0 4 3623 16 LVecBase3d::fmin 0 1 510 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const;

2457 10 cross_into 0 4 3623 22 LVecBase3d::cross_into 0 1 511 10
/**
 *
 */
60
inline void LVecBase3d::cross_into(LVecBase3d const &other);

2458 12 almost_equal 0 4 3623 24 LVecBase3d::almost_equal 0 2 512 513 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const;
inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const;

2459 6 output 0 4 3623 18 LVecBase3d::output 0 1 514 10
/**
 *
 */
56
inline void LVecBase3d::output(std::ostream &out) const;

2460 8 __repr__ 0 4 3623 20 LVecBase3d::__repr__ 0 1 515 0
52
inline std::string LVecBase3d::__repr__(void) const;

2461 20 write_datagram_fixed 0 4 3623 32 LVecBase3d::write_datagram_fixed 0 1 516 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const;

2462 19 read_datagram_fixed 0 4 3623 31 LVecBase3d::read_datagram_fixed 0 1 517 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source);

2463 14 write_datagram 0 4 3623 26 LVecBase3d::write_datagram 0 1 518 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3d::write_datagram(Datagram &destination) const;

2464 13 read_datagram 0 4 3623 25 LVecBase3d::read_datagram 0 1 519 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3d::read_datagram(DatagramIterator &source);

2465 14 get_class_type 0 4 3623 26 LVecBase3d::get_class_type 0 1 520 0
51
static TypeHandle LVecBase3d::get_class_type(void);

2466 11 ~LVecBase3d 0 516 3623 23 LVecBase3d::~LVecBase3d 0 0 0
30
LVecBase3d::~LVecBase3d(void);

2467 10 LVecBase3i 0 260 3625 22 LVecBase3i::LVecBase3i 0 5 521 522 523 524 525 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
268
inline LVecBase3i::LVecBase3i(void) = default;
inline LVecBase3i::LVecBase3i(int fill_value);
inline LVecBase3i::LVecBase3i(int x, int y, int z);
inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z);
inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default;

2468 12 operator new 0 4 3625 24 LVecBase3i::operator new 0 1 526 0
124
inline void *LVecBase3i::operator new(std::size_t size);
inline void *LVecBase3i::operator new(std::size_t size, void *ptr);

2469 15 operator delete 0 4 3625 27 LVecBase3i::operator delete 0 0 0
108
inline void LVecBase3i::operator delete(void *ptr);
inline void LVecBase3i::operator delete(void *, void *);

2470 12 validate_ptr 0 4 3625 24 LVecBase3i::validate_ptr 0 0 0
61
static inline bool LVecBase3i::validate_ptr(void const *ptr);

2471 10 operator = 0 4 3625 22 LVecBase3i::operator = 0 2 527 528 0
117
void LVecBase3i::operator =(LVecBase3i const &copy) = default;
void LVecBase3i::operator =(int fill_value) = default;

2472 4 zero 0 4 3625 16 LVecBase3i::zero 0 1 529 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3i const &LVecBase3i::zero(void);

2473 6 unit_x 0 4 3625 18 LVecBase3i::unit_x 0 1 530 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_x(void);

2474 6 unit_y 0 4 3625 18 LVecBase3i::unit_y 0 1 531 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_y(void);

2475 6 unit_z 0 4 3625 18 LVecBase3i::unit_z 0 1 532 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_z(void);

2476 10 __reduce__ 0 4 3625 22 LVecBase3i::__reduce__ 0 1 533 0
62
inline PyObject *LVecBase3i::__reduce__(PyObject *self) const;

2477 11 __getattr__ 0 4 3625 23 LVecBase3i::__getattr__ 0 1 534 0
93
inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2478 11 __setattr__ 0 4 3625 23 LVecBase3i::__setattr__ 0 1 535 0
99
inline int LVecBase3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2479 11 operator [] 0 4 3625 23 LVecBase3i::operator [] 0 2 536 537 10
/**
 *
 */
92
inline int LVecBase3i::operator [](int i) const;
inline int &LVecBase3i::operator [](int i);

2480 4 size 0 4 3625 16 LVecBase3i::size 0 1 538 0
44
static constexpr int LVecBase3i::size(void);

2481 6 is_nan 0 4 3625 18 LVecBase3i::is_nan 0 1 539 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3i::is_nan(void) const;

2482 8 get_cell 0 4 3625 20 LVecBase3i::get_cell 0 1 540 10
/**
 *
 */
45
inline int LVecBase3i::get_cell(int i) const;

2483 5 get_x 0 4 3625 17 LVecBase3i::get_x 0 1 541 10
/**
 *
 */
41
inline int LVecBase3i::get_x(void) const;

2484 5 get_y 0 4 3625 17 LVecBase3i::get_y 0 1 542 10
/**
 *
 */
41
inline int LVecBase3i::get_y(void) const;

2485 5 get_z 0 4 3625 17 LVecBase3i::get_z 0 1 543 10
/**
 *
 */
41
inline int LVecBase3i::get_z(void) const;

2486 8 set_cell 0 4 3625 20 LVecBase3i::set_cell 0 1 544 10
/**
 *
 */
51
inline void LVecBase3i::set_cell(int i, int value);

2487 5 set_x 0 4 3625 17 LVecBase3i::set_x 0 1 545 10
/**
 *
 */
41
inline void LVecBase3i::set_x(int value);

2488 5 set_y 0 4 3625 17 LVecBase3i::set_y 0 1 546 10
/**
 *
 */
41
inline void LVecBase3i::set_y(int value);

2489 5 set_z 0 4 3625 17 LVecBase3i::set_z 0 1 547 10
/**
 *
 */
41
inline void LVecBase3i::set_z(int value);

2490 6 get_xy 0 4 3625 18 LVecBase3i::get_xy 0 1 548 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xy(void) const;

2491 6 get_xz 0 4 3625 18 LVecBase3i::get_xz 0 1 549 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xz(void) const;

2492 6 get_yz 0 4 3625 18 LVecBase3i::get_yz 0 1 550 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_yz(void) const;

2493 11 add_to_cell 0 4 3625 23 LVecBase3i::add_to_cell 0 1 551 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase3i::add_to_cell(int i, int value);

2494 5 add_x 0 4 3625 17 LVecBase3i::add_x 0 1 552 10
/**
 *
 */
41
inline void LVecBase3i::add_x(int value);

2495 5 add_y 0 4 3625 17 LVecBase3i::add_y 0 1 553 10
/**
 *
 */
41
inline void LVecBase3i::add_y(int value);

2496 5 add_z 0 4 3625 17 LVecBase3i::add_z 0 1 554 10
/**
 *
 */
41
inline void LVecBase3i::add_z(int value);

2497 8 get_data 0 4 3625 20 LVecBase3i::get_data 0 1 555 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase3i::get_data(void) const;

2498 18 get_num_components 0 4 3625 30 LVecBase3i::get_num_components 0 1 556 0
58
static constexpr int LVecBase3i::get_num_components(void);

2499 4 fill 0 4 3625 16 LVecBase3i::fill 0 1 557 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase3i::fill(int fill_value);

2500 3 set 0 4 3625 15 LVecBase3i::set 0 1 558 10
/**
 *
 */
49
inline void LVecBase3i::set(int x, int y, int z);

2501 3 dot 0 4 3625 15 LVecBase3i::dot 0 1 559 10
/**
 *
 */
58
inline int LVecBase3i::dot(LVecBase3i const &other) const;

2502 14 length_squared 0 4 3625 26 LVecBase3i::length_squared 0 1 560 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase3i::length_squared(void) const;

2503 5 cross 0 4 3625 17 LVecBase3i::cross 0 1 561 10
/**
 *
 */
67
inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const;

2504 10 operator < 0 4 3625 22 LVecBase3i::operator < 0 1 562 0
66
inline bool LVecBase3i::operator <(LVecBase3i const &other) const;

2505 11 operator == 0 4 3625 23 LVecBase3i::operator == 0 1 563 0
67
inline bool LVecBase3i::operator ==(LVecBase3i const &other) const;

2506 11 operator != 0 4 3625 23 LVecBase3i::operator != 0 1 564 0
67
inline bool LVecBase3i::operator !=(LVecBase3i const &other) const;

2507 10 compare_to 0 4 3625 22 LVecBase3i::compare_to 0 1 565 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase3i::compare_to(LVecBase3i const &other) const;

2508 8 get_hash 0 4 3625 20 LVecBase3i::get_hash 0 1 566 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase3i::get_hash(void) const;

2509 8 add_hash 0 4 3625 20 LVecBase3i::add_hash 0 1 567 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase3i::add_hash(std::size_t hash) const;

2510 13 generate_hash 0 4 3625 25 LVecBase3i::generate_hash 0 1 568 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase3i::generate_hash(ChecksumHashGenerator &hashgen) const;

2511 10 operator - 0 68 3625 22 LVecBase3i::operator - 0 1 569 0
53
inline LVecBase3i LVecBase3i::operator -(void) const;

2512 10 operator + 0 4 3625 22 LVecBase3i::operator + 0 1 570 0
72
inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &other) const;

2513 10 operator - 0 4 3625 22 LVecBase3i::operator - 0 1 571 0
72
inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &other) const;

2514 10 operator * 0 4 3625 22 LVecBase3i::operator * 0 1 572 0
59
inline LVecBase3i LVecBase3i::operator *(int scalar) const;

2515 10 operator / 0 4 3625 22 LVecBase3i::operator / 0 1 573 0
59
inline LVecBase3i LVecBase3i::operator /(int scalar) const;

2516 11 operator += 0 4 3625 23 LVecBase3i::operator += 0 1 574 0
61
inline void LVecBase3i::operator +=(LVecBase3i const &other);

2517 11 operator -= 0 4 3625 23 LVecBase3i::operator -= 0 1 575 0
61
inline void LVecBase3i::operator -=(LVecBase3i const &other);

2518 11 operator *= 0 4 3625 23 LVecBase3i::operator *= 0 1 576 0
48
inline void LVecBase3i::operator *=(int scalar);

2519 11 operator /= 0 4 3625 23 LVecBase3i::operator /= 0 1 577 0
48
inline void LVecBase3i::operator /=(int scalar);

2520 18 componentwise_mult 0 4 3625 30 LVecBase3i::componentwise_mult 0 1 578 10
/**
 *
 */
68
inline void LVecBase3i::componentwise_mult(LVecBase3i const &other);

2521 12 __floordiv__ 0 4 3625 24 LVecBase3i::__floordiv__ 0 1 579 0
76
inline PyObject *LVecBase3i::__floordiv__(PyObject *self, int scalar) const;

2522 13 __ifloordiv__ 0 4 3625 25 LVecBase3i::__ifloordiv__ 0 1 580 0
71
inline PyObject *LVecBase3i::__ifloordiv__(PyObject *self, int scalar);

2523 7 __pow__ 0 4 3625 19 LVecBase3i::__pow__ 0 1 581 0
73
inline PyObject *LVecBase3i::__pow__(PyObject *self, int exponent) const;

2524 8 __ipow__ 0 4 3625 20 LVecBase3i::__ipow__ 0 1 582 0
68
inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent);

2525 9 __round__ 0 4 3625 21 LVecBase3i::__round__ 0 1 583 0
55
inline PyObject *LVecBase3i::__round__(PyObject *self);

2526 9 __floor__ 0 4 3625 21 LVecBase3i::__floor__ 0 1 584 0
55
inline PyObject *LVecBase3i::__floor__(PyObject *self);

2527 8 __ceil__ 0 4 3625 20 LVecBase3i::__ceil__ 0 1 585 0
54
inline PyObject *LVecBase3i::__ceil__(PyObject *self);

2528 4 fmax 0 4 3625 16 LVecBase3i::fmax 0 1 586 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const;

2529 4 fmin 0 4 3625 16 LVecBase3i::fmin 0 1 587 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const;

2530 10 cross_into 0 4 3625 22 LVecBase3i::cross_into 0 1 588 10
/**
 *
 */
60
inline void LVecBase3i::cross_into(LVecBase3i const &other);

2531 12 almost_equal 0 4 3625 24 LVecBase3i::almost_equal 0 2 589 590 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const;
inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const;

2532 6 output 0 4 3625 18 LVecBase3i::output 0 1 591 10
/**
 *
 */
56
inline void LVecBase3i::output(std::ostream &out) const;

2533 8 __repr__ 0 4 3625 20 LVecBase3i::__repr__ 0 1 592 0
52
inline std::string LVecBase3i::__repr__(void) const;

2534 20 write_datagram_fixed 0 4 3625 32 LVecBase3i::write_datagram_fixed 0 1 593 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const;

2535 19 read_datagram_fixed 0 4 3625 31 LVecBase3i::read_datagram_fixed 0 1 594 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source);

2536 14 write_datagram 0 4 3625 26 LVecBase3i::write_datagram 0 1 595 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3i::write_datagram(Datagram &destination) const;

2537 13 read_datagram 0 4 3625 25 LVecBase3i::read_datagram 0 1 596 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3i::read_datagram(DatagramIterator &source);

2538 14 get_class_type 0 4 3625 26 LVecBase3i::get_class_type 0 1 597 0
51
static TypeHandle LVecBase3i::get_class_type(void);

2539 11 ~LVecBase3i 0 516 3625 23 LVecBase3i::~LVecBase3i 0 0 0
30
LVecBase3i::~LVecBase3i(void);

2540 29 get_default_coordinate_system 0 1 0 29 get_default_coordinate_system 0 1 1925 0
53
CoordinateSystem get_default_coordinate_system(void);

2541 30 parse_coordinate_system_string 0 1 0 30 parse_coordinate_system_string 0 1 1926 0
72
CoordinateSystem parse_coordinate_system_string(std::string const &str);

2542 24 format_coordinate_system 0 1 0 24 format_coordinate_system 0 1 1927 0
58
std::string format_coordinate_system(CoordinateSystem cs);

2543 15 is_right_handed 0 1 0 15 is_right_handed 0 1 1928 0
57
bool is_right_handed(CoordinateSystem cs = ::CS_default);

2544 9 LVector3f 0 260 3628 20 LVector3f::LVector3f 0 6 598 599 600 601 602 603 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
320
inline LVector3f::LVector3f(void) = default;
inline LVector3f::LVector3f(LVecBase3f const &copy);
inline LVector3f::LVector3f(float fill_value);
inline LVector3f::LVector3f(float x, float y, float z);
inline LVector3f::LVector3f(LVecBase2f const &copy, float z);
inline LVector3f::LVector3f(LVector3f const &) = default;

2545 11 __getattr__ 0 4 3628 22 LVector3f::__getattr__ 0 1 604 0
92
inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2546 11 __setattr__ 0 4 3628 22 LVector3f::__setattr__ 0 1 605 0
98
inline int LVector3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2547 4 zero 0 4 3628 15 LVector3f::zero 0 1 606 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3f const &LVector3f::zero(void);

2548 6 unit_x 0 4 3628 17 LVector3f::unit_x 0 1 607 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3f const &LVector3f::unit_x(void);

2549 6 unit_y 0 4 3628 17 LVector3f::unit_y 0 1 608 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3f const &LVector3f::unit_y(void);

2550 6 unit_z 0 4 3628 17 LVector3f::unit_z 0 1 609 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3f const &LVector3f::unit_z(void);

2551 6 get_xy 0 4 3628 17 LVector3f::get_xy 0 1 610 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_xy(void) const;

2552 6 get_xz 0 4 3628 17 LVector3f::get_xz 0 1 611 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2f LVector3f::get_xz(void) const;

2553 6 get_yz 0 4 3628 17 LVector3f::get_yz 0 1 612 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_yz(void) const;

2554 10 operator - 0 68 3628 21 LVector3f::operator - 0 1 613 0
51
inline LVector3f LVector3f::operator -(void) const;

2555 10 operator + 0 4 3628 21 LVector3f::operator + 0 2 614 615 0
141
inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator +(LVector3f const &other) const;

2556 10 operator - 0 4 3628 21 LVector3f::operator - 0 2 616 617 0
141
inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator -(LVector3f const &other) const;

2557 5 cross 0 4 3628 16 LVector3f::cross 0 1 618 10
/**
 *
 */
65
inline LVector3f LVector3f::cross(LVecBase3f const &other) const;

2558 10 normalized 0 4 3628 21 LVector3f::normalized 0 1 619 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3f LVector3f::normalized(void) const;

2559 7 project 0 4 3628 18 LVector3f::project 0 1 620 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3f LVector3f::project(LVecBase3f const &onto) const;

2560 9 angle_rad 0 4 3628 20 LVector3f::angle_rad 0 1 621 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_rad(LVector3f const &other) const;

2561 9 angle_deg 0 4 3628 20 LVector3f::angle_deg 0 1 622 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_deg(LVector3f const &other) const;

2562 16 signed_angle_rad 0 4 3628 27 LVector3f::signed_angle_rad 0 1 623 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const;

2563 16 signed_angle_deg 0 4 3628 27 LVector3f::signed_angle_deg 0 1 624 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const;

2564 18 relative_angle_rad 0 4 3628 29 LVector3f::relative_angle_rad 0 1 625 34
/**
 * @deprecated Do not use.
 */
73
inline float LVector3f::relative_angle_rad(LVector3f const &other) const;

2565 18 relative_angle_deg 0 4 3628 29 LVector3f::relative_angle_deg 0 1 626 34
/**
 * @deprecated Do not use.
 */
73
inline float LVector3f::relative_angle_deg(LVector3f const &other) const;

2566 10 operator * 0 4 3628 21 LVector3f::operator * 0 1 627 0
59
inline LVector3f LVector3f::operator *(float scalar) const;

2567 10 operator / 0 4 3628 21 LVector3f::operator / 0 1 628 0
59
inline LVector3f LVector3f::operator /(float scalar) const;

2568 2 up 0 4 3628 13 LVector3f::up 0 1 629 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default);

2569 5 right 0 4 3628 16 LVector3f::right 0 1 630 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default);

2570 7 forward 0 4 3628 18 LVector3f::forward 0 1 631 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default);

2571 4 down 0 4 3628 15 LVector3f::down 0 1 632 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default);

2572 4 left 0 4 3628 15 LVector3f::left 0 1 633 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default);

2573 4 back 0 4 3628 15 LVector3f::back 0 1 634 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default);

2574 3 rfu 0 4 3628 14 LVector3f::rfu 0 1 635 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
109
static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2575 8 __repr__ 0 4 3628 19 LVector3f::__repr__ 0 1 636 0
51
inline std::string LVector3f::__repr__(void) const;

2576 14 get_class_type 0 4 3628 25 LVector3f::get_class_type 0 1 637 0
50
static TypeHandle LVector3f::get_class_type(void);

2577 10 ~LVector3f 0 516 3628 21 LVector3f::~LVector3f 0 0 0
28
LVector3f::~LVector3f(void);

2578 9 LVector3d 0 260 3629 20 LVector3d::LVector3d 0 6 638 639 640 641 642 643 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
325
inline LVector3d::LVector3d(void) = default;
inline LVector3d::LVector3d(LVecBase3d const &copy);
inline LVector3d::LVector3d(double fill_value);
inline LVector3d::LVector3d(double x, double y, double z);
inline LVector3d::LVector3d(LVecBase2d const &copy, double z);
inline LVector3d::LVector3d(LVector3d const &) = default;

2579 11 __getattr__ 0 4 3629 22 LVector3d::__getattr__ 0 1 644 0
92
inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2580 11 __setattr__ 0 4 3629 22 LVector3d::__setattr__ 0 1 645 0
98
inline int LVector3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2581 4 zero 0 4 3629 15 LVector3d::zero 0 1 646 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3d const &LVector3d::zero(void);

2582 6 unit_x 0 4 3629 17 LVector3d::unit_x 0 1 647 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3d const &LVector3d::unit_x(void);

2583 6 unit_y 0 4 3629 17 LVector3d::unit_y 0 1 648 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3d const &LVector3d::unit_y(void);

2584 6 unit_z 0 4 3629 17 LVector3d::unit_z 0 1 649 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3d const &LVector3d::unit_z(void);

2585 6 get_xy 0 4 3629 17 LVector3d::get_xy 0 1 650 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_xy(void) const;

2586 6 get_xz 0 4 3629 17 LVector3d::get_xz 0 1 651 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2d LVector3d::get_xz(void) const;

2587 6 get_yz 0 4 3629 17 LVector3d::get_yz 0 1 652 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_yz(void) const;

2588 10 operator - 0 68 3629 21 LVector3d::operator - 0 1 653 0
51
inline LVector3d LVector3d::operator -(void) const;

2589 10 operator + 0 4 3629 21 LVector3d::operator + 0 2 654 655 0
141
inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator +(LVector3d const &other) const;

2590 10 operator - 0 4 3629 21 LVector3d::operator - 0 2 656 657 0
141
inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator -(LVector3d const &other) const;

2591 5 cross 0 4 3629 16 LVector3d::cross 0 1 658 10
/**
 *
 */
65
inline LVector3d LVector3d::cross(LVecBase3d const &other) const;

2592 10 normalized 0 4 3629 21 LVector3d::normalized 0 1 659 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3d LVector3d::normalized(void) const;

2593 7 project 0 4 3629 18 LVector3d::project 0 1 660 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3d LVector3d::project(LVecBase3d const &onto) const;

2594 9 angle_rad 0 4 3629 20 LVector3d::angle_rad 0 1 661 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_rad(LVector3d const &other) const;

2595 9 angle_deg 0 4 3629 20 LVector3d::angle_deg 0 1 662 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_deg(LVector3d const &other) const;

2596 16 signed_angle_rad 0 4 3629 27 LVector3d::signed_angle_rad 0 1 663 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const;

2597 16 signed_angle_deg 0 4 3629 27 LVector3d::signed_angle_deg 0 1 664 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const;

2598 18 relative_angle_rad 0 4 3629 29 LVector3d::relative_angle_rad 0 1 665 34
/**
 * @deprecated Do not use.
 */
74
inline double LVector3d::relative_angle_rad(LVector3d const &other) const;

2599 18 relative_angle_deg 0 4 3629 29 LVector3d::relative_angle_deg 0 1 666 34
/**
 * @deprecated Do not use.
 */
74
inline double LVector3d::relative_angle_deg(LVector3d const &other) const;

2600 10 operator * 0 4 3629 21 LVector3d::operator * 0 1 667 0
60
inline LVector3d LVector3d::operator *(double scalar) const;

2601 10 operator / 0 4 3629 21 LVector3d::operator / 0 1 668 0
60
inline LVector3d LVector3d::operator /(double scalar) const;

2602 2 up 0 4 3629 13 LVector3d::up 0 1 669 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default);

2603 5 right 0 4 3629 16 LVector3d::right 0 1 670 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default);

2604 7 forward 0 4 3629 18 LVector3d::forward 0 1 671 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default);

2605 4 down 0 4 3629 15 LVector3d::down 0 1 672 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default);

2606 4 left 0 4 3629 15 LVector3d::left 0 1 673 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default);

2607 4 back 0 4 3629 15 LVector3d::back 0 1 674 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default);

2608 3 rfu 0 4 3629 14 LVector3d::rfu 0 1 675 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
112
static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2609 8 __repr__ 0 4 3629 19 LVector3d::__repr__ 0 1 676 0
51
inline std::string LVector3d::__repr__(void) const;

2610 14 get_class_type 0 4 3629 25 LVector3d::get_class_type 0 1 677 0
50
static TypeHandle LVector3d::get_class_type(void);

2611 10 ~LVector3d 0 516 3629 21 LVector3d::~LVector3d 0 0 0
28
LVector3d::~LVector3d(void);

2612 9 LVector3i 0 260 3630 20 LVector3i::LVector3i 0 6 678 679 680 681 682 683 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LVector3i::LVector3i(void) = default;
inline LVector3i::LVector3i(LVecBase3i const &copy);
inline LVector3i::LVector3i(int fill_value);
inline LVector3i::LVector3i(int x, int y, int z);
inline LVector3i::LVector3i(LVecBase2i const &copy, int z);
inline LVector3i::LVector3i(LVector3i const &) = default;

2613 11 __getattr__ 0 4 3630 22 LVector3i::__getattr__ 0 1 684 0
92
inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2614 11 __setattr__ 0 4 3630 22 LVector3i::__setattr__ 0 1 685 0
98
inline int LVector3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2615 4 zero 0 4 3630 15 LVector3i::zero 0 1 686 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3i const &LVector3i::zero(void);

2616 6 unit_x 0 4 3630 17 LVector3i::unit_x 0 1 687 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3i const &LVector3i::unit_x(void);

2617 6 unit_y 0 4 3630 17 LVector3i::unit_y 0 1 688 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3i const &LVector3i::unit_y(void);

2618 6 unit_z 0 4 3630 17 LVector3i::unit_z 0 1 689 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3i const &LVector3i::unit_z(void);

2619 6 get_xy 0 4 3630 17 LVector3i::get_xy 0 1 690 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_xy(void) const;

2620 6 get_xz 0 4 3630 17 LVector3i::get_xz 0 1 691 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2i LVector3i::get_xz(void) const;

2621 6 get_yz 0 4 3630 17 LVector3i::get_yz 0 1 692 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_yz(void) const;

2622 10 operator - 0 68 3630 21 LVector3i::operator - 0 1 693 0
51
inline LVector3i LVector3i::operator -(void) const;

2623 10 operator + 0 4 3630 21 LVector3i::operator + 0 2 694 695 0
141
inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator +(LVector3i const &other) const;

2624 10 operator - 0 4 3630 21 LVector3i::operator - 0 2 696 697 0
141
inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator -(LVector3i const &other) const;

2625 5 cross 0 4 3630 16 LVector3i::cross 0 1 698 10
/**
 *
 */
65
inline LVector3i LVector3i::cross(LVecBase3i const &other) const;

2626 10 operator * 0 4 3630 21 LVector3i::operator * 0 1 699 0
57
inline LVector3i LVector3i::operator *(int scalar) const;

2627 10 operator / 0 4 3630 21 LVector3i::operator / 0 1 700 0
57
inline LVector3i LVector3i::operator /(int scalar) const;

2628 2 up 0 4 3630 13 LVector3i::up 0 1 701 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default);

2629 5 right 0 4 3630 16 LVector3i::right 0 1 702 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default);

2630 7 forward 0 4 3630 18 LVector3i::forward 0 1 703 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default);

2631 4 down 0 4 3630 15 LVector3i::down 0 1 704 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default);

2632 4 left 0 4 3630 15 LVector3i::left 0 1 705 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default);

2633 4 back 0 4 3630 15 LVector3i::back 0 1 706 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default);

2634 3 rfu 0 4 3630 14 LVector3i::rfu 0 1 707 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
103
static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2635 8 __repr__ 0 4 3630 19 LVector3i::__repr__ 0 1 708 0
51
inline std::string LVector3i::__repr__(void) const;

2636 14 get_class_type 0 4 3630 25 LVector3i::get_class_type 0 1 709 0
50
static TypeHandle LVector3i::get_class_type(void);

2637 10 ~LVector3i 0 516 3630 21 LVector3i::~LVector3i 0 0 0
28
LVector3i::~LVector3i(void);

2638 8 LPoint3f 0 260 3631 18 LPoint3f::LPoint3f 0 6 710 711 712 713 714 715 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
307
inline LPoint3f::LPoint3f(void) = default;
inline LPoint3f::LPoint3f(LVecBase3f const &copy);
inline LPoint3f::LPoint3f(float fill_value);
inline LPoint3f::LPoint3f(float x, float y, float z);
inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z);
inline LPoint3f::LPoint3f(LPoint3f const &) = default;

2639 11 __getattr__ 0 4 3631 21 LPoint3f::__getattr__ 0 1 716 0
91
inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2640 11 __setattr__ 0 4 3631 21 LPoint3f::__setattr__ 0 1 717 0
97
inline int LPoint3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2641 4 zero 0 4 3631 14 LPoint3f::zero 0 1 718 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3f const &LPoint3f::zero(void);

2642 6 unit_x 0 4 3631 16 LPoint3f::unit_x 0 1 719 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3f const &LPoint3f::unit_x(void);

2643 6 unit_y 0 4 3631 16 LPoint3f::unit_y 0 1 720 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3f const &LPoint3f::unit_y(void);

2644 6 unit_z 0 4 3631 16 LPoint3f::unit_z 0 1 721 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3f const &LPoint3f::unit_z(void);

2645 6 get_xy 0 4 3631 16 LPoint3f::get_xy 0 1 722 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_xy(void) const;

2646 6 get_xz 0 4 3631 16 LPoint3f::get_xz 0 1 723 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2f LPoint3f::get_xz(void) const;

2647 6 get_yz 0 4 3631 16 LPoint3f::get_yz 0 1 724 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_yz(void) const;

2648 10 operator - 0 68 3631 20 LPoint3f::operator - 0 1 725 0
49
inline LPoint3f LPoint3f::operator -(void) const;

2649 10 operator + 0 4 3631 20 LPoint3f::operator + 0 2 726 727 0
138
inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const;
inline LPoint3f LPoint3f::operator +(LVector3f const &other) const;

2650 10 operator - 0 4 3631 20 LPoint3f::operator - 0 3 728 729 730 0
206
inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const;
inline LVector3f LPoint3f::operator -(LPoint3f const &other) const;
inline LPoint3f LPoint3f::operator -(LVector3f const &other) const;

2651 5 cross 0 4 3631 15 LPoint3f::cross 0 1 731 10
/**
 *
 */
63
inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const;

2652 10 normalized 0 4 3631 20 LPoint3f::normalized 0 1 732 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3f LPoint3f::normalized(void) const;

2653 7 project 0 4 3631 17 LPoint3f::project 0 1 733 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const;

2654 10 operator * 0 4 3631 20 LPoint3f::operator * 0 1 734 0
57
inline LPoint3f LPoint3f::operator *(float scalar) const;

2655 10 operator / 0 4 3631 20 LPoint3f::operator / 0 1 735 0
57
inline LPoint3f LPoint3f::operator /(float scalar) const;

2656 6 origin 0 4 3631 16 LPoint3f::origin 0 1 736 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default);

2657 3 rfu 0 4 3631 13 LPoint3f::rfu 0 1 737 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
107
static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2658 8 __repr__ 0 4 3631 18 LPoint3f::__repr__ 0 1 738 0
50
inline std::string LPoint3f::__repr__(void) const;

2659 14 get_class_type 0 4 3631 24 LPoint3f::get_class_type 0 1 739 0
49
static TypeHandle LPoint3f::get_class_type(void);

2660 9 ~LPoint3f 0 516 3631 19 LPoint3f::~LPoint3f 0 0 0
26
LPoint3f::~LPoint3f(void);

2661 8 LPoint3d 0 260 3632 18 LPoint3d::LPoint3d 0 6 740 741 742 743 744 745 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
312
inline LPoint3d::LPoint3d(void) = default;
inline LPoint3d::LPoint3d(LVecBase3d const &copy);
inline LPoint3d::LPoint3d(double fill_value);
inline LPoint3d::LPoint3d(double x, double y, double z);
inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z);
inline LPoint3d::LPoint3d(LPoint3d const &) = default;

2662 11 __getattr__ 0 4 3632 21 LPoint3d::__getattr__ 0 1 746 0
91
inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2663 11 __setattr__ 0 4 3632 21 LPoint3d::__setattr__ 0 1 747 0
97
inline int LPoint3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2664 4 zero 0 4 3632 14 LPoint3d::zero 0 1 748 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3d const &LPoint3d::zero(void);

2665 6 unit_x 0 4 3632 16 LPoint3d::unit_x 0 1 749 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3d const &LPoint3d::unit_x(void);

2666 6 unit_y 0 4 3632 16 LPoint3d::unit_y 0 1 750 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3d const &LPoint3d::unit_y(void);

2667 6 unit_z 0 4 3632 16 LPoint3d::unit_z 0 1 751 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3d const &LPoint3d::unit_z(void);

2668 6 get_xy 0 4 3632 16 LPoint3d::get_xy 0 1 752 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_xy(void) const;

2669 6 get_xz 0 4 3632 16 LPoint3d::get_xz 0 1 753 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2d LPoint3d::get_xz(void) const;

2670 6 get_yz 0 4 3632 16 LPoint3d::get_yz 0 1 754 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_yz(void) const;

2671 10 operator - 0 68 3632 20 LPoint3d::operator - 0 1 755 0
49
inline LPoint3d LPoint3d::operator -(void) const;

2672 10 operator + 0 4 3632 20 LPoint3d::operator + 0 2 756 757 0
138
inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const;
inline LPoint3d LPoint3d::operator +(LVector3d const &other) const;

2673 10 operator - 0 4 3632 20 LPoint3d::operator - 0 3 758 759 760 0
206
inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const;
inline LVector3d LPoint3d::operator -(LPoint3d const &other) const;
inline LPoint3d LPoint3d::operator -(LVector3d const &other) const;

2674 5 cross 0 4 3632 15 LPoint3d::cross 0 1 761 10
/**
 *
 */
63
inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const;

2675 10 normalized 0 4 3632 20 LPoint3d::normalized 0 1 762 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3d LPoint3d::normalized(void) const;

2676 7 project 0 4 3632 17 LPoint3d::project 0 1 763 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const;

2677 10 operator * 0 4 3632 20 LPoint3d::operator * 0 1 764 0
58
inline LPoint3d LPoint3d::operator *(double scalar) const;

2678 10 operator / 0 4 3632 20 LPoint3d::operator / 0 1 765 0
58
inline LPoint3d LPoint3d::operator /(double scalar) const;

2679 6 origin 0 4 3632 16 LPoint3d::origin 0 1 766 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default);

2680 3 rfu 0 4 3632 13 LPoint3d::rfu 0 1 767 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
110
static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2681 8 __repr__ 0 4 3632 18 LPoint3d::__repr__ 0 1 768 0
50
inline std::string LPoint3d::__repr__(void) const;

2682 14 get_class_type 0 4 3632 24 LPoint3d::get_class_type 0 1 769 0
49
static TypeHandle LPoint3d::get_class_type(void);

2683 9 ~LPoint3d 0 516 3632 19 LPoint3d::~LPoint3d 0 0 0
26
LPoint3d::~LPoint3d(void);

2684 8 LPoint3i 0 260 3633 18 LPoint3i::LPoint3i 0 6 770 771 772 773 774 775 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
297
inline LPoint3i::LPoint3i(void) = default;
inline LPoint3i::LPoint3i(LVecBase3i const &copy);
inline LPoint3i::LPoint3i(int fill_value);
inline LPoint3i::LPoint3i(int x, int y, int z);
inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z);
inline LPoint3i::LPoint3i(LPoint3i const &) = default;

2685 11 __getattr__ 0 4 3633 21 LPoint3i::__getattr__ 0 1 776 0
91
inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2686 11 __setattr__ 0 4 3633 21 LPoint3i::__setattr__ 0 1 777 0
97
inline int LPoint3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2687 4 zero 0 4 3633 14 LPoint3i::zero 0 1 778 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3i const &LPoint3i::zero(void);

2688 6 unit_x 0 4 3633 16 LPoint3i::unit_x 0 1 779 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3i const &LPoint3i::unit_x(void);

2689 6 unit_y 0 4 3633 16 LPoint3i::unit_y 0 1 780 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3i const &LPoint3i::unit_y(void);

2690 6 unit_z 0 4 3633 16 LPoint3i::unit_z 0 1 781 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3i const &LPoint3i::unit_z(void);

2691 6 get_xy 0 4 3633 16 LPoint3i::get_xy 0 1 782 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_xy(void) const;

2692 6 get_xz 0 4 3633 16 LPoint3i::get_xz 0 1 783 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2i LPoint3i::get_xz(void) const;

2693 6 get_yz 0 4 3633 16 LPoint3i::get_yz 0 1 784 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_yz(void) const;

2694 10 operator - 0 68 3633 20 LPoint3i::operator - 0 1 785 0
49
inline LPoint3i LPoint3i::operator -(void) const;

2695 10 operator + 0 4 3633 20 LPoint3i::operator + 0 2 786 787 0
138
inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const;
inline LPoint3i LPoint3i::operator +(LVector3i const &other) const;

2696 10 operator - 0 4 3633 20 LPoint3i::operator - 0 3 788 789 790 0
206
inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const;
inline LVector3i LPoint3i::operator -(LPoint3i const &other) const;
inline LPoint3i LPoint3i::operator -(LVector3i const &other) const;

2697 5 cross 0 4 3633 15 LPoint3i::cross 0 1 791 10
/**
 *
 */
63
inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const;

2698 10 operator * 0 4 3633 20 LPoint3i::operator * 0 1 792 0
55
inline LPoint3i LPoint3i::operator *(int scalar) const;

2699 10 operator / 0 4 3633 20 LPoint3i::operator / 0 1 793 0
55
inline LPoint3i LPoint3i::operator /(int scalar) const;

2700 6 origin 0 4 3633 16 LPoint3i::origin 0 1 794 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default);

2701 3 rfu 0 4 3633 13 LPoint3i::rfu 0 1 795 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
101
static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2702 8 __repr__ 0 4 3633 18 LPoint3i::__repr__ 0 1 796 0
50
inline std::string LPoint3i::__repr__(void) const;

2703 14 get_class_type 0 4 3633 24 LPoint3i::get_class_type 0 1 797 0
49
static TypeHandle LPoint3i::get_class_type(void);

2704 9 ~LPoint3i 0 516 3633 19 LPoint3i::~LPoint3i 0 0 0
26
LPoint3i::~LPoint3i(void);

2705 10 LVecBase4f 0 260 3634 22 LVecBase4f::LVecBase4f 0 8 798 799 800 801 802 803 804 805 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
461
inline LVecBase4f::LVecBase4f(void) = default;
inline LVecBase4f::LVecBase4f(float fill_value);
inline LVecBase4f::LVecBase4f(float x, float y, float z, float w);
inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy);
inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w);
inline LVecBase4f::LVecBase4f(LPoint3f const &point);
inline LVecBase4f::LVecBase4f(LVector3f const &vector);
inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default;

2706 12 operator new 0 4 3634 24 LVecBase4f::operator new 0 1 806 0
124
inline void *LVecBase4f::operator new(std::size_t size);
inline void *LVecBase4f::operator new(std::size_t size, void *ptr);

2707 15 operator delete 0 4 3634 27 LVecBase4f::operator delete 0 0 0
108
inline void LVecBase4f::operator delete(void *ptr);
inline void LVecBase4f::operator delete(void *, void *);

2708 12 validate_ptr 0 4 3634 24 LVecBase4f::validate_ptr 0 0 0
61
static inline bool LVecBase4f::validate_ptr(void const *ptr);

2709 10 operator = 0 4 3634 22 LVecBase4f::operator = 0 2 807 808 0
119
void LVecBase4f::operator =(LVecBase4f const &copy) = default;
void LVecBase4f::operator =(float fill_value) = default;

2710 4 zero 0 4 3634 16 LVecBase4f::zero 0 1 809 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4f const &LVecBase4f::zero(void);

2711 6 unit_x 0 4 3634 18 LVecBase4f::unit_x 0 1 810 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_x(void);

2712 6 unit_y 0 4 3634 18 LVecBase4f::unit_y 0 1 811 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_y(void);

2713 6 unit_z 0 4 3634 18 LVecBase4f::unit_z 0 1 812 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_z(void);

2714 6 unit_w 0 4 3634 18 LVecBase4f::unit_w 0 1 813 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_w(void);

2715 10 __reduce__ 0 4 3634 22 LVecBase4f::__reduce__ 0 1 814 0
62
inline PyObject *LVecBase4f::__reduce__(PyObject *self) const;

2716 11 __getattr__ 0 4 3634 23 LVecBase4f::__getattr__ 0 1 815 0
93
inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2717 11 __setattr__ 0 4 3634 23 LVecBase4f::__setattr__ 0 1 816 0
99
inline int LVecBase4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2718 11 operator [] 0 4 3634 23 LVecBase4f::operator [] 0 2 817 818 10
/**
 *
 */
96
inline float LVecBase4f::operator [](int i) const;
inline float &LVecBase4f::operator [](int i);

2719 4 size 0 4 3634 16 LVecBase4f::size 0 1 819 0
44
static constexpr int LVecBase4f::size(void);

2720 6 is_nan 0 4 3634 18 LVecBase4f::is_nan 0 1 820 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4f::is_nan(void) const;

2721 8 get_cell 0 4 3634 20 LVecBase4f::get_cell 0 1 821 10
/**
 *
 */
47
inline float LVecBase4f::get_cell(int i) const;

2722 8 set_cell 0 4 3634 20 LVecBase4f::set_cell 0 1 822 10
/**
 *
 */
53
inline void LVecBase4f::set_cell(int i, float value);

2723 5 get_x 0 4 3634 17 LVecBase4f::get_x 0 1 823 10
/**
 *
 */
43
inline float LVecBase4f::get_x(void) const;

2724 5 get_y 0 4 3634 17 LVecBase4f::get_y 0 1 824 10
/**
 *
 */
43
inline float LVecBase4f::get_y(void) const;

2725 5 get_z 0 4 3634 17 LVecBase4f::get_z 0 1 825 10
/**
 *
 */
43
inline float LVecBase4f::get_z(void) const;

2726 5 get_w 0 4 3634 17 LVecBase4f::get_w 0 1 826 10
/**
 *
 */
43
inline float LVecBase4f::get_w(void) const;

2727 7 get_xyz 0 4 3634 19 LVecBase4f::get_xyz 0 1 827 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3f LVecBase4f::get_xyz(void) const;

2728 6 get_xy 0 4 3634 18 LVecBase4f::get_xy 0 1 828 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2f LVecBase4f::get_xy(void) const;

2729 5 set_x 0 4 3634 17 LVecBase4f::set_x 0 1 829 10
/**
 *
 */
43
inline void LVecBase4f::set_x(float value);

2730 5 set_y 0 4 3634 17 LVecBase4f::set_y 0 1 830 10
/**
 *
 */
43
inline void LVecBase4f::set_y(float value);

2731 5 set_z 0 4 3634 17 LVecBase4f::set_z 0 1 831 10
/**
 *
 */
43
inline void LVecBase4f::set_z(float value);

2732 5 set_w 0 4 3634 17 LVecBase4f::set_w 0 1 832 10
/**
 *
 */
43
inline void LVecBase4f::set_w(float value);

2733 11 add_to_cell 0 4 3634 23 LVecBase4f::add_to_cell 0 1 833 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase4f::add_to_cell(int i, float value);

2734 5 add_x 0 4 3634 17 LVecBase4f::add_x 0 1 834 10
/**
 *
 */
43
inline void LVecBase4f::add_x(float value);

2735 5 add_y 0 4 3634 17 LVecBase4f::add_y 0 1 835 10
/**
 *
 */
43
inline void LVecBase4f::add_y(float value);

2736 5 add_z 0 4 3634 17 LVecBase4f::add_z 0 1 836 10
/**
 *
 */
43
inline void LVecBase4f::add_z(float value);

2737 5 add_w 0 4 3634 17 LVecBase4f::add_w 0 1 837 10
/**
 *
 */
43
inline void LVecBase4f::add_w(float value);

2738 8 get_data 0 4 3634 20 LVecBase4f::get_data 0 1 838 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase4f::get_data(void) const;

2739 18 get_num_components 0 4 3634 30 LVecBase4f::get_num_components 0 1 839 0
58
static constexpr int LVecBase4f::get_num_components(void);

2740 12 extract_data 0 4 3634 24 LVecBase4f::extract_data 0 0 0
46
inline void LVecBase4f::extract_data(float *);

2741 4 fill 0 4 3634 16 LVecBase4f::fill 0 1 840 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase4f::fill(float fill_value);

2742 3 set 0 4 3634 15 LVecBase4f::set 0 1 841 10
/**
 *
 */
64
inline void LVecBase4f::set(float x, float y, float z, float w);

2743 3 dot 0 4 3634 15 LVecBase4f::dot 0 1 842 10
/**
 *
 */
60
inline float LVecBase4f::dot(LVecBase4f const &other) const;

2744 14 length_squared 0 4 3634 26 LVecBase4f::length_squared 0 1 843 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase4f::length_squared(void) const;

2745 6 length 0 4 3634 18 LVecBase4f::length 0 1 844 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase4f::length(void) const;

2746 9 normalize 0 4 3634 21 LVecBase4f::normalize 0 1 845 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4f::normalize(void);

2747 10 normalized 0 4 3634 22 LVecBase4f::normalized 0 1 846 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4f LVecBase4f::normalized(void) const;

2748 7 project 0 4 3634 19 LVecBase4f::project 0 1 847 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const;

2749 10 operator < 0 4 3634 22 LVecBase4f::operator < 0 1 848 0
66
inline bool LVecBase4f::operator <(LVecBase4f const &other) const;

2750 11 operator == 0 4 3634 23 LVecBase4f::operator == 0 1 849 0
67
inline bool LVecBase4f::operator ==(LVecBase4f const &other) const;

2751 11 operator != 0 4 3634 23 LVecBase4f::operator != 0 1 850 0
67
inline bool LVecBase4f::operator !=(LVecBase4f const &other) const;

2752 10 compare_to 0 4 3634 22 LVecBase4f::compare_to 0 2 851 852 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase4f::compare_to(LVecBase4f const &other) const;
inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const;

2753 8 get_hash 0 4 3634 20 LVecBase4f::get_hash 0 2 853 854 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase4f::get_hash(void) const;
inline std::size_t LVecBase4f::get_hash(float threshold) const;

2754 8 add_hash 0 4 3634 20 LVecBase4f::add_hash 0 2 855 856 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase4f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const;

2755 13 generate_hash 0 4 3634 25 LVecBase4f::generate_hash 0 2 857 858 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2756 10 operator - 0 68 3634 22 LVecBase4f::operator - 0 1 859 0
53
inline LVecBase4f LVecBase4f::operator -(void) const;

2757 10 operator + 0 4 3634 22 LVecBase4f::operator + 0 1 860 0
72
inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &other) const;

2758 10 operator - 0 4 3634 22 LVecBase4f::operator - 0 1 861 0
72
inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &other) const;

2759 10 operator * 0 4 3634 22 LVecBase4f::operator * 0 1 862 0
61
inline LVecBase4f LVecBase4f::operator *(float scalar) const;

2760 10 operator / 0 4 3634 22 LVecBase4f::operator / 0 1 863 0
61
inline LVecBase4f LVecBase4f::operator /(float scalar) const;

2761 11 operator += 0 4 3634 23 LVecBase4f::operator += 0 1 864 0
61
inline void LVecBase4f::operator +=(LVecBase4f const &other);

2762 11 operator -= 0 4 3634 23 LVecBase4f::operator -= 0 1 865 0
61
inline void LVecBase4f::operator -=(LVecBase4f const &other);

2763 11 operator *= 0 4 3634 23 LVecBase4f::operator *= 0 1 866 0
50
inline void LVecBase4f::operator *=(float scalar);

2764 11 operator /= 0 4 3634 23 LVecBase4f::operator /= 0 1 867 0
50
inline void LVecBase4f::operator /=(float scalar);

2765 18 componentwise_mult 0 4 3634 30 LVecBase4f::componentwise_mult 0 1 868 10
/**
 *
 */
68
inline void LVecBase4f::componentwise_mult(LVecBase4f const &other);

2766 12 __floordiv__ 0 4 3634 24 LVecBase4f::__floordiv__ 0 1 869 0
78
inline PyObject *LVecBase4f::__floordiv__(PyObject *self, float scalar) const;

2767 13 __ifloordiv__ 0 4 3634 25 LVecBase4f::__ifloordiv__ 0 1 870 0
73
inline PyObject *LVecBase4f::__ifloordiv__(PyObject *self, float scalar);

2768 7 __pow__ 0 4 3634 19 LVecBase4f::__pow__ 0 1 871 0
75
inline PyObject *LVecBase4f::__pow__(PyObject *self, float exponent) const;

2769 8 __ipow__ 0 4 3634 20 LVecBase4f::__ipow__ 0 1 872 0
70
inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent);

2770 9 __round__ 0 4 3634 21 LVecBase4f::__round__ 0 1 873 0
55
inline PyObject *LVecBase4f::__round__(PyObject *self);

2771 9 __floor__ 0 4 3634 21 LVecBase4f::__floor__ 0 1 874 0
55
inline PyObject *LVecBase4f::__floor__(PyObject *self);

2772 8 __ceil__ 0 4 3634 20 LVecBase4f::__ceil__ 0 1 875 0
54
inline PyObject *LVecBase4f::__ceil__(PyObject *self);

2773 4 fmax 0 4 3634 16 LVecBase4f::fmax 0 1 876 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const;

2774 4 fmin 0 4 3634 16 LVecBase4f::fmin 0 1 877 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const;

2775 12 almost_equal 0 4 3634 24 LVecBase4f::almost_equal 0 2 878 879 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const;
inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const;

2776 6 output 0 4 3634 18 LVecBase4f::output 0 1 880 10
/**
 *
 */
56
inline void LVecBase4f::output(std::ostream &out) const;

2777 8 __repr__ 0 4 3634 20 LVecBase4f::__repr__ 0 1 881 0
52
inline std::string LVecBase4f::__repr__(void) const;

2778 20 write_datagram_fixed 0 4 3634 32 LVecBase4f::write_datagram_fixed 0 1 882 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const;

2779 19 read_datagram_fixed 0 4 3634 31 LVecBase4f::read_datagram_fixed 0 1 883 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source);

2780 14 write_datagram 0 4 3634 26 LVecBase4f::write_datagram 0 1 884 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4f::write_datagram(Datagram &destination) const;

2781 13 read_datagram 0 4 3634 25 LVecBase4f::read_datagram 0 1 885 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4f::read_datagram(DatagramIterator &source);

2782 14 get_class_type 0 4 3634 26 LVecBase4f::get_class_type 0 1 886 0
51
static TypeHandle LVecBase4f::get_class_type(void);

2783 11 ~LVecBase4f 0 516 3634 23 LVecBase4f::~LVecBase4f 0 0 0
30
LVecBase4f::~LVecBase4f(void);

2784 19 UnalignedLVecBase4f 0 260 3636 40 UnalignedLVecBase4f::UnalignedLVecBase4f 0 5 887 888 889 890 891 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
377
inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default;
inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float fill_value);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default;

2785 4 fill 0 4 3636 25 UnalignedLVecBase4f::fill 0 1 892 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
56
inline void UnalignedLVecBase4f::fill(float fill_value);

2786 3 set 0 4 3636 24 UnalignedLVecBase4f::set 0 1 893 10
/**
 *
 */
73
inline void UnalignedLVecBase4f::set(float x, float y, float z, float w);

2787 11 operator [] 0 4 3636 32 UnalignedLVecBase4f::operator [] 0 2 894 895 10
/**
 *
 */
114
inline float UnalignedLVecBase4f::operator [](int i) const;
inline float &UnalignedLVecBase4f::operator [](int i);

2788 4 size 0 4 3636 25 UnalignedLVecBase4f::size 0 1 896 0
53
static constexpr int UnalignedLVecBase4f::size(void);

2789 8 get_data 0 4 3636 29 UnalignedLVecBase4f::get_data 0 1 897 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
62
inline float const *UnalignedLVecBase4f::get_data(void) const;

2790 18 get_num_components 0 4 3636 39 UnalignedLVecBase4f::get_num_components 0 1 898 0
67
static constexpr int UnalignedLVecBase4f::get_num_components(void);

2791 11 operator == 0 4 3636 32 UnalignedLVecBase4f::operator == 0 1 899 0
85
inline bool UnalignedLVecBase4f::operator ==(UnalignedLVecBase4f const &other) const;

2792 11 operator != 0 4 3636 32 UnalignedLVecBase4f::operator != 0 1 900 0
85
inline bool UnalignedLVecBase4f::operator !=(UnalignedLVecBase4f const &other) const;

2793 14 get_class_type 0 4 3636 35 UnalignedLVecBase4f::get_class_type 0 1 901 0
60
static TypeHandle UnalignedLVecBase4f::get_class_type(void);

2794 20 ~UnalignedLVecBase4f 0 516 3636 41 UnalignedLVecBase4f::~UnalignedLVecBase4f 0 0 0
48
UnalignedLVecBase4f::~UnalignedLVecBase4f(void);

2795 10 LVecBase4d 0 260 3638 22 LVecBase4d::LVecBase4d 0 8 902 903 904 905 906 907 908 909 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
467
inline LVecBase4d::LVecBase4d(void) = default;
inline LVecBase4d::LVecBase4d(double fill_value);
inline LVecBase4d::LVecBase4d(double x, double y, double z, double w);
inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy);
inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w);
inline LVecBase4d::LVecBase4d(LPoint3d const &point);
inline LVecBase4d::LVecBase4d(LVector3d const &vector);
inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default;

2796 12 operator new 0 4 3638 24 LVecBase4d::operator new 0 1 910 0
124
inline void *LVecBase4d::operator new(std::size_t size);
inline void *LVecBase4d::operator new(std::size_t size, void *ptr);

2797 15 operator delete 0 4 3638 27 LVecBase4d::operator delete 0 0 0
108
inline void LVecBase4d::operator delete(void *ptr);
inline void LVecBase4d::operator delete(void *, void *);

2798 12 validate_ptr 0 4 3638 24 LVecBase4d::validate_ptr 0 0 0
61
static inline bool LVecBase4d::validate_ptr(void const *ptr);

2799 10 operator = 0 4 3638 22 LVecBase4d::operator = 0 2 911 912 0
120
void LVecBase4d::operator =(LVecBase4d const &copy) = default;
void LVecBase4d::operator =(double fill_value) = default;

2800 4 zero 0 4 3638 16 LVecBase4d::zero 0 1 913 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4d const &LVecBase4d::zero(void);

2801 6 unit_x 0 4 3638 18 LVecBase4d::unit_x 0 1 914 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_x(void);

2802 6 unit_y 0 4 3638 18 LVecBase4d::unit_y 0 1 915 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_y(void);

2803 6 unit_z 0 4 3638 18 LVecBase4d::unit_z 0 1 916 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_z(void);

2804 6 unit_w 0 4 3638 18 LVecBase4d::unit_w 0 1 917 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_w(void);

2805 10 __reduce__ 0 4 3638 22 LVecBase4d::__reduce__ 0 1 918 0
62
inline PyObject *LVecBase4d::__reduce__(PyObject *self) const;

2806 11 __getattr__ 0 4 3638 23 LVecBase4d::__getattr__ 0 1 919 0
93
inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2807 11 __setattr__ 0 4 3638 23 LVecBase4d::__setattr__ 0 1 920 0
99
inline int LVecBase4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2808 11 operator [] 0 4 3638 23 LVecBase4d::operator [] 0 2 921 922 10
/**
 *
 */
98
inline double LVecBase4d::operator [](int i) const;
inline double &LVecBase4d::operator [](int i);

2809 4 size 0 4 3638 16 LVecBase4d::size 0 1 923 0
44
static constexpr int LVecBase4d::size(void);

2810 6 is_nan 0 4 3638 18 LVecBase4d::is_nan 0 1 924 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4d::is_nan(void) const;

2811 8 get_cell 0 4 3638 20 LVecBase4d::get_cell 0 1 925 10
/**
 *
 */
48
inline double LVecBase4d::get_cell(int i) const;

2812 8 set_cell 0 4 3638 20 LVecBase4d::set_cell 0 1 926 10
/**
 *
 */
54
inline void LVecBase4d::set_cell(int i, double value);

2813 5 get_x 0 4 3638 17 LVecBase4d::get_x 0 1 927 10
/**
 *
 */
44
inline double LVecBase4d::get_x(void) const;

2814 5 get_y 0 4 3638 17 LVecBase4d::get_y 0 1 928 10
/**
 *
 */
44
inline double LVecBase4d::get_y(void) const;

2815 5 get_z 0 4 3638 17 LVecBase4d::get_z 0 1 929 10
/**
 *
 */
44
inline double LVecBase4d::get_z(void) const;

2816 5 get_w 0 4 3638 17 LVecBase4d::get_w 0 1 930 10
/**
 *
 */
44
inline double LVecBase4d::get_w(void) const;

2817 7 get_xyz 0 4 3638 19 LVecBase4d::get_xyz 0 1 931 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3d LVecBase4d::get_xyz(void) const;

2818 6 get_xy 0 4 3638 18 LVecBase4d::get_xy 0 1 932 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2d LVecBase4d::get_xy(void) const;

2819 5 set_x 0 4 3638 17 LVecBase4d::set_x 0 1 933 10
/**
 *
 */
44
inline void LVecBase4d::set_x(double value);

2820 5 set_y 0 4 3638 17 LVecBase4d::set_y 0 1 934 10
/**
 *
 */
44
inline void LVecBase4d::set_y(double value);

2821 5 set_z 0 4 3638 17 LVecBase4d::set_z 0 1 935 10
/**
 *
 */
44
inline void LVecBase4d::set_z(double value);

2822 5 set_w 0 4 3638 17 LVecBase4d::set_w 0 1 936 10
/**
 *
 */
44
inline void LVecBase4d::set_w(double value);

2823 11 add_to_cell 0 4 3638 23 LVecBase4d::add_to_cell 0 1 937 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase4d::add_to_cell(int i, double value);

2824 5 add_x 0 4 3638 17 LVecBase4d::add_x 0 1 938 10
/**
 *
 */
44
inline void LVecBase4d::add_x(double value);

2825 5 add_y 0 4 3638 17 LVecBase4d::add_y 0 1 939 10
/**
 *
 */
44
inline void LVecBase4d::add_y(double value);

2826 5 add_z 0 4 3638 17 LVecBase4d::add_z 0 1 940 10
/**
 *
 */
44
inline void LVecBase4d::add_z(double value);

2827 5 add_w 0 4 3638 17 LVecBase4d::add_w 0 1 941 10
/**
 *
 */
44
inline void LVecBase4d::add_w(double value);

2828 8 get_data 0 4 3638 20 LVecBase4d::get_data 0 1 942 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase4d::get_data(void) const;

2829 18 get_num_components 0 4 3638 30 LVecBase4d::get_num_components 0 1 943 0
58
static constexpr int LVecBase4d::get_num_components(void);

2830 12 extract_data 0 4 3638 24 LVecBase4d::extract_data 0 0 0
46
inline void LVecBase4d::extract_data(float *);

2831 4 fill 0 4 3638 16 LVecBase4d::fill 0 1 944 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase4d::fill(double fill_value);

2832 3 set 0 4 3638 15 LVecBase4d::set 0 1 945 10
/**
 *
 */
68
inline void LVecBase4d::set(double x, double y, double z, double w);

2833 3 dot 0 4 3638 15 LVecBase4d::dot 0 1 946 10
/**
 *
 */
61
inline double LVecBase4d::dot(LVecBase4d const &other) const;

2834 14 length_squared 0 4 3638 26 LVecBase4d::length_squared 0 1 947 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase4d::length_squared(void) const;

2835 6 length 0 4 3638 18 LVecBase4d::length 0 1 948 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase4d::length(void) const;

2836 9 normalize 0 4 3638 21 LVecBase4d::normalize 0 1 949 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4d::normalize(void);

2837 10 normalized 0 4 3638 22 LVecBase4d::normalized 0 1 950 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4d LVecBase4d::normalized(void) const;

2838 7 project 0 4 3638 19 LVecBase4d::project 0 1 951 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const;

2839 10 operator < 0 4 3638 22 LVecBase4d::operator < 0 1 952 0
66
inline bool LVecBase4d::operator <(LVecBase4d const &other) const;

2840 11 operator == 0 4 3638 23 LVecBase4d::operator == 0 1 953 0
67
inline bool LVecBase4d::operator ==(LVecBase4d const &other) const;

2841 11 operator != 0 4 3638 23 LVecBase4d::operator != 0 1 954 0
67
inline bool LVecBase4d::operator !=(LVecBase4d const &other) const;

2842 10 compare_to 0 4 3638 22 LVecBase4d::compare_to 0 2 955 956 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase4d::compare_to(LVecBase4d const &other) const;
inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const;

2843 8 get_hash 0 4 3638 20 LVecBase4d::get_hash 0 2 957 958 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase4d::get_hash(void) const;
inline std::size_t LVecBase4d::get_hash(double threshold) const;

2844 8 add_hash 0 4 3638 20 LVecBase4d::add_hash 0 2 959 960 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase4d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const;

2845 13 generate_hash 0 4 3638 25 LVecBase4d::generate_hash 0 2 961 962 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2846 10 operator - 0 68 3638 22 LVecBase4d::operator - 0 1 963 0
53
inline LVecBase4d LVecBase4d::operator -(void) const;

2847 10 operator + 0 4 3638 22 LVecBase4d::operator + 0 1 964 0
72
inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &other) const;

2848 10 operator - 0 4 3638 22 LVecBase4d::operator - 0 1 965 0
72
inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &other) const;

2849 10 operator * 0 4 3638 22 LVecBase4d::operator * 0 1 966 0
62
inline LVecBase4d LVecBase4d::operator *(double scalar) const;

2850 10 operator / 0 4 3638 22 LVecBase4d::operator / 0 1 967 0
62
inline LVecBase4d LVecBase4d::operator /(double scalar) const;

2851 11 operator += 0 4 3638 23 LVecBase4d::operator += 0 1 968 0
61
inline void LVecBase4d::operator +=(LVecBase4d const &other);

2852 11 operator -= 0 4 3638 23 LVecBase4d::operator -= 0 1 969 0
61
inline void LVecBase4d::operator -=(LVecBase4d const &other);

2853 11 operator *= 0 4 3638 23 LVecBase4d::operator *= 0 1 970 0
51
inline void LVecBase4d::operator *=(double scalar);

2854 11 operator /= 0 4 3638 23 LVecBase4d::operator /= 0 1 971 0
51
inline void LVecBase4d::operator /=(double scalar);

2855 18 componentwise_mult 0 4 3638 30 LVecBase4d::componentwise_mult 0 1 972 10
/**
 *
 */
68
inline void LVecBase4d::componentwise_mult(LVecBase4d const &other);

2856 12 __floordiv__ 0 4 3638 24 LVecBase4d::__floordiv__ 0 1 973 0
79
inline PyObject *LVecBase4d::__floordiv__(PyObject *self, double scalar) const;

2857 13 __ifloordiv__ 0 4 3638 25 LVecBase4d::__ifloordiv__ 0 1 974 0
74
inline PyObject *LVecBase4d::__ifloordiv__(PyObject *self, double scalar);

2858 7 __pow__ 0 4 3638 19 LVecBase4d::__pow__ 0 1 975 0
76
inline PyObject *LVecBase4d::__pow__(PyObject *self, double exponent) const;

2859 8 __ipow__ 0 4 3638 20 LVecBase4d::__ipow__ 0 1 976 0
71
inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent);

2860 9 __round__ 0 4 3638 21 LVecBase4d::__round__ 0 1 977 0
55
inline PyObject *LVecBase4d::__round__(PyObject *self);

2861 9 __floor__ 0 4 3638 21 LVecBase4d::__floor__ 0 1 978 0
55
inline PyObject *LVecBase4d::__floor__(PyObject *self);

2862 8 __ceil__ 0 4 3638 20 LVecBase4d::__ceil__ 0 1 979 0
54
inline PyObject *LVecBase4d::__ceil__(PyObject *self);

2863 4 fmax 0 4 3638 16 LVecBase4d::fmax 0 1 980 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const;

2864 4 fmin 0 4 3638 16 LVecBase4d::fmin 0 1 981 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const;

2865 12 almost_equal 0 4 3638 24 LVecBase4d::almost_equal 0 2 982 983 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const;
inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const;

2866 6 output 0 4 3638 18 LVecBase4d::output 0 1 984 10
/**
 *
 */
56
inline void LVecBase4d::output(std::ostream &out) const;

2867 8 __repr__ 0 4 3638 20 LVecBase4d::__repr__ 0 1 985 0
52
inline std::string LVecBase4d::__repr__(void) const;

2868 20 write_datagram_fixed 0 4 3638 32 LVecBase4d::write_datagram_fixed 0 1 986 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const;

2869 19 read_datagram_fixed 0 4 3638 31 LVecBase4d::read_datagram_fixed 0 1 987 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source);

2870 14 write_datagram 0 4 3638 26 LVecBase4d::write_datagram 0 1 988 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4d::write_datagram(Datagram &destination) const;

2871 13 read_datagram 0 4 3638 25 LVecBase4d::read_datagram 0 1 989 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4d::read_datagram(DatagramIterator &source);

2872 14 get_class_type 0 4 3638 26 LVecBase4d::get_class_type 0 1 990 0
51
static TypeHandle LVecBase4d::get_class_type(void);

2873 11 ~LVecBase4d 0 516 3638 23 LVecBase4d::~LVecBase4d 0 0 0
30
LVecBase4d::~LVecBase4d(void);

2874 19 UnalignedLVecBase4d 0 260 3640 40 UnalignedLVecBase4d::UnalignedLVecBase4d 0 5 991 992 993 994 995 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
382
inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default;
inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double fill_value);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default;

2875 4 fill 0 4 3640 25 UnalignedLVecBase4d::fill 0 1 996 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
57
inline void UnalignedLVecBase4d::fill(double fill_value);

2876 3 set 0 4 3640 24 UnalignedLVecBase4d::set 0 1 997 10
/**
 *
 */
77
inline void UnalignedLVecBase4d::set(double x, double y, double z, double w);

2877 11 operator [] 0 4 3640 32 UnalignedLVecBase4d::operator [] 0 2 998 999 10
/**
 *
 */
116
inline double UnalignedLVecBase4d::operator [](int i) const;
inline double &UnalignedLVecBase4d::operator [](int i);

2878 4 size 0 4 3640 25 UnalignedLVecBase4d::size 0 1 1000 0
53
static constexpr int UnalignedLVecBase4d::size(void);

2879 8 get_data 0 4 3640 29 UnalignedLVecBase4d::get_data 0 1 1001 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
63
inline double const *UnalignedLVecBase4d::get_data(void) const;

2880 18 get_num_components 0 4 3640 39 UnalignedLVecBase4d::get_num_components 0 1 1002 0
67
static constexpr int UnalignedLVecBase4d::get_num_components(void);

2881 11 operator == 0 4 3640 32 UnalignedLVecBase4d::operator == 0 1 1003 0
85
inline bool UnalignedLVecBase4d::operator ==(UnalignedLVecBase4d const &other) const;

2882 11 operator != 0 4 3640 32 UnalignedLVecBase4d::operator != 0 1 1004 0
85
inline bool UnalignedLVecBase4d::operator !=(UnalignedLVecBase4d const &other) const;

2883 14 get_class_type 0 4 3640 35 UnalignedLVecBase4d::get_class_type 0 1 1005 0
60
static TypeHandle UnalignedLVecBase4d::get_class_type(void);

2884 20 ~UnalignedLVecBase4d 0 516 3640 41 UnalignedLVecBase4d::~UnalignedLVecBase4d 0 0 0
48
UnalignedLVecBase4d::~UnalignedLVecBase4d(void);

2885 10 LVecBase4i 0 260 3642 22 LVecBase4i::LVecBase4i 0 8 1006 1007 1008 1009 1010 1011 1012 1013 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
449
inline LVecBase4i::LVecBase4i(void) = default;
inline LVecBase4i::LVecBase4i(int fill_value);
inline LVecBase4i::LVecBase4i(int x, int y, int z, int w);
inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy);
inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w);
inline LVecBase4i::LVecBase4i(LPoint3i const &point);
inline LVecBase4i::LVecBase4i(LVector3i const &vector);
inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default;

2886 12 operator new 0 4 3642 24 LVecBase4i::operator new 0 1 1014 0
124
inline void *LVecBase4i::operator new(std::size_t size);
inline void *LVecBase4i::operator new(std::size_t size, void *ptr);

2887 15 operator delete 0 4 3642 27 LVecBase4i::operator delete 0 0 0
108
inline void LVecBase4i::operator delete(void *ptr);
inline void LVecBase4i::operator delete(void *, void *);

2888 12 validate_ptr 0 4 3642 24 LVecBase4i::validate_ptr 0 0 0
61
static inline bool LVecBase4i::validate_ptr(void const *ptr);

2889 10 operator = 0 4 3642 22 LVecBase4i::operator = 0 2 1015 1016 0
117
void LVecBase4i::operator =(LVecBase4i const &copy) = default;
void LVecBase4i::operator =(int fill_value) = default;

2890 4 zero 0 4 3642 16 LVecBase4i::zero 0 1 1017 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4i const &LVecBase4i::zero(void);

2891 6 unit_x 0 4 3642 18 LVecBase4i::unit_x 0 1 1018 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_x(void);

2892 6 unit_y 0 4 3642 18 LVecBase4i::unit_y 0 1 1019 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_y(void);

2893 6 unit_z 0 4 3642 18 LVecBase4i::unit_z 0 1 1020 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_z(void);

2894 6 unit_w 0 4 3642 18 LVecBase4i::unit_w 0 1 1021 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_w(void);

2895 10 __reduce__ 0 4 3642 22 LVecBase4i::__reduce__ 0 1 1022 0
62
inline PyObject *LVecBase4i::__reduce__(PyObject *self) const;

2896 11 __getattr__ 0 4 3642 23 LVecBase4i::__getattr__ 0 1 1023 0
93
inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2897 11 __setattr__ 0 4 3642 23 LVecBase4i::__setattr__ 0 1 1024 0
99
inline int LVecBase4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2898 11 operator [] 0 4 3642 23 LVecBase4i::operator [] 0 2 1025 1026 10
/**
 *
 */
92
inline int LVecBase4i::operator [](int i) const;
inline int &LVecBase4i::operator [](int i);

2899 4 size 0 4 3642 16 LVecBase4i::size 0 1 1027 0
44
static constexpr int LVecBase4i::size(void);

2900 6 is_nan 0 4 3642 18 LVecBase4i::is_nan 0 1 1028 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4i::is_nan(void) const;

2901 8 get_cell 0 4 3642 20 LVecBase4i::get_cell 0 1 1029 10
/**
 *
 */
45
inline int LVecBase4i::get_cell(int i) const;

2902 8 set_cell 0 4 3642 20 LVecBase4i::set_cell 0 1 1030 10
/**
 *
 */
51
inline void LVecBase4i::set_cell(int i, int value);

2903 5 get_x 0 4 3642 17 LVecBase4i::get_x 0 1 1031 10
/**
 *
 */
41
inline int LVecBase4i::get_x(void) const;

2904 5 get_y 0 4 3642 17 LVecBase4i::get_y 0 1 1032 10
/**
 *
 */
41
inline int LVecBase4i::get_y(void) const;

2905 5 get_z 0 4 3642 17 LVecBase4i::get_z 0 1 1033 10
/**
 *
 */
41
inline int LVecBase4i::get_z(void) const;

2906 5 get_w 0 4 3642 17 LVecBase4i::get_w 0 1 1034 10
/**
 *
 */
41
inline int LVecBase4i::get_w(void) const;

2907 7 get_xyz 0 4 3642 19 LVecBase4i::get_xyz 0 1 1035 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3i LVecBase4i::get_xyz(void) const;

2908 6 get_xy 0 4 3642 18 LVecBase4i::get_xy 0 1 1036 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2i LVecBase4i::get_xy(void) const;

2909 5 set_x 0 4 3642 17 LVecBase4i::set_x 0 1 1037 10
/**
 *
 */
41
inline void LVecBase4i::set_x(int value);

2910 5 set_y 0 4 3642 17 LVecBase4i::set_y 0 1 1038 10
/**
 *
 */
41
inline void LVecBase4i::set_y(int value);

2911 5 set_z 0 4 3642 17 LVecBase4i::set_z 0 1 1039 10
/**
 *
 */
41
inline void LVecBase4i::set_z(int value);

2912 5 set_w 0 4 3642 17 LVecBase4i::set_w 0 1 1040 10
/**
 *
 */
41
inline void LVecBase4i::set_w(int value);

2913 11 add_to_cell 0 4 3642 23 LVecBase4i::add_to_cell 0 1 1041 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase4i::add_to_cell(int i, int value);

2914 5 add_x 0 4 3642 17 LVecBase4i::add_x 0 1 1042 10
/**
 *
 */
41
inline void LVecBase4i::add_x(int value);

2915 5 add_y 0 4 3642 17 LVecBase4i::add_y 0 1 1043 10
/**
 *
 */
41
inline void LVecBase4i::add_y(int value);

2916 5 add_z 0 4 3642 17 LVecBase4i::add_z 0 1 1044 10
/**
 *
 */
41
inline void LVecBase4i::add_z(int value);

2917 5 add_w 0 4 3642 17 LVecBase4i::add_w 0 1 1045 10
/**
 *
 */
41
inline void LVecBase4i::add_w(int value);

2918 8 get_data 0 4 3642 20 LVecBase4i::get_data 0 1 1046 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase4i::get_data(void) const;

2919 18 get_num_components 0 4 3642 30 LVecBase4i::get_num_components 0 1 1047 0
58
static constexpr int LVecBase4i::get_num_components(void);

2920 12 extract_data 0 4 3642 24 LVecBase4i::extract_data 0 0 0
46
inline void LVecBase4i::extract_data(float *);

2921 4 fill 0 4 3642 16 LVecBase4i::fill 0 1 1048 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase4i::fill(int fill_value);

2922 3 set 0 4 3642 15 LVecBase4i::set 0 1 1049 10
/**
 *
 */
56
inline void LVecBase4i::set(int x, int y, int z, int w);

2923 3 dot 0 4 3642 15 LVecBase4i::dot 0 1 1050 10
/**
 *
 */
58
inline int LVecBase4i::dot(LVecBase4i const &other) const;

2924 14 length_squared 0 4 3642 26 LVecBase4i::length_squared 0 1 1051 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase4i::length_squared(void) const;

2925 10 operator < 0 4 3642 22 LVecBase4i::operator < 0 1 1052 0
66
inline bool LVecBase4i::operator <(LVecBase4i const &other) const;

2926 11 operator == 0 4 3642 23 LVecBase4i::operator == 0 1 1053 0
67
inline bool LVecBase4i::operator ==(LVecBase4i const &other) const;

2927 11 operator != 0 4 3642 23 LVecBase4i::operator != 0 1 1054 0
67
inline bool LVecBase4i::operator !=(LVecBase4i const &other) const;

2928 10 compare_to 0 4 3642 22 LVecBase4i::compare_to 0 1 1055 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase4i::compare_to(LVecBase4i const &other) const;

2929 8 get_hash 0 4 3642 20 LVecBase4i::get_hash 0 1 1056 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase4i::get_hash(void) const;

2930 8 add_hash 0 4 3642 20 LVecBase4i::add_hash 0 1 1057 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase4i::add_hash(std::size_t hash) const;

2931 13 generate_hash 0 4 3642 25 LVecBase4i::generate_hash 0 1 1058 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase4i::generate_hash(ChecksumHashGenerator &hashgen) const;

2932 10 operator - 0 68 3642 22 LVecBase4i::operator - 0 1 1059 0
53
inline LVecBase4i LVecBase4i::operator -(void) const;

2933 10 operator + 0 4 3642 22 LVecBase4i::operator + 0 1 1060 0
72
inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &other) const;

2934 10 operator - 0 4 3642 22 LVecBase4i::operator - 0 1 1061 0
72
inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &other) const;

2935 10 operator * 0 4 3642 22 LVecBase4i::operator * 0 1 1062 0
59
inline LVecBase4i LVecBase4i::operator *(int scalar) const;

2936 10 operator / 0 4 3642 22 LVecBase4i::operator / 0 1 1063 0
59
inline LVecBase4i LVecBase4i::operator /(int scalar) const;

2937 11 operator += 0 4 3642 23 LVecBase4i::operator += 0 1 1064 0
61
inline void LVecBase4i::operator +=(LVecBase4i const &other);

2938 11 operator -= 0 4 3642 23 LVecBase4i::operator -= 0 1 1065 0
61
inline void LVecBase4i::operator -=(LVecBase4i const &other);

2939 11 operator *= 0 4 3642 23 LVecBase4i::operator *= 0 1 1066 0
48
inline void LVecBase4i::operator *=(int scalar);

2940 11 operator /= 0 4 3642 23 LVecBase4i::operator /= 0 1 1067 0
48
inline void LVecBase4i::operator /=(int scalar);

2941 18 componentwise_mult 0 4 3642 30 LVecBase4i::componentwise_mult 0 1 1068 10
/**
 *
 */
68
inline void LVecBase4i::componentwise_mult(LVecBase4i const &other);

2942 12 __floordiv__ 0 4 3642 24 LVecBase4i::__floordiv__ 0 1 1069 0
76
inline PyObject *LVecBase4i::__floordiv__(PyObject *self, int scalar) const;

2943 13 __ifloordiv__ 0 4 3642 25 LVecBase4i::__ifloordiv__ 0 1 1070 0
71
inline PyObject *LVecBase4i::__ifloordiv__(PyObject *self, int scalar);

2944 7 __pow__ 0 4 3642 19 LVecBase4i::__pow__ 0 1 1071 0
73
inline PyObject *LVecBase4i::__pow__(PyObject *self, int exponent) const;

2945 8 __ipow__ 0 4 3642 20 LVecBase4i::__ipow__ 0 1 1072 0
68
inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent);

2946 9 __round__ 0 4 3642 21 LVecBase4i::__round__ 0 1 1073 0
55
inline PyObject *LVecBase4i::__round__(PyObject *self);

2947 9 __floor__ 0 4 3642 21 LVecBase4i::__floor__ 0 1 1074 0
55
inline PyObject *LVecBase4i::__floor__(PyObject *self);

2948 8 __ceil__ 0 4 3642 20 LVecBase4i::__ceil__ 0 1 1075 0
54
inline PyObject *LVecBase4i::__ceil__(PyObject *self);

2949 4 fmax 0 4 3642 16 LVecBase4i::fmax 0 1 1076 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const;

2950 4 fmin 0 4 3642 16 LVecBase4i::fmin 0 1 1077 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const;

2951 12 almost_equal 0 4 3642 24 LVecBase4i::almost_equal 0 2 1078 1079 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const;
inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const;

2952 6 output 0 4 3642 18 LVecBase4i::output 0 1 1080 10
/**
 *
 */
56
inline void LVecBase4i::output(std::ostream &out) const;

2953 8 __repr__ 0 4 3642 20 LVecBase4i::__repr__ 0 1 1081 0
52
inline std::string LVecBase4i::__repr__(void) const;

2954 20 write_datagram_fixed 0 4 3642 32 LVecBase4i::write_datagram_fixed 0 1 1082 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const;

2955 19 read_datagram_fixed 0 4 3642 31 LVecBase4i::read_datagram_fixed 0 1 1083 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source);

2956 14 write_datagram 0 4 3642 26 LVecBase4i::write_datagram 0 1 1084 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4i::write_datagram(Datagram &destination) const;

2957 13 read_datagram 0 4 3642 25 LVecBase4i::read_datagram 0 1 1085 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4i::read_datagram(DatagramIterator &source);

2958 14 get_class_type 0 4 3642 26 LVecBase4i::get_class_type 0 1 1086 0
51
static TypeHandle LVecBase4i::get_class_type(void);

2959 11 ~LVecBase4i 0 516 3642 23 LVecBase4i::~LVecBase4i 0 0 0
30
LVecBase4i::~LVecBase4i(void);

2960 19 UnalignedLVecBase4i 0 260 3644 40 UnalignedLVecBase4i::UnalignedLVecBase4i 0 5 1087 1088 1089 1090 1091 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
367
inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default;
inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int fill_value);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default;

2961 4 fill 0 4 3644 25 UnalignedLVecBase4i::fill 0 1 1092 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
54
inline void UnalignedLVecBase4i::fill(int fill_value);

2962 3 set 0 4 3644 24 UnalignedLVecBase4i::set 0 1 1093 10
/**
 *
 */
65
inline void UnalignedLVecBase4i::set(int x, int y, int z, int w);

2963 11 operator [] 0 4 3644 32 UnalignedLVecBase4i::operator [] 0 2 1094 1095 10
/**
 *
 */
110
inline int UnalignedLVecBase4i::operator [](int i) const;
inline int &UnalignedLVecBase4i::operator [](int i);

2964 4 size 0 4 3644 25 UnalignedLVecBase4i::size 0 1 1096 0
53
static constexpr int UnalignedLVecBase4i::size(void);

2965 8 get_data 0 4 3644 29 UnalignedLVecBase4i::get_data 0 1 1097 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
60
inline int const *UnalignedLVecBase4i::get_data(void) const;

2966 18 get_num_components 0 4 3644 39 UnalignedLVecBase4i::get_num_components 0 1 1098 0
67
static constexpr int UnalignedLVecBase4i::get_num_components(void);

2967 11 operator == 0 4 3644 32 UnalignedLVecBase4i::operator == 0 1 1099 0
85
inline bool UnalignedLVecBase4i::operator ==(UnalignedLVecBase4i const &other) const;

2968 11 operator != 0 4 3644 32 UnalignedLVecBase4i::operator != 0 1 1100 0
85
inline bool UnalignedLVecBase4i::operator !=(UnalignedLVecBase4i const &other) const;

2969 14 get_class_type 0 4 3644 35 UnalignedLVecBase4i::get_class_type 0 1 1101 0
60
static TypeHandle UnalignedLVecBase4i::get_class_type(void);

2970 20 ~UnalignedLVecBase4i 0 516 3644 41 UnalignedLVecBase4i::~UnalignedLVecBase4i 0 0 0
48
UnalignedLVecBase4i::~UnalignedLVecBase4i(void);

2971 9 LVector4f 0 260 3646 20 LVector4f::LVector4f 0 6 1102 1103 1104 1105 1106 1107 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
329
inline LVector4f::LVector4f(void) = default;
inline LVector4f::LVector4f(LVecBase4f const &copy);
inline LVector4f::LVector4f(float fill_value);
inline LVector4f::LVector4f(float x, float y, float z, float w);
inline LVector4f::LVector4f(LVecBase3f const &copy, float w);
inline LVector4f::LVector4f(LVector4f const &) = default;

2972 11 __getattr__ 0 4 3646 22 LVector4f::__getattr__ 0 1 1108 0
92
inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2973 11 __setattr__ 0 4 3646 22 LVector4f::__setattr__ 0 1 1109 0
98
inline int LVector4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2974 4 zero 0 4 3646 15 LVector4f::zero 0 1 1110 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4f const &LVector4f::zero(void);

2975 6 unit_x 0 4 3646 17 LVector4f::unit_x 0 1 1111 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4f const &LVector4f::unit_x(void);

2976 6 unit_y 0 4 3646 17 LVector4f::unit_y 0 1 1112 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4f const &LVector4f::unit_y(void);

2977 6 unit_z 0 4 3646 17 LVector4f::unit_z 0 1 1113 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4f const &LVector4f::unit_z(void);

2978 6 unit_w 0 4 3646 17 LVector4f::unit_w 0 1 1114 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4f const &LVector4f::unit_w(void);

2979 7 get_xyz 0 4 3646 18 LVector4f::get_xyz 0 1 1115 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3f LVector4f::get_xyz(void) const;

2980 6 get_xy 0 4 3646 17 LVector4f::get_xy 0 1 1116 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2f LVector4f::get_xy(void) const;

2981 10 operator - 0 68 3646 21 LVector4f::operator - 0 1 1117 0
51
inline LVector4f LVector4f::operator -(void) const;

2982 10 operator + 0 4 3646 21 LVector4f::operator + 0 2 1118 1119 0
141
inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator +(LVector4f const &other) const;

2983 10 operator - 0 4 3646 21 LVector4f::operator - 0 2 1120 1121 0
141
inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator -(LVector4f const &other) const;

2984 10 operator * 0 4 3646 21 LVector4f::operator * 0 1 1122 0
59
inline LVector4f LVector4f::operator *(float scalar) const;

2985 10 operator / 0 4 3646 21 LVector4f::operator / 0 1 1123 0
59
inline LVector4f LVector4f::operator /(float scalar) const;

2986 10 normalized 0 4 3646 21 LVector4f::normalized 0 1 1124 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4f LVector4f::normalized(void) const;

2987 7 project 0 4 3646 18 LVector4f::project 0 1 1125 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4f LVector4f::project(LVecBase4f const &onto) const;

2988 8 __repr__ 0 4 3646 19 LVector4f::__repr__ 0 1 1126 0
51
inline std::string LVector4f::__repr__(void) const;

2989 14 get_class_type 0 4 3646 25 LVector4f::get_class_type 0 1 1127 0
50
static TypeHandle LVector4f::get_class_type(void);

2990 10 ~LVector4f 0 516 3646 21 LVector4f::~LVector4f 0 0 0
28
LVector4f::~LVector4f(void);

2991 9 LVector4d 0 260 3647 20 LVector4d::LVector4d 0 6 1128 1129 1130 1131 1132 1133 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
335
inline LVector4d::LVector4d(void) = default;
inline LVector4d::LVector4d(LVecBase4d const &copy);
inline LVector4d::LVector4d(double fill_value);
inline LVector4d::LVector4d(double x, double y, double z, double w);
inline LVector4d::LVector4d(LVecBase3d const &copy, double w);
inline LVector4d::LVector4d(LVector4d const &) = default;

2992 11 __getattr__ 0 4 3647 22 LVector4d::__getattr__ 0 1 1134 0
92
inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2993 11 __setattr__ 0 4 3647 22 LVector4d::__setattr__ 0 1 1135 0
98
inline int LVector4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2994 4 zero 0 4 3647 15 LVector4d::zero 0 1 1136 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4d const &LVector4d::zero(void);

2995 6 unit_x 0 4 3647 17 LVector4d::unit_x 0 1 1137 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4d const &LVector4d::unit_x(void);

2996 6 unit_y 0 4 3647 17 LVector4d::unit_y 0 1 1138 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4d const &LVector4d::unit_y(void);

2997 6 unit_z 0 4 3647 17 LVector4d::unit_z 0 1 1139 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4d const &LVector4d::unit_z(void);

2998 6 unit_w 0 4 3647 17 LVector4d::unit_w 0 1 1140 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4d const &LVector4d::unit_w(void);

2999 7 get_xyz 0 4 3647 18 LVector4d::get_xyz 0 1 1141 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3d LVector4d::get_xyz(void) const;

3000 6 get_xy 0 4 3647 17 LVector4d::get_xy 0 1 1142 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2d LVector4d::get_xy(void) const;

3001 10 operator - 0 68 3647 21 LVector4d::operator - 0 1 1143 0
51
inline LVector4d LVector4d::operator -(void) const;

3002 10 operator + 0 4 3647 21 LVector4d::operator + 0 2 1144 1145 0
141
inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator +(LVector4d const &other) const;

3003 10 operator - 0 4 3647 21 LVector4d::operator - 0 2 1146 1147 0
141
inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator -(LVector4d const &other) const;

3004 10 operator * 0 4 3647 21 LVector4d::operator * 0 1 1148 0
60
inline LVector4d LVector4d::operator *(double scalar) const;

3005 10 operator / 0 4 3647 21 LVector4d::operator / 0 1 1149 0
60
inline LVector4d LVector4d::operator /(double scalar) const;

3006 10 normalized 0 4 3647 21 LVector4d::normalized 0 1 1150 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4d LVector4d::normalized(void) const;

3007 7 project 0 4 3647 18 LVector4d::project 0 1 1151 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4d LVector4d::project(LVecBase4d const &onto) const;

3008 8 __repr__ 0 4 3647 19 LVector4d::__repr__ 0 1 1152 0
51
inline std::string LVector4d::__repr__(void) const;

3009 14 get_class_type 0 4 3647 25 LVector4d::get_class_type 0 1 1153 0
50
static TypeHandle LVector4d::get_class_type(void);

3010 10 ~LVector4d 0 516 3647 21 LVector4d::~LVector4d 0 0 0
28
LVector4d::~LVector4d(void);

3011 9 LVector4i 0 260 3648 20 LVector4i::LVector4i 0 6 1154 1155 1156 1157 1158 1159 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
317
inline LVector4i::LVector4i(void) = default;
inline LVector4i::LVector4i(LVecBase4i const &copy);
inline LVector4i::LVector4i(int fill_value);
inline LVector4i::LVector4i(int x, int y, int z, int w);
inline LVector4i::LVector4i(LVecBase3i const &copy, int w);
inline LVector4i::LVector4i(LVector4i const &) = default;

3012 11 __getattr__ 0 4 3648 22 LVector4i::__getattr__ 0 1 1160 0
92
inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &attr_name) const;

3013 11 __setattr__ 0 4 3648 22 LVector4i::__setattr__ 0 1 1161 0
98
inline int LVector4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3014 4 zero 0 4 3648 15 LVector4i::zero 0 1 1162 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4i const &LVector4i::zero(void);

3015 6 unit_x 0 4 3648 17 LVector4i::unit_x 0 1 1163 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4i const &LVector4i::unit_x(void);

3016 6 unit_y 0 4 3648 17 LVector4i::unit_y 0 1 1164 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4i const &LVector4i::unit_y(void);

3017 6 unit_z 0 4 3648 17 LVector4i::unit_z 0 1 1165 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4i const &LVector4i::unit_z(void);

3018 6 unit_w 0 4 3648 17 LVector4i::unit_w 0 1 1166 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4i const &LVector4i::unit_w(void);

3019 7 get_xyz 0 4 3648 18 LVector4i::get_xyz 0 1 1167 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3i LVector4i::get_xyz(void) const;

3020 6 get_xy 0 4 3648 17 LVector4i::get_xy 0 1 1168 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2i LVector4i::get_xy(void) const;

3021 10 operator - 0 68 3648 21 LVector4i::operator - 0 1 1169 0
51
inline LVector4i LVector4i::operator -(void) const;

3022 10 operator + 0 4 3648 21 LVector4i::operator + 0 2 1170 1171 0
141
inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator +(LVector4i const &other) const;

3023 10 operator - 0 4 3648 21 LVector4i::operator - 0 2 1172 1173 0
141
inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator -(LVector4i const &other) const;

3024 10 operator * 0 4 3648 21 LVector4i::operator * 0 1 1174 0
57
inline LVector4i LVector4i::operator *(int scalar) const;

3025 10 operator / 0 4 3648 21 LVector4i::operator / 0 1 1175 0
57
inline LVector4i LVector4i::operator /(int scalar) const;

3026 8 __repr__ 0 4 3648 19 LVector4i::__repr__ 0 1 1176 0
51
inline std::string LVector4i::__repr__(void) const;

3027 14 get_class_type 0 4 3648 25 LVector4i::get_class_type 0 1 1177 0
50
static TypeHandle LVector4i::get_class_type(void);

3028 10 ~LVector4i 0 516 3648 21 LVector4i::~LVector4i 0 0 0
28
LVector4i::~LVector4i(void);

3029 8 LPoint4f 0 260 3649 18 LPoint4f::LPoint4f 0 6 1178 1179 1180 1181 1182 1183 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
316
inline LPoint4f::LPoint4f(void) = default;
inline LPoint4f::LPoint4f(LVecBase4f const &copy);
inline LPoint4f::LPoint4f(float fill_value);
inline LPoint4f::LPoint4f(float x, float y, float z, float w);
inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w);
inline LPoint4f::LPoint4f(LPoint4f const &) = default;

3030 11 __getattr__ 0 4 3649 21 LPoint4f::__getattr__ 0 1 1184 0
91
inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &attr_name) const;

3031 11 __setattr__ 0 4 3649 21 LPoint4f::__setattr__ 0 1 1185 0
97
inline int LPoint4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3032 4 zero 0 4 3649 14 LPoint4f::zero 0 1 1186 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4f const &LPoint4f::zero(void);

3033 6 unit_x 0 4 3649 16 LPoint4f::unit_x 0 1 1187 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4f const &LPoint4f::unit_x(void);

3034 6 unit_y 0 4 3649 16 LPoint4f::unit_y 0 1 1188 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4f const &LPoint4f::unit_y(void);

3035 6 unit_z 0 4 3649 16 LPoint4f::unit_z 0 1 1189 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4f const &LPoint4f::unit_z(void);

3036 6 unit_w 0 4 3649 16 LPoint4f::unit_w 0 1 1190 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4f const &LPoint4f::unit_w(void);

3037 7 get_xyz 0 4 3649 17 LPoint4f::get_xyz 0 1 1191 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3f LPoint4f::get_xyz(void) const;

3038 6 get_xy 0 4 3649 16 LPoint4f::get_xy 0 1 1192 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2f LPoint4f::get_xy(void) const;

3039 10 operator - 0 68 3649 20 LPoint4f::operator - 0 1 1193 0
49
inline LPoint4f LPoint4f::operator -(void) const;

3040 10 operator + 0 4 3649 20 LPoint4f::operator + 0 2 1194 1195 0
138
inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const;
inline LPoint4f LPoint4f::operator +(LVector4f const &other) const;

3041 10 operator - 0 4 3649 20 LPoint4f::operator - 0 3 1196 1197 1198 0
206
inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const;
inline LVector4f LPoint4f::operator -(LPoint4f const &other) const;
inline LPoint4f LPoint4f::operator -(LVector4f const &other) const;

3042 10 operator * 0 4 3649 20 LPoint4f::operator * 0 1 1199 0
57
inline LPoint4f LPoint4f::operator *(float scalar) const;

3043 10 operator / 0 4 3649 20 LPoint4f::operator / 0 1 1200 0
57
inline LPoint4f LPoint4f::operator /(float scalar) const;

3044 10 normalized 0 4 3649 20 LPoint4f::normalized 0 1 1201 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4f LPoint4f::normalized(void) const;

3045 7 project 0 4 3649 17 LPoint4f::project 0 1 1202 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const;

3046 8 __repr__ 0 4 3649 18 LPoint4f::__repr__ 0 1 1203 0
50
inline std::string LPoint4f::__repr__(void) const;

3047 14 get_class_type 0 4 3649 24 LPoint4f::get_class_type 0 1 1204 0
49
static TypeHandle LPoint4f::get_class_type(void);

3048 9 ~LPoint4f 0 516 3649 19 LPoint4f::~LPoint4f 0 0 0
26
LPoint4f::~LPoint4f(void);

3049 8 LPoint4d 0 260 3650 18 LPoint4d::LPoint4d 0 6 1205 1206 1207 1208 1209 1210 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
322
inline LPoint4d::LPoint4d(void) = default;
inline LPoint4d::LPoint4d(LVecBase4d const &copy);
inline LPoint4d::LPoint4d(double fill_value);
inline LPoint4d::LPoint4d(double x, double y, double z, double w);
inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w);
inline LPoint4d::LPoint4d(LPoint4d const &) = default;

3050 11 __getattr__ 0 4 3650 21 LPoint4d::__getattr__ 0 1 1211 0
91
inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &attr_name) const;

3051 11 __setattr__ 0 4 3650 21 LPoint4d::__setattr__ 0 1 1212 0
97
inline int LPoint4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3052 4 zero 0 4 3650 14 LPoint4d::zero 0 1 1213 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4d const &LPoint4d::zero(void);

3053 6 unit_x 0 4 3650 16 LPoint4d::unit_x 0 1 1214 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4d const &LPoint4d::unit_x(void);

3054 6 unit_y 0 4 3650 16 LPoint4d::unit_y 0 1 1215 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4d const &LPoint4d::unit_y(void);

3055 6 unit_z 0 4 3650 16 LPoint4d::unit_z 0 1 1216 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4d const &LPoint4d::unit_z(void);

3056 6 unit_w 0 4 3650 16 LPoint4d::unit_w 0 1 1217 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4d const &LPoint4d::unit_w(void);

3057 7 get_xyz 0 4 3650 17 LPoint4d::get_xyz 0 1 1218 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3d LPoint4d::get_xyz(void) const;

3058 6 get_xy 0 4 3650 16 LPoint4d::get_xy 0 1 1219 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2d LPoint4d::get_xy(void) const;

3059 10 operator - 0 68 3650 20 LPoint4d::operator - 0 1 1220 0
49
inline LPoint4d LPoint4d::operator -(void) const;

3060 10 operator + 0 4 3650 20 LPoint4d::operator + 0 2 1221 1222 0
138
inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const;
inline LPoint4d LPoint4d::operator +(LVector4d const &other) const;

3061 10 operator - 0 4 3650 20 LPoint4d::operator - 0 3 1223 1224 1225 0
206
inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const;
inline LVector4d LPoint4d::operator -(LPoint4d const &other) const;
inline LPoint4d LPoint4d::operator -(LVector4d const &other) const;

3062 10 operator * 0 4 3650 20 LPoint4d::operator * 0 1 1226 0
58
inline LPoint4d LPoint4d::operator *(double scalar) const;

3063 10 operator / 0 4 3650 20 LPoint4d::operator / 0 1 1227 0
58
inline LPoint4d LPoint4d::operator /(double scalar) const;

3064 10 normalized 0 4 3650 20 LPoint4d::normalized 0 1 1228 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4d LPoint4d::normalized(void) const;

3065 7 project 0 4 3650 17 LPoint4d::project 0 1 1229 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const;

3066 8 __repr__ 0 4 3650 18 LPoint4d::__repr__ 0 1 1230 0
50
inline std::string LPoint4d::__repr__(void) const;

3067 14 get_class_type 0 4 3650 24 LPoint4d::get_class_type 0 1 1231 0
49
static TypeHandle LPoint4d::get_class_type(void);

3068 9 ~LPoint4d 0 516 3650 19 LPoint4d::~LPoint4d 0 0 0
26
LPoint4d::~LPoint4d(void);

3069 8 LPoint4i 0 260 3651 18 LPoint4i::LPoint4i 0 6 1232 1233 1234 1235 1236 1237 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
304
inline LPoint4i::LPoint4i(void) = default;
inline LPoint4i::LPoint4i(LVecBase4i const &copy);
inline LPoint4i::LPoint4i(int fill_value);
inline LPoint4i::LPoint4i(int x, int y, int z, int w);
inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w);
inline LPoint4i::LPoint4i(LPoint4i const &) = default;

3070 11 __getattr__ 0 4 3651 21 LPoint4i::__getattr__ 0 1 1238 0
91
inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &attr_name) const;

3071 11 __setattr__ 0 4 3651 21 LPoint4i::__setattr__ 0 1 1239 0
97
inline int LPoint4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

3072 4 zero 0 4 3651 14 LPoint4i::zero 0 1 1240 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4i const &LPoint4i::zero(void);

3073 6 unit_x 0 4 3651 16 LPoint4i::unit_x 0 1 1241 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4i const &LPoint4i::unit_x(void);

3074 6 unit_y 0 4 3651 16 LPoint4i::unit_y 0 1 1242 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4i const &LPoint4i::unit_y(void);

3075 6 unit_z 0 4 3651 16 LPoint4i::unit_z 0 1 1243 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4i const &LPoint4i::unit_z(void);

3076 6 unit_w 0 4 3651 16 LPoint4i::unit_w 0 1 1244 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4i const &LPoint4i::unit_w(void);

3077 7 get_xyz 0 4 3651 17 LPoint4i::get_xyz 0 1 1245 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3i LPoint4i::get_xyz(void) const;

3078 6 get_xy 0 4 3651 16 LPoint4i::get_xy 0 1 1246 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2i LPoint4i::get_xy(void) const;

3079 10 operator - 0 68 3651 20 LPoint4i::operator - 0 1 1247 0
49
inline LPoint4i LPoint4i::operator -(void) const;

3080 10 operator + 0 4 3651 20 LPoint4i::operator + 0 2 1248 1249 0
138
inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const;
inline LPoint4i LPoint4i::operator +(LVector4i const &other) const;

3081 10 operator - 0 4 3651 20 LPoint4i::operator - 0 3 1250 1251 1252 0
206
inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const;
inline LVector4i LPoint4i::operator -(LPoint4i const &other) const;
inline LPoint4i LPoint4i::operator -(LVector4i const &other) const;

3082 10 operator * 0 4 3651 20 LPoint4i::operator * 0 1 1253 0
55
inline LPoint4i LPoint4i::operator *(int scalar) const;

3083 10 operator / 0 4 3651 20 LPoint4i::operator / 0 1 1254 0
55
inline LPoint4i LPoint4i::operator /(int scalar) const;

3084 8 __repr__ 0 4 3651 18 LPoint4i::__repr__ 0 1 1255 0
50
inline std::string LPoint4i::__repr__(void) const;

3085 14 get_class_type 0 4 3651 24 LPoint4i::get_class_type 0 1 1256 0
49
static TypeHandle LPoint4i::get_class_type(void);

3086 9 ~LPoint4i 0 516 3651 19 LPoint4i::~LPoint4i 0 0 0
26
LPoint4i::~LPoint4i(void);

3087 11 operator [] 0 4 3654 27 LMatrix3f::Row::operator [] 0 2 1359 1360 10
/**
 *
 */
104
inline float LMatrix3f::Row::operator [](int i) const;
inline float &LMatrix3f::Row::operator [](int i);

3088 4 size 0 4 3654 20 LMatrix3f::Row::size 0 1 1361 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3f::Row::size(void);

3089 17 operator typecast 0 132 3654 33 LMatrix3f::Row::operator typecast 0 1 1362 0
47
inline operator LVecBase3f const &(void) const;

3090 3 Row 0 260 3654 19 LMatrix3f::Row::Row 0 1 1358 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default;

3091 4 ~Row 0 516 3654 20 LMatrix3f::Row::~Row 0 0 0
27
LMatrix3f::Row::~Row(void);

3092 11 operator [] 0 4 3655 28 LMatrix3f::CRow::operator [] 0 1 1364 0
55
inline float LMatrix3f::CRow::operator [](int i) const;

3093 4 size 0 4 3655 21 LMatrix3f::CRow::size 0 1 1365 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3f::CRow::size(void);

3094 17 operator typecast 0 132 3655 34 LMatrix3f::CRow::operator typecast 0 1 1366 0
47
inline operator LVecBase3f const &(void) const;

3095 4 CRow 0 260 3655 21 LMatrix3f::CRow::CRow 0 1 1363 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default;

3096 5 ~CRow 0 516 3655 22 LMatrix3f::CRow::~CRow 0 0 0
29
LMatrix3f::CRow::~CRow(void);

3097 9 LMatrix3f 0 260 3652 20 LMatrix3f::LMatrix3f 0 4 1257 1258 1259 1260 96
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
277
inline LMatrix3f::LMatrix3f(void);
inline LMatrix3f::LMatrix3f(LMatrix3f const &other);
inline LMatrix3f::LMatrix3f(float , float , float , float , float , float , float , float , float );
inline LMatrix3f::LMatrix3f(LVecBase3f const &, LVecBase3f const &, LVecBase3f const &);

3098 10 operator = 0 4 3652 21 LMatrix3f::operator = 0 2 1261 1262 22
/**
 *
 */

/**
 *
 */
111
inline void LMatrix3f::operator =(LMatrix3f const &other);
inline void LMatrix3f::operator =(float fill_value);

3099 12 operator new 0 4 3652 23 LMatrix3f::operator new 0 1 1263 0
122
inline void *LMatrix3f::operator new(std::size_t size);
inline void *LMatrix3f::operator new(std::size_t size, void *ptr);

3100 15 operator delete 0 4 3652 26 LMatrix3f::operator delete 0 0 0
106
inline void LMatrix3f::operator delete(void *ptr);
inline void LMatrix3f::operator delete(void *, void *);

3101 12 validate_ptr 0 4 3652 23 LMatrix3f::validate_ptr 0 0 0
60
static inline bool LMatrix3f::validate_ptr(void const *ptr);

3102 10 __reduce__ 0 4 3652 21 LMatrix3f::__reduce__ 0 1 1264 0
61
inline PyObject *LMatrix3f::__reduce__(PyObject *self) const;

3103 4 fill 0 4 3652 15 LMatrix3f::fill 0 1 1265 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
39
void LMatrix3f::fill(float fill_value);

3104 3 set 0 4 3652 14 LMatrix3f::set 0 1 1266 10
/**
 *
 */
126
inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

3105 11 operator [] 0 4 3652 22 LMatrix3f::operator [] 0 2 1267 1268 0
112
inline LMatrix3f::CRow LMatrix3f::operator [](int i) const;
inline LMatrix3f::Row LMatrix3f::operator [](int i);

3106 4 size 0 4 3652 15 LMatrix3f::size 0 1 1269 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3f::size(void);

3107 7 set_row 0 4 3652 18 LMatrix3f::set_row 0 2 1270 1271 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3f::set_row(int row, LVecBase3f const &v);
inline void LMatrix3f::set_row(int row, LVecBase2f const &v);

3108 7 set_col 0 4 3652 18 LMatrix3f::set_col 0 2 1272 1273 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3f::set_col(int col, LVecBase3f const &v);
inline void LMatrix3f::set_col(int col, LVecBase2f const &v);

3109 7 get_row 0 4 3652 18 LMatrix3f::get_row 0 2 1274 1275 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3f LMatrix3f::get_row(int row) const;
inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const;

3110 7 get_col 0 4 3652 18 LMatrix3f::get_col 0 1 1276 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3f LMatrix3f::get_col(int col) const;

3111 8 get_row2 0 4 3652 19 LMatrix3f::get_row2 0 1 1277 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2f LMatrix3f::get_row2(int row) const;

3112 8 get_col2 0 4 3652 19 LMatrix3f::get_col2 0 1 1278 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2f LMatrix3f::get_col2(int col) const;

3113 11 operator () 0 4 3652 22 LMatrix3f::operator () 0 2 1279 1280 10
/**
 *
 */
116
inline float &LMatrix3f::operator ()(int row, int col);
inline float LMatrix3f::operator ()(int row, int col) const;

3114 6 is_nan 0 4 3652 17 LMatrix3f::is_nan 0 1 1281 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3f::is_nan(void) const;

3115 11 is_identity 0 4 3652 22 LMatrix3f::is_identity 0 1 1282 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3f::is_identity(void) const;

3116 8 get_cell 0 4 3652 19 LMatrix3f::get_cell 0 1 1283 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix3f::get_cell(int row, int col) const;

3117 8 set_cell 0 4 3652 19 LMatrix3f::set_cell 0 1 1284 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix3f::set_cell(int row, int col, float value);

3118 8 get_data 0 4 3652 19 LMatrix3f::get_data 0 1 1285 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix3f::get_data(void) const;

3119 18 get_num_components 0 4 3652 29 LMatrix3f::get_num_components 0 1 1286 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3f::get_num_components(void) const;

3120 10 operator < 0 4 3652 21 LMatrix3f::operator < 0 1 1287 0
64
inline bool LMatrix3f::operator <(LMatrix3f const &other) const;

3121 11 operator == 0 4 3652 22 LMatrix3f::operator == 0 1 1288 0
65
inline bool LMatrix3f::operator ==(LMatrix3f const &other) const;

3122 11 operator != 0 4 3652 22 LMatrix3f::operator != 0 1 1289 0
65
inline bool LMatrix3f::operator !=(LMatrix3f const &other) const;

3123 10 compare_to 0 4 3652 21 LMatrix3f::compare_to 0 2 1290 1291 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix3f::compare_to(LMatrix3f const &other) const;
int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const;

3124 8 get_hash 0 4 3652 19 LMatrix3f::get_hash 0 2 1292 1293 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix3f::get_hash(void) const;
inline std::size_t LMatrix3f::get_hash(float threshold) const;

3125 8 add_hash 0 4 3652 19 LMatrix3f::add_hash 0 2 1294 1295 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix3f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const;

3126 5 xform 0 4 3652 16 LMatrix3f::xform 0 1 1296 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const;

3127 11 xform_point 0 4 3652 22 LMatrix3f::xform_point 0 1 1297 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const;

3128 9 xform_vec 0 4 3652 20 LMatrix3f::xform_vec 0 2 1298 1299 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const;
inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const;

3129 17 xform_vec_general 0 4 3652 28 LMatrix3f::xform_vec_general 0 1 1300 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const;

3130 14 xform_in_place 0 4 3652 25 LMatrix3f::xform_in_place 0 1 1301 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3f::xform_in_place(LVecBase3f &v) const;

3131 20 xform_point_in_place 0 4 3652 31 LMatrix3f::xform_point_in_place 0 1 1302 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const;

3132 18 xform_vec_in_place 0 4 3652 29 LMatrix3f::xform_vec_in_place 0 2 1303 1304 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const;
inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const;

3133 26 xform_vec_general_in_place 0 4 3652 37 LMatrix3f::xform_vec_general_in_place 0 1 1305 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const;

3134 8 multiply 0 4 3652 19 LMatrix3f::multiply 0 1 1306 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2);

3135 10 operator * 0 4 3652 21 LMatrix3f::operator * 0 2 1307 1308 0
129
inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const;
inline LMatrix3f LMatrix3f::operator *(float scalar) const;

3136 10 operator / 0 4 3652 21 LMatrix3f::operator / 0 1 1309 0
59
inline LMatrix3f LMatrix3f::operator /(float scalar) const;

3137 11 operator += 0 4 3652 22 LMatrix3f::operator += 0 1 1310 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator +=(LMatrix3f const &other);

3138 11 operator -= 0 4 3652 22 LMatrix3f::operator -= 0 1 1311 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator -=(LMatrix3f const &other);

3139 11 operator *= 0 4 3652 22 LMatrix3f::operator *= 0 2 1312 1313 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
121
inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator *=(float scalar);

3140 11 operator /= 0 4 3652 22 LMatrix3f::operator /= 0 1 1314 39
/**
 * Performs a memberwise scale.
 */
55
inline LMatrix3f &LMatrix3f::operator /=(float scalar);

3141 18 componentwise_mult 0 4 3652 29 LMatrix3f::componentwise_mult 0 1 1315 10
/**
 *
 */
66
inline void LMatrix3f::componentwise_mult(LMatrix3f const &other);

3142 11 determinant 0 4 3652 22 LMatrix3f::determinant 0 1 1316 49
/**
 * Returns the determinant of the matrix.
 */
48
inline float LMatrix3f::determinant(void) const;

3143 14 transpose_from 0 4 3652 25 LMatrix3f::transpose_from 0 1 1317 10
/**
 *
 */
62
inline void LMatrix3f::transpose_from(LMatrix3f const &other);

3144 18 transpose_in_place 0 4 3652 29 LMatrix3f::transpose_in_place 0 1 1318 10
/**
 *
 */
48
inline void LMatrix3f::transpose_in_place(void);

3145 11 invert_from 0 4 3652 22 LMatrix3f::invert_from 0 1 1319 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3f::invert_from(LMatrix3f const &other);

3146 15 invert_in_place 0 4 3652 26 LMatrix3f::invert_in_place 0 1 1320 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3f::invert_in_place(void);

3147 21 invert_transpose_from 0 4 3652 32 LMatrix3f::invert_transpose_from 0 2 1321 1322 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other);
inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other);

3148 9 ident_mat 0 4 3652 20 LMatrix3f::ident_mat 0 1 1323 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3f const &LMatrix3f::ident_mat(void);

3149 17 set_translate_mat 0 4 3652 28 LMatrix3f::set_translate_mat 0 1 1324 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans);

3150 14 set_rotate_mat 0 4 3652 25 LMatrix3f::set_rotate_mat 0 2 1325 1326 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
156
inline void LMatrix3f::set_rotate_mat(float angle);
void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3151 13 set_scale_mat 0 4 3652 24 LMatrix3f::set_scale_mat 0 2 1327 1328 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale);
inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale);

3152 13 translate_mat 0 4 3652 24 LMatrix3f::translate_mat 0 2 1329 1330 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
144
static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans);
static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty);

3153 10 rotate_mat 0 4 3652 21 LMatrix3f::rotate_mat 0 2 1331 1332 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
179
static inline LMatrix3f LMatrix3f::rotate_mat(float angle);
static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3154 9 scale_mat 0 4 3652 20 LMatrix3f::scale_mat 0 4 1333 1334 1335 1336 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
283
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy);
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz);

3155 23 set_rotate_mat_normaxis 0 4 3652 34 LMatrix3f::set_rotate_mat_normaxis 0 1 1337 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
113
void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3156 19 rotate_mat_normaxis 0 4 3652 30 LMatrix3f::rotate_mat_normaxis 0 1 1338 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
128
static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3157 13 set_shear_mat 0 4 3652 24 LMatrix3f::set_shear_mat 0 1 1339 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3158 9 shear_mat 0 4 3652 20 LMatrix3f::shear_mat 0 2 1340 1341 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3159 19 set_scale_shear_mat 0 4 3652 30 LMatrix3f::set_scale_shear_mat 0 1 1342 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3160 15 scale_shear_mat 0 4 3652 26 LMatrix3f::scale_shear_mat 0 2 1343 1344 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3161 11 convert_mat 0 4 3652 22 LMatrix3f::convert_mat 0 1 1345 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3162 12 almost_equal 0 4 3652 23 LMatrix3f::almost_equal 0 2 1346 1347 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
143
bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const;
inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const;

3163 6 output 0 4 3652 17 LMatrix3f::output 0 1 1348 10
/**
 *
 */
48
void LMatrix3f::output(std::ostream &out) const;

3164 5 write 0 4 3652 16 LMatrix3f::write 0 1 1349 10
/**
 *
 */
69
void LMatrix3f::write(std::ostream &out, int indent_level = 0) const;

3165 8 __repr__ 0 4 3652 19 LMatrix3f::__repr__ 0 1 1350 0
51
inline std::string LMatrix3f::__repr__(void) const;

3166 13 generate_hash 0 4 3652 24 LMatrix3f::generate_hash 0 2 1351 1352 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
161
inline void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

3167 20 write_datagram_fixed 0 4 3652 31 LMatrix3f::write_datagram_fixed 0 1 1353 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3f::write_datagram_fixed(Datagram &destination) const;

3168 19 read_datagram_fixed 0 4 3652 30 LMatrix3f::read_datagram_fixed 0 1 1354 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3f::read_datagram_fixed(DatagramIterator &scan);

3169 14 write_datagram 0 4 3652 25 LMatrix3f::write_datagram 0 1 1355 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3f::write_datagram(Datagram &destination) const;

3170 13 read_datagram 0 4 3652 24 LMatrix3f::read_datagram 0 1 1356 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3f::read_datagram(DatagramIterator &source);

3171 14 get_class_type 0 4 3652 25 LMatrix3f::get_class_type 0 1 1357 0
50
static TypeHandle LMatrix3f::get_class_type(void);

3172 10 ~LMatrix3f 0 516 3652 21 LMatrix3f::~LMatrix3f 0 0 0
28
LMatrix3f::~LMatrix3f(void);

3173 9 transpose 0 1 0 9 transpose 0 4 1929 1930 1931 1932 0
191
inline LMatrix3f transpose(LMatrix3f const &a);
inline LMatrix4f transpose(LMatrix4f const &a);
inline LMatrix3d transpose(LMatrix3d const &a);
inline LMatrix4d transpose(LMatrix4d const &a);

3174 6 invert 0 1 0 6 invert 0 6 1933 1934 1935 1936 1937 1938 0
281
inline LMatrix3f invert(LMatrix3f const &a);
inline LMatrix4f invert(LMatrix4f const &a);
inline LMatrix3d invert(LMatrix3d const &a);
inline LMatrix4d invert(LMatrix4d const &a);
inline LQuaternionf invert(LQuaternionf const &a);
inline LQuaterniond invert(LQuaterniond const &a);

3175 11 operator [] 0 4 3658 27 LMatrix4f::Row::operator [] 0 2 1479 1480 10
/**
 *
 */
104
inline float LMatrix4f::Row::operator [](int i) const;
inline float &LMatrix4f::Row::operator [](int i);

3176 4 size 0 4 3658 20 LMatrix4f::Row::size 0 1 1481 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4f::Row::size(void);

3177 17 operator typecast 0 132 3658 33 LMatrix4f::Row::operator typecast 0 1 1482 0
47
inline operator LVecBase4f const &(void) const;

3178 3 Row 0 260 3658 19 LMatrix4f::Row::Row 0 1 1478 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default;

3179 4 ~Row 0 516 3658 20 LMatrix4f::Row::~Row 0 0 0
27
LMatrix4f::Row::~Row(void);

3180 11 operator [] 0 4 3659 28 LMatrix4f::CRow::operator [] 0 1 1484 0
55
inline float LMatrix4f::CRow::operator [](int i) const;

3181 4 size 0 4 3659 21 LMatrix4f::CRow::size 0 1 1485 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4f::CRow::size(void);

3182 17 operator typecast 0 132 3659 34 LMatrix4f::CRow::operator typecast 0 1 1486 0
47
inline operator LVecBase4f const &(void) const;

3183 4 CRow 0 260 3659 21 LMatrix4f::CRow::CRow 0 1 1483 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default;

3184 5 ~CRow 0 516 3659 22 LMatrix4f::CRow::~CRow 0 0 0
29
LMatrix4f::CRow::~CRow(void);

3185 9 LMatrix4f 0 260 3656 20 LMatrix4f::LMatrix4f 0 7 1367 1368 1369 1370 1371 1372 1373 228
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
548
inline LMatrix4f::LMatrix4f(void);
inline LMatrix4f::LMatrix4f(LMatrix4f const &other);
inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other);
inline LMatrix4f::LMatrix4f(float , float , float , float , float , float , float , float , float , float , float , float , float , float , float , float );
inline LMatrix4f::LMatrix4f(LVecBase4f const &, LVecBase4f const &, LVecBase4f const &, LVecBase4f const &);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans);

3186 10 operator = 0 4 3656 21 LMatrix4f::operator = 0 3 1374 1375 1376 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
179
inline void LMatrix4f::operator =(LMatrix4f const &other);
inline void LMatrix4f::operator =(UnalignedLMatrix4f const &other);
inline void LMatrix4f::operator =(float fill_value);

3187 12 operator new 0 4 3656 23 LMatrix4f::operator new 0 1 1377 0
122
inline void *LMatrix4f::operator new(std::size_t size);
inline void *LMatrix4f::operator new(std::size_t size, void *ptr);

3188 15 operator delete 0 4 3656 26 LMatrix4f::operator delete 0 0 0
106
inline void LMatrix4f::operator delete(void *ptr);
inline void LMatrix4f::operator delete(void *, void *);

3189 12 validate_ptr 0 4 3656 23 LMatrix4f::validate_ptr 0 0 0
60
static inline bool LMatrix4f::validate_ptr(void const *ptr);

3190 10 __reduce__ 0 4 3656 21 LMatrix4f::__reduce__ 0 1 1378 0
61
inline PyObject *LMatrix4f::__reduce__(PyObject *self) const;

3191 4 fill 0 4 3656 15 LMatrix4f::fill 0 1 1379 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
46
inline void LMatrix4f::fill(float fill_value);

3192 3 set 0 4 3656 14 LMatrix4f::set 0 1 1380 10
/**
 *
 */
203
inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3193 11 set_upper_3 0 4 3656 22 LMatrix4f::set_upper_3 0 1 1381 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3);

3194 11 get_upper_3 0 4 3656 22 LMatrix4f::get_upper_3 0 1 1382 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3f LMatrix4f::get_upper_3(void) const;

3195 11 operator [] 0 4 3656 22 LMatrix4f::operator [] 0 2 1383 1384 0
112
inline LMatrix4f::CRow LMatrix4f::operator [](int i) const;
inline LMatrix4f::Row LMatrix4f::operator [](int i);

3196 4 size 0 4 3656 15 LMatrix4f::size 0 1 1385 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4f::size(void);

3197 7 set_row 0 4 3656 18 LMatrix4f::set_row 0 2 1386 1387 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4f::set_row(int row, LVecBase4f const &v);
inline void LMatrix4f::set_row(int row, LVecBase3f const &v);

3198 7 set_col 0 4 3656 18 LMatrix4f::set_col 0 2 1388 1389 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4f::set_col(int col, LVecBase4f const &v);
inline void LMatrix4f::set_col(int col, LVecBase3f const &v);

3199 7 get_row 0 4 3656 18 LMatrix4f::get_row 0 2 1390 1391 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4f LMatrix4f::get_row(int row) const;
inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const;

3200 7 get_col 0 4 3656 18 LMatrix4f::get_col 0 1 1392 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4f LMatrix4f::get_col(int col) const;

3201 8 get_row3 0 4 3656 19 LMatrix4f::get_row3 0 2 1393 1394 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3f LMatrix4f::get_row3(int row) const;
inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const;

3202 8 get_col3 0 4 3656 19 LMatrix4f::get_col3 0 1 1395 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3f LMatrix4f::get_col3(int col) const;

3203 11 operator () 0 4 3656 22 LMatrix4f::operator () 0 2 1396 1397 10
/**
 *
 */
116
inline float &LMatrix4f::operator ()(int row, int col);
inline float LMatrix4f::operator ()(int row, int col) const;

3204 6 is_nan 0 4 3656 17 LMatrix4f::is_nan 0 1 1398 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4f::is_nan(void) const;

3205 11 is_identity 0 4 3656 22 LMatrix4f::is_identity 0 1 1399 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4f::is_identity(void) const;

3206 8 get_cell 0 4 3656 19 LMatrix4f::get_cell 0 1 1400 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix4f::get_cell(int row, int col) const;

3207 8 set_cell 0 4 3656 19 LMatrix4f::set_cell 0 1 1401 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix4f::set_cell(int row, int col, float value);

3208 8 get_data 0 4 3656 19 LMatrix4f::get_data 0 1 1402 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix4f::get_data(void) const;

3209 18 get_num_components 0 4 3656 29 LMatrix4f::get_num_components 0 1 1403 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4f::get_num_components(void) const;

3210 5 begin 0 4 3656 16 LMatrix4f::begin 0 2 1404 1405 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4f::iterator LMatrix4f::begin(void);
inline LMatrix4f::const_iterator LMatrix4f::begin(void) const;

3211 3 end 0 4 3656 14 LMatrix4f::end 0 2 1406 1407 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4f::iterator LMatrix4f::end(void);
inline LMatrix4f::const_iterator LMatrix4f::end(void) const;

3212 10 operator < 0 4 3656 21 LMatrix4f::operator < 0 1 1408 0
64
inline bool LMatrix4f::operator <(LMatrix4f const &other) const;

3213 11 operator == 0 4 3656 22 LMatrix4f::operator == 0 1 1409 0
65
inline bool LMatrix4f::operator ==(LMatrix4f const &other) const;

3214 11 operator != 0 4 3656 22 LMatrix4f::operator != 0 1 1410 0
65
inline bool LMatrix4f::operator !=(LMatrix4f const &other) const;

3215 10 compare_to 0 4 3656 21 LMatrix4f::compare_to 0 2 1411 1412 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix4f::compare_to(LMatrix4f const &other) const;
int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const;

3216 8 get_hash 0 4 3656 19 LMatrix4f::get_hash 0 2 1413 1414 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix4f::get_hash(void) const;
inline std::size_t LMatrix4f::get_hash(float threshold) const;

3217 8 add_hash 0 4 3656 19 LMatrix4f::add_hash 0 2 1415 1416 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix4f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const;

3218 5 xform 0 4 3656 16 LMatrix4f::xform 0 1 1417 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const;

3219 11 xform_point 0 4 3656 22 LMatrix4f::xform_point 0 1 1418 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const;

3220 19 xform_point_general 0 4 3656 30 LMatrix4f::xform_point_general 0 1 1419 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const;

3221 9 xform_vec 0 4 3656 20 LMatrix4f::xform_vec 0 1 1420 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const;

3222 17 xform_vec_general 0 4 3656 28 LMatrix4f::xform_vec_general 0 1 1421 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const;

3223 14 xform_in_place 0 4 3656 25 LMatrix4f::xform_in_place 0 1 1422 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4f::xform_in_place(LVecBase4f &v) const;

3224 20 xform_point_in_place 0 4 3656 31 LMatrix4f::xform_point_in_place 0 1 1423 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const;

3225 28 xform_point_general_in_place 0 4 3656 39 LMatrix4f::xform_point_general_in_place 0 1 1424 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const;

3226 18 xform_vec_in_place 0 4 3656 29 LMatrix4f::xform_vec_in_place 0 1 1425 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const;

3227 26 xform_vec_general_in_place 0 4 3656 37 LMatrix4f::xform_vec_general_in_place 0 1 1426 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const;

3228 8 multiply 0 4 3656 19 LMatrix4f::multiply 0 1 1427 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2);

3229 10 operator * 0 4 3656 21 LMatrix4f::operator * 0 2 1428 1429 0
129
inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const;
inline LMatrix4f LMatrix4f::operator *(float scalar) const;

3230 10 operator / 0 4 3656 21 LMatrix4f::operator / 0 1 1430 0
59
inline LMatrix4f LMatrix4f::operator /(float scalar) const;

3231 11 operator += 0 4 3656 22 LMatrix4f::operator += 0 1 1431 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator +=(LMatrix4f const &other);

3232 11 operator -= 0 4 3656 22 LMatrix4f::operator -= 0 1 1432 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator -=(LMatrix4f const &other);

3233 11 operator *= 0 4 3656 22 LMatrix4f::operator *= 0 2 1433 1434 22
/**
 *
 */

/**
 *
 */
121
inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator *=(float scalar);

3234 11 operator /= 0 4 3656 22 LMatrix4f::operator /= 0 1 1435 10
/**
 *
 */
55
inline LMatrix4f &LMatrix4f::operator /=(float scalar);

3235 18 componentwise_mult 0 4 3656 29 LMatrix4f::componentwise_mult 0 1 1436 10
/**
 *
 */
66
inline void LMatrix4f::componentwise_mult(LMatrix4f const &other);

3236 14 transpose_from 0 4 3656 25 LMatrix4f::transpose_from 0 1 1437 10
/**
 *
 */
62
inline void LMatrix4f::transpose_from(LMatrix4f const &other);

3237 18 transpose_in_place 0 4 3656 29 LMatrix4f::transpose_in_place 0 1 1438 10
/**
 *
 */
48
inline void LMatrix4f::transpose_in_place(void);

3238 11 invert_from 0 4 3656 22 LMatrix4f::invert_from 0 1 1439 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4f::invert_from(LMatrix4f const &other);

3239 18 invert_affine_from 0 4 3656 29 LMatrix4f::invert_affine_from 0 1 1440 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other);

3240 15 invert_in_place 0 4 3656 26 LMatrix4f::invert_in_place 0 1 1441 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4f::invert_in_place(void);

3241 10 accumulate 0 4 3656 21 LMatrix4f::accumulate 0 1 1442 48
/**
 * Computes `(*this) += other * weight`.
 */
72
inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight);

3242 9 ident_mat 0 4 3656 20 LMatrix4f::ident_mat 0 1 1443 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4f const &LMatrix4f::ident_mat(void);

3243 8 ones_mat 0 4 3656 19 LMatrix4f::ones_mat 0 1 1444 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4f const &LMatrix4f::ones_mat(void);

3244 9 zeros_mat 0 4 3656 20 LMatrix4f::zeros_mat 0 1 1445 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4f const &LMatrix4f::zeros_mat(void);

3245 17 set_translate_mat 0 4 3656 28 LMatrix4f::set_translate_mat 0 1 1446 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans);

3246 14 set_rotate_mat 0 4 3656 25 LMatrix4f::set_rotate_mat 0 1 1447 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
104
void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3247 23 set_rotate_mat_normaxis 0 4 3656 34 LMatrix4f::set_rotate_mat_normaxis 0 1 1448 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
113
void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3248 13 set_scale_mat 0 4 3656 24 LMatrix4f::set_scale_mat 0 1 1449 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale);

3249 13 set_shear_mat 0 4 3656 24 LMatrix4f::set_shear_mat 0 1 1450 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3250 19 set_scale_shear_mat 0 4 3656 30 LMatrix4f::set_scale_shear_mat 0 1 1451 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3251 13 translate_mat 0 4 3656 24 LMatrix4f::translate_mat 0 2 1452 1453 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
154
static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans);
static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz);

3252 10 rotate_mat 0 4 3656 21 LMatrix4f::rotate_mat 0 1 1454 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
119
static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3253 19 rotate_mat_normaxis 0 4 3656 30 LMatrix4f::rotate_mat_normaxis 0 1 1455 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
128
static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3254 9 scale_mat 0 4 3656 20 LMatrix4f::scale_mat 0 3 1456 1457 1458 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
205
static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale);
static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz);
static inline LMatrix4f LMatrix4f::scale_mat(float scale);

3255 9 shear_mat 0 4 3656 20 LMatrix4f::shear_mat 0 2 1459 1460 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3256 15 scale_shear_mat 0 4 3656 26 LMatrix4f::scale_shear_mat 0 2 1461 1462 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3257 13 y_to_z_up_mat 0 4 3656 24 LMatrix4f::y_to_z_up_mat 0 1 1463 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void);

3258 13 z_to_y_up_mat 0 4 3656 24 LMatrix4f::z_to_y_up_mat 0 1 1464 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void);

3259 11 convert_mat 0 4 3656 22 LMatrix4f::convert_mat 0 1 1465 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3260 12 almost_equal 0 4 3656 23 LMatrix4f::almost_equal 0 2 1466 1467 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
143
bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const;
inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const;

3261 6 output 0 4 3656 17 LMatrix4f::output 0 1 1468 10
/**
 *
 */
48
void LMatrix4f::output(std::ostream &out) const;

3262 5 write 0 4 3656 16 LMatrix4f::write 0 1 1469 10
/**
 *
 */
69
void LMatrix4f::write(std::ostream &out, int indent_level = 0) const;

3263 8 __repr__ 0 4 3656 19 LMatrix4f::__repr__ 0 1 1470 0
51
inline std::string LMatrix4f::__repr__(void) const;

3264 13 generate_hash 0 4 3656 24 LMatrix4f::generate_hash 0 2 1471 1472 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
157
inline void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen, float scale) const;

3265 20 write_datagram_fixed 0 4 3656 31 LMatrix4f::write_datagram_fixed 0 1 1473 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4f::write_datagram_fixed(Datagram &destination) const;

3266 19 read_datagram_fixed 0 4 3656 30 LMatrix4f::read_datagram_fixed 0 1 1474 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4f::read_datagram_fixed(DatagramIterator &scan);

3267 14 write_datagram 0 4 3656 25 LMatrix4f::write_datagram 0 1 1475 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4f::write_datagram(Datagram &destination) const;

3268 13 read_datagram 0 4 3656 24 LMatrix4f::read_datagram 0 1 1476 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4f::read_datagram(DatagramIterator &source);

3269 14 get_class_type 0 4 3656 25 LMatrix4f::get_class_type 0 1 1477 0
50
static TypeHandle LMatrix4f::get_class_type(void);

3270 10 ~LMatrix4f 0 516 3656 21 LMatrix4f::~LMatrix4f 0 0 0
28
LMatrix4f::~LMatrix4f(void);

3271 18 UnalignedLMatrix4f 0 260 3660 38 UnalignedLMatrix4f::UnalignedLMatrix4f 0 4 1487 1488 1489 1490 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
424
inline UnalignedLMatrix4f::UnalignedLMatrix4f(void);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3272 10 operator = 0 4 3660 30 UnalignedLMatrix4f::operator = 0 2 1491 1492 22
/**
 *
 */

/**
 *
 */
142
inline void UnalignedLMatrix4f::operator =(LMatrix4f const &copy);
inline void UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy);

3273 3 set 0 4 3660 23 UnalignedLMatrix4f::set 0 1 1493 10
/**
 *
 */
212
inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3274 11 operator () 0 4 3660 31 UnalignedLMatrix4f::operator () 0 2 1494 1495 10
/**
 *
 */
134
inline float &UnalignedLMatrix4f::operator ()(int row, int col);
inline float UnalignedLMatrix4f::operator ()(int row, int col) const;

3275 8 get_data 0 4 3660 28 UnalignedLMatrix4f::get_data 0 1 1496 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
61
inline float const *UnalignedLMatrix4f::get_data(void) const;

3276 18 get_num_components 0 4 3660 38 UnalignedLMatrix4f::get_num_components 0 1 1497 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4f::get_num_components(void) const;

3277 11 operator == 0 4 3660 31 UnalignedLMatrix4f::operator == 0 1 1498 0
83
inline bool UnalignedLMatrix4f::operator ==(UnalignedLMatrix4f const &other) const;

3278 11 operator != 0 4 3660 31 UnalignedLMatrix4f::operator != 0 1 1499 0
83
inline bool UnalignedLMatrix4f::operator !=(UnalignedLMatrix4f const &other) const;

3279 14 get_class_type 0 4 3660 34 UnalignedLMatrix4f::get_class_type 0 1 1500 0
59
static TypeHandle UnalignedLMatrix4f::get_class_type(void);

3280 19 ~UnalignedLMatrix4f 0 516 3660 39 UnalignedLMatrix4f::~UnalignedLMatrix4f 0 0 0
46
UnalignedLMatrix4f::~UnalignedLMatrix4f(void);

3281 11 operator [] 0 4 3664 27 LMatrix3d::Row::operator [] 0 2 1603 1604 10
/**
 *
 */
106
inline double LMatrix3d::Row::operator [](int i) const;
inline double &LMatrix3d::Row::operator [](int i);

3282 4 size 0 4 3664 20 LMatrix3d::Row::size 0 1 1605 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3d::Row::size(void);

3283 17 operator typecast 0 132 3664 33 LMatrix3d::Row::operator typecast 0 1 1606 0
47
inline operator LVecBase3d const &(void) const;

3284 3 Row 0 260 3664 19 LMatrix3d::Row::Row 0 1 1602 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default;

3285 4 ~Row 0 516 3664 20 LMatrix3d::Row::~Row 0 0 0
27
LMatrix3d::Row::~Row(void);

3286 11 operator [] 0 4 3665 28 LMatrix3d::CRow::operator [] 0 1 1608 0
56
inline double LMatrix3d::CRow::operator [](int i) const;

3287 4 size 0 4 3665 21 LMatrix3d::CRow::size 0 1 1609 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3d::CRow::size(void);

3288 17 operator typecast 0 132 3665 34 LMatrix3d::CRow::operator typecast 0 1 1610 0
47
inline operator LVecBase3d const &(void) const;

3289 4 CRow 0 260 3665 21 LMatrix3d::CRow::CRow 0 1 1607 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default;

3290 5 ~CRow 0 516 3665 22 LMatrix3d::CRow::~CRow 0 0 0
29
LMatrix3d::CRow::~CRow(void);

3291 9 LMatrix3d 0 260 3662 20 LMatrix3d::LMatrix3d 0 4 1501 1502 1503 1504 96
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
286
inline LMatrix3d::LMatrix3d(void);
inline LMatrix3d::LMatrix3d(LMatrix3d const &other);
inline LMatrix3d::LMatrix3d(double , double , double , double , double , double , double , double , double );
inline LMatrix3d::LMatrix3d(LVecBase3d const &, LVecBase3d const &, LVecBase3d const &);

3292 10 operator = 0 4 3662 21 LMatrix3d::operator = 0 2 1505 1506 22
/**
 *
 */

/**
 *
 */
112
inline void LMatrix3d::operator =(LMatrix3d const &other);
inline void LMatrix3d::operator =(double fill_value);

3293 12 operator new 0 4 3662 23 LMatrix3d::operator new 0 1 1507 0
122
inline void *LMatrix3d::operator new(std::size_t size);
inline void *LMatrix3d::operator new(std::size_t size, void *ptr);

3294 15 operator delete 0 4 3662 26 LMatrix3d::operator delete 0 0 0
106
inline void LMatrix3d::operator delete(void *ptr);
inline void LMatrix3d::operator delete(void *, void *);

3295 12 validate_ptr 0 4 3662 23 LMatrix3d::validate_ptr 0 0 0
60
static inline bool LMatrix3d::validate_ptr(void const *ptr);

3296 10 __reduce__ 0 4 3662 21 LMatrix3d::__reduce__ 0 1 1508 0
61
inline PyObject *LMatrix3d::__reduce__(PyObject *self) const;

3297 4 fill 0 4 3662 15 LMatrix3d::fill 0 1 1509 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
40
void LMatrix3d::fill(double fill_value);

3298 3 set 0 4 3662 14 LMatrix3d::set 0 1 1510 10
/**
 *
 */
135
inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3299 11 operator [] 0 4 3662 22 LMatrix3d::operator [] 0 2 1511 1512 0
112
inline LMatrix3d::CRow LMatrix3d::operator [](int i) const;
inline LMatrix3d::Row LMatrix3d::operator [](int i);

3300 4 size 0 4 3662 15 LMatrix3d::size 0 1 1513 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3d::size(void);

3301 7 set_row 0 4 3662 18 LMatrix3d::set_row 0 2 1514 1515 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3d::set_row(int row, LVecBase3d const &v);
inline void LMatrix3d::set_row(int row, LVecBase2d const &v);

3302 7 set_col 0 4 3662 18 LMatrix3d::set_col 0 2 1516 1517 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3d::set_col(int col, LVecBase3d const &v);
inline void LMatrix3d::set_col(int col, LVecBase2d const &v);

3303 7 get_row 0 4 3662 18 LMatrix3d::get_row 0 2 1518 1519 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3d LMatrix3d::get_row(int row) const;
inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const;

3304 7 get_col 0 4 3662 18 LMatrix3d::get_col 0 1 1520 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3d LMatrix3d::get_col(int col) const;

3305 8 get_row2 0 4 3662 19 LMatrix3d::get_row2 0 1 1521 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2d LMatrix3d::get_row2(int row) const;

3306 8 get_col2 0 4 3662 19 LMatrix3d::get_col2 0 1 1522 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2d LMatrix3d::get_col2(int col) const;

3307 11 operator () 0 4 3662 22 LMatrix3d::operator () 0 2 1523 1524 10
/**
 *
 */
118
inline double &LMatrix3d::operator ()(int row, int col);
inline double LMatrix3d::operator ()(int row, int col) const;

3308 6 is_nan 0 4 3662 17 LMatrix3d::is_nan 0 1 1525 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3d::is_nan(void) const;

3309 11 is_identity 0 4 3662 22 LMatrix3d::is_identity 0 1 1526 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3d::is_identity(void) const;

3310 8 get_cell 0 4 3662 19 LMatrix3d::get_cell 0 1 1527 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix3d::get_cell(int row, int col) const;

3311 8 set_cell 0 4 3662 19 LMatrix3d::set_cell 0 1 1528 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix3d::set_cell(int row, int col, double value);

3312 8 get_data 0 4 3662 19 LMatrix3d::get_data 0 1 1529 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix3d::get_data(void) const;

3313 18 get_num_components 0 4 3662 29 LMatrix3d::get_num_components 0 1 1530 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3d::get_num_components(void) const;

3314 10 operator < 0 4 3662 21 LMatrix3d::operator < 0 1 1531 0
64
inline bool LMatrix3d::operator <(LMatrix3d const &other) const;

3315 11 operator == 0 4 3662 22 LMatrix3d::operator == 0 1 1532 0
65
inline bool LMatrix3d::operator ==(LMatrix3d const &other) const;

3316 11 operator != 0 4 3662 22 LMatrix3d::operator != 0 1 1533 0
65
inline bool LMatrix3d::operator !=(LMatrix3d const &other) const;

3317 10 compare_to 0 4 3662 21 LMatrix3d::compare_to 0 2 1534 1535 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix3d::compare_to(LMatrix3d const &other) const;
int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const;

3318 8 get_hash 0 4 3662 19 LMatrix3d::get_hash 0 2 1536 1537 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix3d::get_hash(void) const;
inline std::size_t LMatrix3d::get_hash(double threshold) const;

3319 8 add_hash 0 4 3662 19 LMatrix3d::add_hash 0 2 1538 1539 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix3d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const;

3320 5 xform 0 4 3662 16 LMatrix3d::xform 0 1 1540 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const;

3321 11 xform_point 0 4 3662 22 LMatrix3d::xform_point 0 1 1541 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const;

3322 9 xform_vec 0 4 3662 20 LMatrix3d::xform_vec 0 2 1542 1543 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const;
inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const;

3323 17 xform_vec_general 0 4 3662 28 LMatrix3d::xform_vec_general 0 1 1544 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const;

3324 14 xform_in_place 0 4 3662 25 LMatrix3d::xform_in_place 0 1 1545 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3d::xform_in_place(LVecBase3d &v) const;

3325 20 xform_point_in_place 0 4 3662 31 LMatrix3d::xform_point_in_place 0 1 1546 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const;

3326 18 xform_vec_in_place 0 4 3662 29 LMatrix3d::xform_vec_in_place 0 2 1547 1548 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const;
inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const;

3327 26 xform_vec_general_in_place 0 4 3662 37 LMatrix3d::xform_vec_general_in_place 0 1 1549 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const;

3328 8 multiply 0 4 3662 19 LMatrix3d::multiply 0 1 1550 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2);

3329 10 operator * 0 4 3662 21 LMatrix3d::operator * 0 2 1551 1552 0
130
inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const;
inline LMatrix3d LMatrix3d::operator *(double scalar) const;

3330 10 operator / 0 4 3662 21 LMatrix3d::operator / 0 1 1553 0
60
inline LMatrix3d LMatrix3d::operator /(double scalar) const;

3331 11 operator += 0 4 3662 22 LMatrix3d::operator += 0 1 1554 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator +=(LMatrix3d const &other);

3332 11 operator -= 0 4 3662 22 LMatrix3d::operator -= 0 1 1555 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator -=(LMatrix3d const &other);

3333 11 operator *= 0 4 3662 22 LMatrix3d::operator *= 0 2 1556 1557 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
122
inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator *=(double scalar);

3334 11 operator /= 0 4 3662 22 LMatrix3d::operator /= 0 1 1558 39
/**
 * Performs a memberwise scale.
 */
56
inline LMatrix3d &LMatrix3d::operator /=(double scalar);

3335 18 componentwise_mult 0 4 3662 29 LMatrix3d::componentwise_mult 0 1 1559 10
/**
 *
 */
66
inline void LMatrix3d::componentwise_mult(LMatrix3d const &other);

3336 11 determinant 0 4 3662 22 LMatrix3d::determinant 0 1 1560 49
/**
 * Returns the determinant of the matrix.
 */
49
inline double LMatrix3d::determinant(void) const;

3337 14 transpose_from 0 4 3662 25 LMatrix3d::transpose_from 0 1 1561 10
/**
 *
 */
62
inline void LMatrix3d::transpose_from(LMatrix3d const &other);

3338 18 transpose_in_place 0 4 3662 29 LMatrix3d::transpose_in_place 0 1 1562 10
/**
 *
 */
48
inline void LMatrix3d::transpose_in_place(void);

3339 11 invert_from 0 4 3662 22 LMatrix3d::invert_from 0 1 1563 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3d::invert_from(LMatrix3d const &other);

3340 15 invert_in_place 0 4 3662 26 LMatrix3d::invert_in_place 0 1 1564 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3d::invert_in_place(void);

3341 21 invert_transpose_from 0 4 3662 32 LMatrix3d::invert_transpose_from 0 2 1565 1566 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other);
inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other);

3342 9 ident_mat 0 4 3662 20 LMatrix3d::ident_mat 0 1 1567 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3d const &LMatrix3d::ident_mat(void);

3343 17 set_translate_mat 0 4 3662 28 LMatrix3d::set_translate_mat 0 1 1568 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans);

3344 14 set_rotate_mat 0 4 3662 25 LMatrix3d::set_rotate_mat 0 2 1569 1570 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
158
inline void LMatrix3d::set_rotate_mat(double angle);
void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3345 13 set_scale_mat 0 4 3662 24 LMatrix3d::set_scale_mat 0 2 1571 1572 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale);
inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale);

3346 13 translate_mat 0 4 3662 24 LMatrix3d::translate_mat 0 2 1573 1574 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
146
static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans);
static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty);

3347 10 rotate_mat 0 4 3662 21 LMatrix3d::rotate_mat 0 2 1575 1576 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
181
static inline LMatrix3d LMatrix3d::rotate_mat(double angle);
static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3348 9 scale_mat 0 4 3662 20 LMatrix3d::scale_mat 0 4 1577 1578 1579 1580 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
288
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy);
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz);

3349 23 set_rotate_mat_normaxis 0 4 3662 34 LMatrix3d::set_rotate_mat_normaxis 0 1 1581 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
114
void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3350 19 rotate_mat_normaxis 0 4 3662 30 LMatrix3d::rotate_mat_normaxis 0 1 1582 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
129
static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3351 13 set_shear_mat 0 4 3662 24 LMatrix3d::set_shear_mat 0 1 1583 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3352 9 shear_mat 0 4 3662 20 LMatrix3d::shear_mat 0 2 1584 1585 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3353 19 set_scale_shear_mat 0 4 3662 30 LMatrix3d::set_scale_shear_mat 0 1 1586 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3354 15 scale_shear_mat 0 4 3662 26 LMatrix3d::scale_shear_mat 0 2 1587 1588 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3355 11 convert_mat 0 4 3662 22 LMatrix3d::convert_mat 0 1 1589 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3356 12 almost_equal 0 4 3662 23 LMatrix3d::almost_equal 0 2 1590 1591 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
144
bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const;
inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const;

3357 6 output 0 4 3662 17 LMatrix3d::output 0 1 1592 10
/**
 *
 */
48
void LMatrix3d::output(std::ostream &out) const;

3358 5 write 0 4 3662 16 LMatrix3d::write 0 1 1593 10
/**
 *
 */
69
void LMatrix3d::write(std::ostream &out, int indent_level = 0) const;

3359 8 __repr__ 0 4 3662 19 LMatrix3d::__repr__ 0 1 1594 0
51
inline std::string LMatrix3d::__repr__(void) const;

3360 13 generate_hash 0 4 3662 24 LMatrix3d::generate_hash 0 2 1595 1596 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
162
inline void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

3361 20 write_datagram_fixed 0 4 3662 31 LMatrix3d::write_datagram_fixed 0 1 1597 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3d::write_datagram_fixed(Datagram &destination) const;

3362 19 read_datagram_fixed 0 4 3662 30 LMatrix3d::read_datagram_fixed 0 1 1598 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3d::read_datagram_fixed(DatagramIterator &scan);

3363 14 write_datagram 0 4 3662 25 LMatrix3d::write_datagram 0 1 1599 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3d::write_datagram(Datagram &destination) const;

3364 13 read_datagram 0 4 3662 24 LMatrix3d::read_datagram 0 1 1600 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3d::read_datagram(DatagramIterator &source);

3365 14 get_class_type 0 4 3662 25 LMatrix3d::get_class_type 0 1 1601 0
50
static TypeHandle LMatrix3d::get_class_type(void);

3366 10 ~LMatrix3d 0 516 3662 21 LMatrix3d::~LMatrix3d 0 0 0
28
LMatrix3d::~LMatrix3d(void);

3367 11 operator [] 0 4 3668 27 LMatrix4d::Row::operator [] 0 2 1723 1724 10
/**
 *
 */
106
inline double LMatrix4d::Row::operator [](int i) const;
inline double &LMatrix4d::Row::operator [](int i);

3368 4 size 0 4 3668 20 LMatrix4d::Row::size 0 1 1725 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4d::Row::size(void);

3369 17 operator typecast 0 132 3668 33 LMatrix4d::Row::operator typecast 0 1 1726 0
47
inline operator LVecBase4d const &(void) const;

3370 3 Row 0 260 3668 19 LMatrix4d::Row::Row 0 1 1722 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default;

3371 4 ~Row 0 516 3668 20 LMatrix4d::Row::~Row 0 0 0
27
LMatrix4d::Row::~Row(void);

3372 11 operator [] 0 4 3669 28 LMatrix4d::CRow::operator [] 0 1 1728 0
56
inline double LMatrix4d::CRow::operator [](int i) const;

3373 4 size 0 4 3669 21 LMatrix4d::CRow::size 0 1 1729 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4d::CRow::size(void);

3374 17 operator typecast 0 132 3669 34 LMatrix4d::CRow::operator typecast 0 1 1730 0
47
inline operator LVecBase4d const &(void) const;

3375 4 CRow 0 260 3669 21 LMatrix4d::CRow::CRow 0 1 1727 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default;

3376 5 ~CRow 0 516 3669 22 LMatrix4d::CRow::~CRow 0 0 0
29
LMatrix4d::CRow::~CRow(void);

3377 9 LMatrix4d 0 260 3666 20 LMatrix4d::LMatrix4d 0 7 1611 1612 1613 1614 1615 1616 1617 228
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
564
inline LMatrix4d::LMatrix4d(void);
inline LMatrix4d::LMatrix4d(LMatrix4d const &other);
inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other);
inline LMatrix4d::LMatrix4d(double , double , double , double , double , double , double , double , double , double , double , double , double , double , double , double );
inline LMatrix4d::LMatrix4d(LVecBase4d const &, LVecBase4d const &, LVecBase4d const &, LVecBase4d const &);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans);

3378 10 operator = 0 4 3666 21 LMatrix4d::operator = 0 3 1618 1619 1620 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
180
inline void LMatrix4d::operator =(LMatrix4d const &other);
inline void LMatrix4d::operator =(UnalignedLMatrix4d const &other);
inline void LMatrix4d::operator =(double fill_value);

3379 12 operator new 0 4 3666 23 LMatrix4d::operator new 0 1 1621 0
122
inline void *LMatrix4d::operator new(std::size_t size);
inline void *LMatrix4d::operator new(std::size_t size, void *ptr);

3380 15 operator delete 0 4 3666 26 LMatrix4d::operator delete 0 0 0
106
inline void LMatrix4d::operator delete(void *ptr);
inline void LMatrix4d::operator delete(void *, void *);

3381 12 validate_ptr 0 4 3666 23 LMatrix4d::validate_ptr 0 0 0
60
static inline bool LMatrix4d::validate_ptr(void const *ptr);

3382 10 __reduce__ 0 4 3666 21 LMatrix4d::__reduce__ 0 1 1622 0
61
inline PyObject *LMatrix4d::__reduce__(PyObject *self) const;

3383 4 fill 0 4 3666 15 LMatrix4d::fill 0 1 1623 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
47
inline void LMatrix4d::fill(double fill_value);

3384 3 set 0 4 3666 14 LMatrix4d::set 0 1 1624 10
/**
 *
 */
219
inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3385 11 set_upper_3 0 4 3666 22 LMatrix4d::set_upper_3 0 1 1625 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3);

3386 11 get_upper_3 0 4 3666 22 LMatrix4d::get_upper_3 0 1 1626 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3d LMatrix4d::get_upper_3(void) const;

3387 11 operator [] 0 4 3666 22 LMatrix4d::operator [] 0 2 1627 1628 0
112
inline LMatrix4d::CRow LMatrix4d::operator [](int i) const;
inline LMatrix4d::Row LMatrix4d::operator [](int i);

3388 4 size 0 4 3666 15 LMatrix4d::size 0 1 1629 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4d::size(void);

3389 7 set_row 0 4 3666 18 LMatrix4d::set_row 0 2 1630 1631 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4d::set_row(int row, LVecBase4d const &v);
inline void LMatrix4d::set_row(int row, LVecBase3d const &v);

3390 7 set_col 0 4 3666 18 LMatrix4d::set_col 0 2 1632 1633 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4d::set_col(int col, LVecBase4d const &v);
inline void LMatrix4d::set_col(int col, LVecBase3d const &v);

3391 7 get_row 0 4 3666 18 LMatrix4d::get_row 0 2 1634 1635 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4d LMatrix4d::get_row(int row) const;
inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const;

3392 7 get_col 0 4 3666 18 LMatrix4d::get_col 0 1 1636 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4d LMatrix4d::get_col(int col) const;

3393 8 get_row3 0 4 3666 19 LMatrix4d::get_row3 0 2 1637 1638 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3d LMatrix4d::get_row3(int row) const;
inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const;

3394 8 get_col3 0 4 3666 19 LMatrix4d::get_col3 0 1 1639 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3d LMatrix4d::get_col3(int col) const;

3395 11 operator () 0 4 3666 22 LMatrix4d::operator () 0 2 1640 1641 10
/**
 *
 */
118
inline double &LMatrix4d::operator ()(int row, int col);
inline double LMatrix4d::operator ()(int row, int col) const;

3396 6 is_nan 0 4 3666 17 LMatrix4d::is_nan 0 1 1642 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4d::is_nan(void) const;

3397 11 is_identity 0 4 3666 22 LMatrix4d::is_identity 0 1 1643 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4d::is_identity(void) const;

3398 8 get_cell 0 4 3666 19 LMatrix4d::get_cell 0 1 1644 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix4d::get_cell(int row, int col) const;

3399 8 set_cell 0 4 3666 19 LMatrix4d::set_cell 0 1 1645 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix4d::set_cell(int row, int col, double value);

3400 8 get_data 0 4 3666 19 LMatrix4d::get_data 0 1 1646 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix4d::get_data(void) const;

3401 18 get_num_components 0 4 3666 29 LMatrix4d::get_num_components 0 1 1647 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4d::get_num_components(void) const;

3402 5 begin 0 4 3666 16 LMatrix4d::begin 0 2 1648 1649 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4d::iterator LMatrix4d::begin(void);
inline LMatrix4d::const_iterator LMatrix4d::begin(void) const;

3403 3 end 0 4 3666 14 LMatrix4d::end 0 2 1650 1651 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4d::iterator LMatrix4d::end(void);
inline LMatrix4d::const_iterator LMatrix4d::end(void) const;

3404 10 operator < 0 4 3666 21 LMatrix4d::operator < 0 1 1652 0
64
inline bool LMatrix4d::operator <(LMatrix4d const &other) const;

3405 11 operator == 0 4 3666 22 LMatrix4d::operator == 0 1 1653 0
65
inline bool LMatrix4d::operator ==(LMatrix4d const &other) const;

3406 11 operator != 0 4 3666 22 LMatrix4d::operator != 0 1 1654 0
65
inline bool LMatrix4d::operator !=(LMatrix4d const &other) const;

3407 10 compare_to 0 4 3666 21 LMatrix4d::compare_to 0 2 1655 1656 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix4d::compare_to(LMatrix4d const &other) const;
int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const;

3408 8 get_hash 0 4 3666 19 LMatrix4d::get_hash 0 2 1657 1658 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix4d::get_hash(void) const;
inline std::size_t LMatrix4d::get_hash(double threshold) const;

3409 8 add_hash 0 4 3666 19 LMatrix4d::add_hash 0 2 1659 1660 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix4d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const;

3410 5 xform 0 4 3666 16 LMatrix4d::xform 0 1 1661 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const;

3411 11 xform_point 0 4 3666 22 LMatrix4d::xform_point 0 1 1662 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const;

3412 19 xform_point_general 0 4 3666 30 LMatrix4d::xform_point_general 0 1 1663 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const;

3413 9 xform_vec 0 4 3666 20 LMatrix4d::xform_vec 0 1 1664 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const;

3414 17 xform_vec_general 0 4 3666 28 LMatrix4d::xform_vec_general 0 1 1665 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const;

3415 14 xform_in_place 0 4 3666 25 LMatrix4d::xform_in_place 0 1 1666 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4d::xform_in_place(LVecBase4d &v) const;

3416 20 xform_point_in_place 0 4 3666 31 LMatrix4d::xform_point_in_place 0 1 1667 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const;

3417 28 xform_point_general_in_place 0 4 3666 39 LMatrix4d::xform_point_general_in_place 0 1 1668 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const;

3418 18 xform_vec_in_place 0 4 3666 29 LMatrix4d::xform_vec_in_place 0 1 1669 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const;

3419 26 xform_vec_general_in_place 0 4 3666 37 LMatrix4d::xform_vec_general_in_place 0 1 1670 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const;

3420 8 multiply 0 4 3666 19 LMatrix4d::multiply 0 1 1671 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2);

3421 10 operator * 0 4 3666 21 LMatrix4d::operator * 0 2 1672 1673 0
130
inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const;
inline LMatrix4d LMatrix4d::operator *(double scalar) const;

3422 10 operator / 0 4 3666 21 LMatrix4d::operator / 0 1 1674 0
60
inline LMatrix4d LMatrix4d::operator /(double scalar) const;

3423 11 operator += 0 4 3666 22 LMatrix4d::operator += 0 1 1675 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator +=(LMatrix4d const &other);

3424 11 operator -= 0 4 3666 22 LMatrix4d::operator -= 0 1 1676 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator -=(LMatrix4d const &other);

3425 11 operator *= 0 4 3666 22 LMatrix4d::operator *= 0 2 1677 1678 22
/**
 *
 */

/**
 *
 */
122
inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator *=(double scalar);

3426 11 operator /= 0 4 3666 22 LMatrix4d::operator /= 0 1 1679 10
/**
 *
 */
56
inline LMatrix4d &LMatrix4d::operator /=(double scalar);

3427 18 componentwise_mult 0 4 3666 29 LMatrix4d::componentwise_mult 0 1 1680 10
/**
 *
 */
66
inline void LMatrix4d::componentwise_mult(LMatrix4d const &other);

3428 14 transpose_from 0 4 3666 25 LMatrix4d::transpose_from 0 1 1681 10
/**
 *
 */
62
inline void LMatrix4d::transpose_from(LMatrix4d const &other);

3429 18 transpose_in_place 0 4 3666 29 LMatrix4d::transpose_in_place 0 1 1682 10
/**
 *
 */
48
inline void LMatrix4d::transpose_in_place(void);

3430 11 invert_from 0 4 3666 22 LMatrix4d::invert_from 0 1 1683 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4d::invert_from(LMatrix4d const &other);

3431 18 invert_affine_from 0 4 3666 29 LMatrix4d::invert_affine_from 0 1 1684 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other);

3432 15 invert_in_place 0 4 3666 26 LMatrix4d::invert_in_place 0 1 1685 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4d::invert_in_place(void);

3433 10 accumulate 0 4 3666 21 LMatrix4d::accumulate 0 1 1686 48
/**
 * Computes `(*this) += other * weight`.
 */
73
inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight);

3434 9 ident_mat 0 4 3666 20 LMatrix4d::ident_mat 0 1 1687 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4d const &LMatrix4d::ident_mat(void);

3435 8 ones_mat 0 4 3666 19 LMatrix4d::ones_mat 0 1 1688 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4d const &LMatrix4d::ones_mat(void);

3436 9 zeros_mat 0 4 3666 20 LMatrix4d::zeros_mat 0 1 1689 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4d const &LMatrix4d::zeros_mat(void);

3437 17 set_translate_mat 0 4 3666 28 LMatrix4d::set_translate_mat 0 1 1690 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans);

3438 14 set_rotate_mat 0 4 3666 25 LMatrix4d::set_rotate_mat 0 1 1691 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
105
void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3439 23 set_rotate_mat_normaxis 0 4 3666 34 LMatrix4d::set_rotate_mat_normaxis 0 1 1692 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
114
void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3440 13 set_scale_mat 0 4 3666 24 LMatrix4d::set_scale_mat 0 1 1693 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale);

3441 13 set_shear_mat 0 4 3666 24 LMatrix4d::set_shear_mat 0 1 1694 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3442 19 set_scale_shear_mat 0 4 3666 30 LMatrix4d::set_scale_shear_mat 0 1 1695 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3443 13 translate_mat 0 4 3666 24 LMatrix4d::translate_mat 0 2 1696 1697 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
157
static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans);
static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz);

3444 10 rotate_mat 0 4 3666 21 LMatrix4d::rotate_mat 0 1 1698 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
120
static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3445 19 rotate_mat_normaxis 0 4 3666 30 LMatrix4d::rotate_mat_normaxis 0 1 1699 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
129
static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3446 9 scale_mat 0 4 3666 20 LMatrix4d::scale_mat 0 3 1700 1701 1702 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
209
static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale);
static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz);
static inline LMatrix4d LMatrix4d::scale_mat(double scale);

3447 9 shear_mat 0 4 3666 20 LMatrix4d::shear_mat 0 2 1703 1704 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3448 15 scale_shear_mat 0 4 3666 26 LMatrix4d::scale_shear_mat 0 2 1705 1706 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3449 13 y_to_z_up_mat 0 4 3666 24 LMatrix4d::y_to_z_up_mat 0 1 1707 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void);

3450 13 z_to_y_up_mat 0 4 3666 24 LMatrix4d::z_to_y_up_mat 0 1 1708 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void);

3451 11 convert_mat 0 4 3666 22 LMatrix4d::convert_mat 0 1 1709 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3452 12 almost_equal 0 4 3666 23 LMatrix4d::almost_equal 0 2 1710 1711 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
144
bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const;
inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const;

3453 6 output 0 4 3666 17 LMatrix4d::output 0 1 1712 10
/**
 *
 */
48
void LMatrix4d::output(std::ostream &out) const;

3454 5 write 0 4 3666 16 LMatrix4d::write 0 1 1713 10
/**
 *
 */
69
void LMatrix4d::write(std::ostream &out, int indent_level = 0) const;

3455 8 __repr__ 0 4 3666 19 LMatrix4d::__repr__ 0 1 1714 0
51
inline std::string LMatrix4d::__repr__(void) const;

3456 13 generate_hash 0 4 3666 24 LMatrix4d::generate_hash 0 2 1715 1716 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
158
inline void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen, double scale) const;

3457 20 write_datagram_fixed 0 4 3666 31 LMatrix4d::write_datagram_fixed 0 1 1717 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4d::write_datagram_fixed(Datagram &destination) const;

3458 19 read_datagram_fixed 0 4 3666 30 LMatrix4d::read_datagram_fixed 0 1 1718 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4d::read_datagram_fixed(DatagramIterator &scan);

3459 14 write_datagram 0 4 3666 25 LMatrix4d::write_datagram 0 1 1719 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4d::write_datagram(Datagram &destination) const;

3460 13 read_datagram 0 4 3666 24 LMatrix4d::read_datagram 0 1 1720 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4d::read_datagram(DatagramIterator &source);

3461 14 get_class_type 0 4 3666 25 LMatrix4d::get_class_type 0 1 1721 0
50
static TypeHandle LMatrix4d::get_class_type(void);

3462 10 ~LMatrix4d 0 516 3666 21 LMatrix4d::~LMatrix4d 0 0 0
28
LMatrix4d::~LMatrix4d(void);

3463 18 UnalignedLMatrix4d 0 260 3670 38 UnalignedLMatrix4d::UnalignedLMatrix4d 0 4 1731 1732 1733 1734 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
440
inline UnalignedLMatrix4d::UnalignedLMatrix4d(void);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3464 10 operator = 0 4 3670 30 UnalignedLMatrix4d::operator = 0 2 1735 1736 22
/**
 *
 */

/**
 *
 */
142
inline void UnalignedLMatrix4d::operator =(LMatrix4d const &copy);
inline void UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy);

3465 3 set 0 4 3670 23 UnalignedLMatrix4d::set 0 1 1737 10
/**
 *
 */
228
inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3466 11 operator () 0 4 3670 31 UnalignedLMatrix4d::operator () 0 2 1738 1739 10
/**
 *
 */
136
inline double &UnalignedLMatrix4d::operator ()(int row, int col);
inline double UnalignedLMatrix4d::operator ()(int row, int col) const;

3467 8 get_data 0 4 3670 28 UnalignedLMatrix4d::get_data 0 1 1740 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
62
inline double const *UnalignedLMatrix4d::get_data(void) const;

3468 18 get_num_components 0 4 3670 38 UnalignedLMatrix4d::get_num_components 0 1 1741 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4d::get_num_components(void) const;

3469 11 operator == 0 4 3670 31 UnalignedLMatrix4d::operator == 0 1 1742 0
83
inline bool UnalignedLMatrix4d::operator ==(UnalignedLMatrix4d const &other) const;

3470 11 operator != 0 4 3670 31 UnalignedLMatrix4d::operator != 0 1 1743 0
83
inline bool UnalignedLMatrix4d::operator !=(UnalignedLMatrix4d const &other) const;

3471 14 get_class_type 0 4 3670 34 UnalignedLMatrix4d::get_class_type 0 1 1744 0
59
static TypeHandle UnalignedLMatrix4d::get_class_type(void);

3472 19 ~UnalignedLMatrix4d 0 516 3670 39 UnalignedLMatrix4d::~UnalignedLMatrix4d 0 0 0
46
UnalignedLMatrix4d::~UnalignedLMatrix4d(void);

3473 10 operator * 0 1 0 10 operator * 0 24 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 0
1659
inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m);
inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m);
inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m);
inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m);
inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m);
inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m);
inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m);
inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m);
inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m);
inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m);
inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m);
inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m);
inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q);
inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q);
inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q);
inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q);

3474 11 operator *= 0 1 0 11 operator *= 0 16 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 0
941
inline void operator *=(LVecBase3f &v, LMatrix3f const &m);
inline void operator *=(LVector3f &v, LMatrix3f const &m);
inline void operator *=(LPoint3f &v, LMatrix3f const &m);
inline void operator *=(LVector2f &v, LMatrix3f const &m);
inline void operator *=(LPoint2f &v, LMatrix3f const &m);
inline void operator *=(LVecBase4f &v, LMatrix4f const &m);
inline void operator *=(LVector3f &v, LMatrix4f const &m);
inline void operator *=(LPoint3f &v, LMatrix4f const &m);
inline void operator *=(LVecBase3d &v, LMatrix3d const &m);
inline void operator *=(LVector3d &v, LMatrix3d const &m);
inline void operator *=(LPoint3d &v, LMatrix3d const &m);
inline void operator *=(LVector2d &v, LMatrix3d const &m);
inline void operator *=(LPoint2d &v, LMatrix3d const &m);
inline void operator *=(LVecBase4d &v, LMatrix4d const &m);
inline void operator *=(LVector3d &v, LMatrix4d const &m);
inline void operator *=(LPoint3d &v, LMatrix4d const &m);

3475 22 generic_write_datagram 0 1 0 22 generic_write_datagram 0 4 1979 1980 1981 1982 0
303
inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value);

3476 21 generic_read_datagram 0 1 0 21 generic_read_datagram 0 4 1983 1984 1985 1986 0
319
inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source);

3477 14 compose_matrix 0 1 0 14 compose_matrix 0 10 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 0
1484
void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);

3478 16 decompose_matrix 0 1 0 16 decompose_matrix 0 10 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 0
1408
bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);

3479 24 decompose_matrix_old_hpr 0 1 0 24 decompose_matrix_old_hpr 0 2 2007 2008 0
287
bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);

3480 14 old_to_new_hpr 0 1 0 14 old_to_new_hpr 0 2 2009 2010 0
107
LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr);
LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr);

3481 12 LQuaternionf 0 260 3672 26 LQuaternionf::LQuaternionf 0 5 1745 1746 1747 1748 1749 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
305
inline LQuaternionf::LQuaternionf(void);
inline LQuaternionf::LQuaternionf(LVecBase4f const &copy);
inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy);
inline LQuaternionf::LQuaternionf(float r, float i, float j, float k);
inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default;

3482 14 pure_imaginary 0 4 3672 28 LQuaternionf::pure_imaginary 0 1 1750 10
/**
 *
 */
69
static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v);

3483 9 conjugate 0 4 3672 23 LQuaternionf::conjugate 0 1 1751 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaternionf LQuaternionf::conjugate(void) const;

3484 5 xform 0 4 3672 19 LQuaternionf::xform 0 2 1752 1753 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const;
inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const;

3485 8 multiply 0 4 3672 22 LQuaternionf::multiply 0 1 1754 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const;

3486 10 operator - 0 68 3672 24 LQuaternionf::operator - 0 1 1755 0
57
inline LQuaternionf LQuaternionf::operator -(void) const;

3487 10 operator + 0 4 3672 24 LQuaternionf::operator + 0 1 1756 0
78
inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &other) const;

3488 10 operator - 0 4 3672 24 LQuaternionf::operator - 0 1 1757 0
78
inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &other) const;

3489 9 angle_rad 0 4 3672 23 LQuaternionf::angle_rad 0 1 1758 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
70
inline float LQuaternionf::angle_rad(LQuaternionf const &other) const;

3490 9 angle_deg 0 4 3672 23 LQuaternionf::angle_deg 0 1 1759 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
70
inline float LQuaternionf::angle_deg(LQuaternionf const &other) const;

3491 10 operator * 0 4 3672 24 LQuaternionf::operator * 0 4 1760 1761 1762 1763 0
263
inline LQuaternionf LQuaternionf::operator *(float scalar) const;
inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const;
inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &);
inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &);

3492 10 operator / 0 4 3672 24 LQuaternionf::operator / 0 1 1764 0
65
inline LQuaternionf LQuaternionf::operator /(float scalar) const;

3493 11 operator *= 0 4 3672 25 LQuaternionf::operator *= 0 1 1765 10
/**
 *
 */
69
inline LQuaternionf &LQuaternionf::operator *=(LQuaternionf const &);

3494 7 __pow__ 0 4 3672 21 LQuaternionf::__pow__ 0 1 1766 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
49
LQuaternionf LQuaternionf::__pow__(float ) const;

3495 12 almost_equal 0 4 3672 26 LQuaternionf::almost_equal 0 2 1767 1768 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
162
inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const;
inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const;

3496 17 is_same_direction 0 4 3672 31 LQuaternionf::is_same_direction 0 1 1769 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const;

3497 21 almost_same_direction 0 4 3672 35 LQuaternionf::almost_same_direction 0 1 1770 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
98
inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const;

3498 6 output 0 4 3672 20 LQuaternionf::output 0 1 1771 10
/**
 *
 */
55
inline void LQuaternionf::output(std::ostream &) const;

3499 17 extract_to_matrix 0 4 3672 31 LQuaternionf::extract_to_matrix 0 2 1772 1773 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaternionf::extract_to_matrix(LMatrix3f &m) const;
void LQuaternionf::extract_to_matrix(LMatrix4f &m) const;

3500 15 set_from_matrix 0 4 3672 29 LQuaternionf::set_from_matrix 0 2 1774 1775 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaternionf::set_from_matrix(LMatrix3f const &m);
inline void LQuaternionf::set_from_matrix(LMatrix4f const &m);

3501 7 set_hpr 0 4 3672 21 LQuaternionf::set_hpr 0 1 1776 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);

3502 7 get_hpr 0 4 3672 21 LQuaternionf::get_hpr 0 1 1777 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const;

3503 8 get_axis 0 4 3672 22 LQuaternionf::get_axis 0 1 1778 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3f LQuaternionf::get_axis(void) const;

3504 19 get_axis_normalized 0 4 3672 33 LQuaternionf::get_axis_normalized 0 1 1779 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3f LQuaternionf::get_axis_normalized(void) const;

3505 13 get_angle_rad 0 4 3672 27 LQuaternionf::get_angle_rad 0 1 1780 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
53
inline float LQuaternionf::get_angle_rad(void) const;

3506 9 get_angle 0 4 3672 23 LQuaternionf::get_angle 0 1 1781 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
49
inline float LQuaternionf::get_angle(void) const;

3507 23 set_from_axis_angle_rad 0 4 3672 37 LQuaternionf::set_from_axis_angle_rad 0 1 1782 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
90
inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis);

3508 19 set_from_axis_angle 0 4 3672 33 LQuaternionf::set_from_axis_angle 0 1 1783 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
86
inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis);

3509 6 get_up 0 4 3672 20 LQuaternionf::get_up 0 1 1784 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const;

3510 9 get_right 0 4 3672 23 LQuaternionf::get_right 0 1 1785 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const;

3511 11 get_forward 0 4 3672 25 LQuaternionf::get_forward 0 1 1786 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const;

3512 5 get_r 0 4 3672 19 LQuaternionf::get_r 0 1 1787 10
/**
 *
 */
45
inline float LQuaternionf::get_r(void) const;

3513 5 get_i 0 4 3672 19 LQuaternionf::get_i 0 1 1788 10
/**
 *
 */
45
inline float LQuaternionf::get_i(void) const;

3514 5 get_j 0 4 3672 19 LQuaternionf::get_j 0 1 1789 10
/**
 *
 */
45
inline float LQuaternionf::get_j(void) const;

3515 5 get_k 0 4 3672 19 LQuaternionf::get_k 0 1 1790 10
/**
 *
 */
45
inline float LQuaternionf::get_k(void) const;

3516 5 set_r 0 4 3672 19 LQuaternionf::set_r 0 1 1791 10
/**
 *
 */
41
inline void LQuaternionf::set_r(float r);

3517 5 set_i 0 4 3672 19 LQuaternionf::set_i 0 1 1792 10
/**
 *
 */
41
inline void LQuaternionf::set_i(float i);

3518 5 set_j 0 4 3672 19 LQuaternionf::set_j 0 1 1793 10
/**
 *
 */
41
inline void LQuaternionf::set_j(float j);

3519 5 set_k 0 4 3672 19 LQuaternionf::set_k 0 1 1794 10
/**
 *
 */
41
inline void LQuaternionf::set_k(float k);

3520 9 normalize 0 4 3672 23 LQuaternionf::normalize 0 1 1795 10
/**
 *
 */
42
inline bool LQuaternionf::normalize(void);

3521 14 conjugate_from 0 4 3672 28 LQuaternionf::conjugate_from 0 1 1796 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaternionf::conjugate_from(LQuaternionf const &other);

3522 18 conjugate_in_place 0 4 3672 32 LQuaternionf::conjugate_in_place 0 1 1797 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaternionf::conjugate_in_place(void);

3523 11 invert_from 0 4 3672 25 LQuaternionf::invert_from 0 1 1798 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaternionf::invert_from(LQuaternionf const &other);

3524 15 invert_in_place 0 4 3672 29 LQuaternionf::invert_in_place 0 1 1799 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaternionf::invert_in_place(void);

3525 11 is_identity 0 4 3672 25 LQuaternionf::is_identity 0 1 1800 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaternionf::is_identity(void) const;

3526 18 is_almost_identity 0 4 3672 32 LQuaternionf::is_almost_identity 0 1 1801 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
68
inline bool LQuaternionf::is_almost_identity(float tolerance) const;

3527 10 ident_quat 0 4 3672 24 LQuaternionf::ident_quat 0 1 1802 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaternionf const &LQuaternionf::ident_quat(void);

3528 14 get_class_type 0 4 3672 28 LQuaternionf::get_class_type 0 1 1803 0
53
static TypeHandle LQuaternionf::get_class_type(void);

3529 13 ~LQuaternionf 0 516 3672 27 LQuaternionf::~LQuaternionf 0 0 0
34
LQuaternionf::~LQuaternionf(void);

3530 12 LQuaterniond 0 260 3673 26 LQuaterniond::LQuaterniond 0 5 1804 1805 1806 1807 1808 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LQuaterniond::LQuaterniond(void);
inline LQuaterniond::LQuaterniond(LVecBase4d const &copy);
inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy);
inline LQuaterniond::LQuaterniond(double r, double i, double j, double k);
inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default;

3531 14 pure_imaginary 0 4 3673 28 LQuaterniond::pure_imaginary 0 1 1809 10
/**
 *
 */
69
static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v);

3532 9 conjugate 0 4 3673 23 LQuaterniond::conjugate 0 1 1810 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaterniond LQuaterniond::conjugate(void) const;

3533 5 xform 0 4 3673 19 LQuaterniond::xform 0 2 1811 1812 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const;
inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const;

3534 8 multiply 0 4 3673 22 LQuaterniond::multiply 0 1 1813 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const;

3535 10 operator - 0 68 3673 24 LQuaterniond::operator - 0 1 1814 0
57
inline LQuaterniond LQuaterniond::operator -(void) const;

3536 10 operator + 0 4 3673 24 LQuaterniond::operator + 0 1 1815 0
78
inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &other) const;

3537 10 operator - 0 4 3673 24 LQuaterniond::operator - 0 1 1816 0
78
inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &other) const;

3538 9 angle_rad 0 4 3673 23 LQuaterniond::angle_rad 0 1 1817 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
71
inline double LQuaterniond::angle_rad(LQuaterniond const &other) const;

3539 9 angle_deg 0 4 3673 23 LQuaterniond::angle_deg 0 1 1818 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
71
inline double LQuaterniond::angle_deg(LQuaterniond const &other) const;

3540 10 operator * 0 4 3673 24 LQuaterniond::operator * 0 4 1819 1820 1821 1822 0
264
inline LQuaterniond LQuaterniond::operator *(double scalar) const;
inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const;
inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &);
inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &);

3541 10 operator / 0 4 3673 24 LQuaterniond::operator / 0 1 1823 0
66
inline LQuaterniond LQuaterniond::operator /(double scalar) const;

3542 11 operator *= 0 4 3673 25 LQuaterniond::operator *= 0 1 1824 10
/**
 *
 */
69
inline LQuaterniond &LQuaterniond::operator *=(LQuaterniond const &);

3543 7 __pow__ 0 4 3673 21 LQuaterniond::__pow__ 0 1 1825 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
50
LQuaterniond LQuaterniond::__pow__(double ) const;

3544 12 almost_equal 0 4 3673 26 LQuaterniond::almost_equal 0 2 1826 1827 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
163
inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const;
inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const;

3545 17 is_same_direction 0 4 3673 31 LQuaterniond::is_same_direction 0 1 1828 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const;

3546 21 almost_same_direction 0 4 3673 35 LQuaterniond::almost_same_direction 0 1 1829 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
99
inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const;

3547 6 output 0 4 3673 20 LQuaterniond::output 0 1 1830 10
/**
 *
 */
55
inline void LQuaterniond::output(std::ostream &) const;

3548 17 extract_to_matrix 0 4 3673 31 LQuaterniond::extract_to_matrix 0 2 1831 1832 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaterniond::extract_to_matrix(LMatrix3d &m) const;
void LQuaterniond::extract_to_matrix(LMatrix4d &m) const;

3549 15 set_from_matrix 0 4 3673 29 LQuaterniond::set_from_matrix 0 2 1833 1834 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaterniond::set_from_matrix(LMatrix3d const &m);
inline void LQuaterniond::set_from_matrix(LMatrix4d const &m);

3550 7 set_hpr 0 4 3673 21 LQuaterniond::set_hpr 0 1 1835 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);

3551 7 get_hpr 0 4 3673 21 LQuaterniond::get_hpr 0 1 1836 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const;

3552 8 get_axis 0 4 3673 22 LQuaterniond::get_axis 0 1 1837 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3d LQuaterniond::get_axis(void) const;

3553 19 get_axis_normalized 0 4 3673 33 LQuaterniond::get_axis_normalized 0 1 1838 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3d LQuaterniond::get_axis_normalized(void) const;

3554 13 get_angle_rad 0 4 3673 27 LQuaterniond::get_angle_rad 0 1 1839 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
54
inline double LQuaterniond::get_angle_rad(void) const;

3555 9 get_angle 0 4 3673 23 LQuaterniond::get_angle 0 1 1840 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
50
inline double LQuaterniond::get_angle(void) const;

3556 23 set_from_axis_angle_rad 0 4 3673 37 LQuaterniond::set_from_axis_angle_rad 0 1 1841 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
91
inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis);

3557 19 set_from_axis_angle 0 4 3673 33 LQuaterniond::set_from_axis_angle 0 1 1842 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
87
inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis);

3558 6 get_up 0 4 3673 20 LQuaterniond::get_up 0 1 1843 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const;

3559 9 get_right 0 4 3673 23 LQuaterniond::get_right 0 1 1844 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const;

3560 11 get_forward 0 4 3673 25 LQuaterniond::get_forward 0 1 1845 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const;

3561 5 get_r 0 4 3673 19 LQuaterniond::get_r 0 1 1846 10
/**
 *
 */
46
inline double LQuaterniond::get_r(void) const;

3562 5 get_i 0 4 3673 19 LQuaterniond::get_i 0 1 1847 10
/**
 *
 */
46
inline double LQuaterniond::get_i(void) const;

3563 5 get_j 0 4 3673 19 LQuaterniond::get_j 0 1 1848 10
/**
 *
 */
46
inline double LQuaterniond::get_j(void) const;

3564 5 get_k 0 4 3673 19 LQuaterniond::get_k 0 1 1849 10
/**
 *
 */
46
inline double LQuaterniond::get_k(void) const;

3565 5 set_r 0 4 3673 19 LQuaterniond::set_r 0 1 1850 10
/**
 *
 */
42
inline void LQuaterniond::set_r(double r);

3566 5 set_i 0 4 3673 19 LQuaterniond::set_i 0 1 1851 10
/**
 *
 */
42
inline void LQuaterniond::set_i(double i);

3567 5 set_j 0 4 3673 19 LQuaterniond::set_j 0 1 1852 10
/**
 *
 */
42
inline void LQuaterniond::set_j(double j);

3568 5 set_k 0 4 3673 19 LQuaterniond::set_k 0 1 1853 10
/**
 *
 */
42
inline void LQuaterniond::set_k(double k);

3569 9 normalize 0 4 3673 23 LQuaterniond::normalize 0 1 1854 10
/**
 *
 */
42
inline bool LQuaterniond::normalize(void);

3570 14 conjugate_from 0 4 3673 28 LQuaterniond::conjugate_from 0 1 1855 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaterniond::conjugate_from(LQuaterniond const &other);

3571 18 conjugate_in_place 0 4 3673 32 LQuaterniond::conjugate_in_place 0 1 1856 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaterniond::conjugate_in_place(void);

3572 11 invert_from 0 4 3673 25 LQuaterniond::invert_from 0 1 1857 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaterniond::invert_from(LQuaterniond const &other);

3573 15 invert_in_place 0 4 3673 29 LQuaterniond::invert_in_place 0 1 1858 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaterniond::invert_in_place(void);

3574 11 is_identity 0 4 3673 25 LQuaterniond::is_identity 0 1 1859 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaterniond::is_identity(void) const;

3575 18 is_almost_identity 0 4 3673 32 LQuaterniond::is_almost_identity 0 1 1860 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
69
inline bool LQuaterniond::is_almost_identity(double tolerance) const;

3576 10 ident_quat 0 4 3673 24 LQuaterniond::ident_quat 0 1 1861 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaterniond const &LQuaterniond::ident_quat(void);

3577 14 get_class_type 0 4 3673 28 LQuaterniond::get_class_type 0 1 1862 0
53
static TypeHandle LQuaterniond::get_class_type(void);

3578 13 ~LQuaterniond 0 516 3673 27 LQuaterniond::~LQuaterniond 0 0 0
34
LQuaterniond::~LQuaterniond(void);

3579 10 LRotationf 0 260 3674 22 LRotationf::LRotationf 0 9 1863 1864 1865 1866 1867 1868 1869 1870 1871 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
500
inline LRotationf::LRotationf(void);
inline LRotationf::LRotationf(LQuaternionf const &c);
inline LRotationf::LRotationf(LVecBase4f const &copy);
inline LRotationf::LRotationf(float r, float i, float j, float k);
inline LRotationf::LRotationf(LVector3f const &axis, float angle);
inline LRotationf::LRotationf(LMatrix3f const &m);
inline LRotationf::LRotationf(LMatrix4f const &m);
inline LRotationf::LRotationf(float h, float p, float r);
inline LRotationf::LRotationf(LRotationf const &) = default;

3580 10 operator * 0 4 3674 22 LRotationf::operator * 0 3 1872 1873 1874 0
211
inline LRotationf LRotationf::operator *(float scalar) const;
inline LRotationf LRotationf::operator *(LRotationf const &other) const;
inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const;

3581 10 operator / 0 4 3674 22 LRotationf::operator / 0 1 1875 0
61
inline LRotationf LRotationf::operator /(float scalar) const;

3582 14 get_class_type 0 4 3674 26 LRotationf::get_class_type 0 1 1876 0
51
static TypeHandle LRotationf::get_class_type(void);

3583 11 ~LRotationf 0 516 3674 23 LRotationf::~LRotationf 0 0 0
30
LRotationf::~LRotationf(void);

3584 10 LRotationd 0 260 3675 22 LRotationd::LRotationd 0 9 1877 1878 1879 1880 1881 1882 1883 1884 1885 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
508
inline LRotationd::LRotationd(void);
inline LRotationd::LRotationd(LQuaterniond const &c);
inline LRotationd::LRotationd(LVecBase4d const &copy);
inline LRotationd::LRotationd(double r, double i, double j, double k);
inline LRotationd::LRotationd(LVector3d const &axis, double angle);
inline LRotationd::LRotationd(LMatrix3d const &m);
inline LRotationd::LRotationd(LMatrix4d const &m);
inline LRotationd::LRotationd(double h, double p, double r);
inline LRotationd::LRotationd(LRotationd const &) = default;

3585 10 operator * 0 4 3675 22 LRotationd::operator * 0 3 1886 1887 1888 0
212
inline LRotationd LRotationd::operator *(double scalar) const;
inline LRotationd LRotationd::operator *(LRotationd const &other) const;
inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const;

3586 10 operator / 0 4 3675 22 LRotationd::operator / 0 1 1889 0
62
inline LRotationd LRotationd::operator /(double scalar) const;

3587 14 get_class_type 0 4 3675 26 LRotationd::get_class_type 0 1 1890 0
51
static TypeHandle LRotationd::get_class_type(void);

3588 11 ~LRotationd 0 516 3675 23 LRotationd::~LRotationd 0 0 0
30
LRotationd::~LRotationd(void);

3589 13 LOrientationf 0 260 3676 28 LOrientationf::LOrientationf 0 7 1891 1892 1893 1894 1895 1896 1897 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
436
inline LOrientationf::LOrientationf(void);
inline LOrientationf::LOrientationf(LQuaternionf const &c);
inline LOrientationf::LOrientationf(float r, float i, float j, float k);
inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist);
inline LOrientationf::LOrientationf(LMatrix3f const &m);
inline LOrientationf::LOrientationf(LMatrix4f const &m);
inline LOrientationf::LOrientationf(LOrientationf const &) = default;

3590 10 operator * 0 4 3676 25 LOrientationf::operator * 0 2 1898 1899 0
159
inline LOrientationf LOrientationf::operator *(LRotationf const &other) const;
inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const;

3591 14 get_class_type 0 4 3676 29 LOrientationf::get_class_type 0 1 1900 0
54
static TypeHandle LOrientationf::get_class_type(void);

3592 14 ~LOrientationf 0 516 3676 29 LOrientationf::~LOrientationf 0 0 0
36
LOrientationf::~LOrientationf(void);

3593 13 LOrientationd 0 260 3677 28 LOrientationd::LOrientationd 0 7 1901 1902 1903 1904 1905 1906 1907 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
441
inline LOrientationd::LOrientationd(void);
inline LOrientationd::LOrientationd(LQuaterniond const &c);
inline LOrientationd::LOrientationd(double r, double i, double j, double k);
inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist);
inline LOrientationd::LOrientationd(LMatrix3d const &m);
inline LOrientationd::LOrientationd(LMatrix4d const &m);
inline LOrientationd::LOrientationd(LOrientationd const &) = default;

3594 10 operator * 0 4 3677 25 LOrientationd::operator * 0 2 1908 1909 0
159
inline LOrientationd LOrientationd::operator *(LRotationd const &other) const;
inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const;

3595 14 get_class_type 0 4 3677 29 LOrientationd::get_class_type 0 1 1910 0
54
static TypeHandle LOrientationd::get_class_type(void);

3596 14 ~LOrientationd 0 516 3677 29 LOrientationd::~LOrientationd 0 0 0
36
LOrientationd::~LOrientationd(void);

3597 19 ConfigVariableColor 0 260 3748 40 ConfigVariableColor::ConfigVariableColor 0 4 1911 1912 1913 1914 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
488
inline ConfigVariableColor::ConfigVariableColor(std::string const &name);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default;

3598 10 operator = 0 4 3748 31 ConfigVariableColor::operator = 0 1 1915 0
65
inline void ConfigVariableColor::operator =(LColor const &value);

3599 17 operator typecast 0 132 3748 38 ConfigVariableColor::operator typecast 0 1 1920 0
43
inline operator LColor const &(void) const;

3600 11 operator [] 0 4 3748 32 ConfigVariableColor::operator [] 0 1 1916 0
65
inline PN_stdfloat ConfigVariableColor::operator [](int n) const;

3601 9 set_value 0 4 3748 30 ConfigVariableColor::set_value 0 1 1917 48
/**
 * Reassigns the variable's local value.
 */
64
inline void ConfigVariableColor::set_value(LColor const &value);

3602 9 get_value 0 4 3748 30 ConfigVariableColor::get_value 0 1 1918 40
/**
 * Returns the variable's value.
 */
64
inline LColor const &ConfigVariableColor::get_value(void) const;

3603 17 get_default_value 0 4 3748 38 ConfigVariableColor::get_default_value 0 1 1919 48
/**
 * Returns the variable's default value.
 */
65
inline LColor ConfigVariableColor::get_default_value(void) const;

3604 20 ~ConfigVariableColor 0 516 3748 41 ConfigVariableColor::~ConfigVariableColor 0 0 0
48
ConfigVariableColor::~ConfigVariableColor(void);

2010
1 0 0 7 2 3750 2012 0 0 0 
2 0 0 15 2 3750 2012 0 0 1 6 param0 0 3751  
3 0 0 7 8 3753 2082 0 0 0 
4 0 0 15 8 3753 2082 0 0 1 6 param0 0 3754  
5 0 0 23 8 3753 2082 0 10 /**
 *
 */ 1 10 fill_value 1 3608  
6 0 0 23 8 3753 2082 0 10 /**
 *
 */ 2 1 x 1 3608  1 y 1 3608  
7 0 0 4 9 3758 0 0 0 2 4 this 3 3753  4 size 1 3756  
8 0 0 6 12 3753 0 0 0 2 4 this 3 3753  4 copy 1 3754  
9 0 0 6 12 3753 0 0 0 2 4 this 3 3753  10 fill_value 1 3608  
10 0 0 6 13 3754 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
11 0 0 6 14 3754 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
12 0 0 6 15 3754 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
13 0 0 38 16 3759 0 0 0 1 4 this 3 3754  
14 0 0 38 17 3759 0 0 0 2 4 this 3 3754  9 attr_name 1 3762  
15 0 0 38 18 3614 0 0 0 3 4 this 3 3753  9 attr_name 1 3762  6 assign 1 3759  
16 0 0 4 19 3758 0 0 10 /**
 *
 */ 3 4 this 3 3753  1 i 1 3614  10 assign_val 1 3608  
17 0 0 6 19 3608 0 0 0 2 4 this 3 3754  1 i 1 3614  
18 0 0 6 20 3614 0 0 0 0 
19 0 0 6 21 3763 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3754  
20 0 0 6 22 3608 0 0 10 /**
 *
 */ 2 4 this 3 3754  1 i 1 3614  
21 0 0 4 23 3758 0 0 10 /**
 *
 */ 3 4 this 3 3753  1 i 1 3614  5 value 1 3608  
22 0 0 6 24 3608 0 0 10 /**
 *
 */ 1 4 this 3 3754  
23 0 0 6 25 3608 0 0 10 /**
 *
 */ 1 4 this 3 3754  
24 0 0 4 26 3758 0 0 10 /**
 *
 */ 2 4 this 3 3753  5 value 1 3608  
25 0 0 4 27 3758 0 0 10 /**
 *
 */ 2 4 this 3 3753  5 value 1 3608  
26 0 0 4 31 3758 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3753  1 i 1 3614  5 value 1 3608  
27 0 0 4 32 3758 0 0 10 /**
 *
 */ 2 4 this 3 3753  5 value 1 3608  
28 0 0 4 33 3758 0 0 10 /**
 *
 */ 2 4 this 3 3753  5 value 1 3608  
29 0 0 4 34 3758 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3754  
30 0 0 6 35 3614 0 0 0 0 
31 0 0 4 36 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3753  10 fill_value 1 3608  
32 0 0 4 37 3758 0 0 10 /**
 *
 */ 3 4 this 3 3753  1 x 1 3608  1 y 1 3608  
33 0 0 6 38 3608 0 0 10 /**
 *
 */ 2 4 this 3 3754  5 other 1 3754  
34 0 0 6 39 3608 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3754  
35 0 0 6 40 3608 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3754  
36 0 0 6 41 3763 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3753  
37 0 0 7 42 3753 2082 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3754  
38 0 0 7 43 3753 2082 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3754  4 onto 1 3754  
39 0 0 6 44 3763 0 0 0 2 4 this 3 3754  5 other 1 3754  
40 0 0 6 45 3763 0 0 0 2 4 this 3 3754  5 other 1 3754  
41 0 0 6 46 3763 0 0 0 2 4 this 3 3754  5 other 1 3754  
42 0 0 6 47 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3754  5 other 1 3754  
43 0 0 6 47 3614 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3754  5 other 1 3754  9 threshold 1 3608  
44 0 0 6 48 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3754  
45 0 0 6 48 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3754  9 threshold 1 3608  
46 0 0 6 49 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3754  4 hash 1 3756  
47 0 0 6 49 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3754  4 hash 1 3756  9 threshold 1 3608  
48 0 0 4 50 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3754  7 hashgen 1 3764  
49 0 0 4 50 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3754  7 hashgen 1 3764  9 threshold 1 3608  
50 0 0 7 51 3753 2082 0 0 1 4 this 3 3754  
51 0 0 7 52 3753 2082 0 0 2 4 this 3 3754  5 other 1 3754  
52 0 0 7 53 3753 2082 0 0 2 4 this 3 3754  5 other 1 3754  
53 0 0 7 54 3753 2082 0 0 2 4 this 3 3754  6 scalar 1 3608  
54 0 0 7 55 3753 2082 0 0 2 4 this 3 3754  6 scalar 1 3608  
55 0 0 6 56 3753 0 0 0 2 4 this 3 3753  5 other 1 3754  
56 0 0 6 57 3753 0 0 0 2 4 this 3 3753  5 other 1 3754  
57 0 0 6 58 3753 0 0 0 2 4 this 3 3753  6 scalar 1 3608  
58 0 0 6 59 3753 0 0 0 2 4 this 3 3753  6 scalar 1 3608  
59 0 0 4 60 3758 0 0 10 /**
 *
 */ 2 4 this 3 3753  5 other 1 3754  
60 0 0 38 61 3759 0 0 0 2 4 this 3 3754  6 scalar 1 3608  
61 0 0 38 62 3759 0 0 0 2 4 this 3 3753  6 scalar 1 3608  
62 0 0 38 63 3759 0 0 0 2 4 this 3 3754  8 exponent 1 3608  
63 0 0 38 64 3759 0 0 0 2 4 this 3 3753  8 exponent 1 3608  
64 0 0 38 65 3759 0 0 0 1 4 this 3 3753  
65 0 0 38 66 3759 0 0 0 1 4 this 3 3753  
66 0 0 38 67 3759 0 0 0 1 4 this 3 3753  
67 0 0 7 68 3753 2082 0 10 /**
 *
 */ 2 4 this 3 3754  5 other 1 3754  
68 0 0 7 69 3753 2082 0 10 /**
 *
 */ 2 4 this 3 3754  5 other 1 3754  
69 0 0 6 70 3763 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3754  5 other 1 3754  
70 0 0 6 70 3763 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3754  5 other 1 3754  9 threshold 1 3608  
71 0 0 4 71 3758 0 0 10 /**
 *
 */ 2 4 this 3 3754  3 out 1 3766  
72 0 0 38 72 3762 0 0 0 1 4 this 3 3754  
73 0 0 4 73 3758 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3754  11 destination 1 3768  
74 0 0 4 74 3758 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3753  6 source 1 3770  
75 0 0 4 75 3758 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3754  11 destination 1 3768  
76 0 0 4 76 3758 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3753  6 source 1 3770  
77 0 0 7 77 3773 0 0 0 0 
78 0 0 7 81 3774 2150 0 0 0 
79 0 0 15 81 3774 2150 0 0 1 6 param0 0 3775  
80 0 0 23 81 3774 2150 0 10 /**
 *
 */ 1 10 fill_value 1 3611  
81 0 0 23 81 3774 2150 0 10 /**
 *
 */ 2 1 x 1 3611  1 y 1 3611  
82 0 0 4 82 3758 0 0 0 2 4 this 3 3774  4 size 1 3756  
83 0 0 6 85 3774 0 0 0 2 4 this 3 3774  4 copy 1 3775  
84 0 0 6 85 3774 0 0 0 2 4 this 3 3774  10 fill_value 1 3611  
85 0 0 6 86 3775 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
86 0 0 6 87 3775 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
87 0 0 6 88 3775 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
88 0 0 38 89 3759 0 0 0 1 4 this 3 3775  
89 0 0 38 90 3759 0 0 0 2 4 this 3 3775  9 attr_name 1 3762  
90 0 0 38 91 3614 0 0 0 3 4 this 3 3774  9 attr_name 1 3762  6 assign 1 3759  
91 0 0 4 92 3758 0 0 10 /**
 *
 */ 3 4 this 3 3774  1 i 1 3614  10 assign_val 1 3611  
92 0 0 6 92 3611 0 0 0 2 4 this 3 3775  1 i 1 3614  
93 0 0 6 93 3614 0 0 0 0 
94 0 0 6 94 3763 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3775  
95 0 0 6 95 3611 0 0 10 /**
 *
 */ 2 4 this 3 3775  1 i 1 3614  
96 0 0 4 96 3758 0 0 10 /**
 *
 */ 3 4 this 3 3774  1 i 1 3614  5 value 1 3611  
97 0 0 6 97 3611 0 0 10 /**
 *
 */ 1 4 this 3 3775  
98 0 0 6 98 3611 0 0 10 /**
 *
 */ 1 4 this 3 3775  
99 0 0 4 99 3758 0 0 10 /**
 *
 */ 2 4 this 3 3774  5 value 1 3611  
100 0 0 4 100 3758 0 0 10 /**
 *
 */ 2 4 this 3 3774  5 value 1 3611  
101 0 0 4 104 3758 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3774  1 i 1 3614  5 value 1 3611  
102 0 0 4 105 3758 0 0 10 /**
 *
 */ 2 4 this 3 3774  5 value 1 3611  
103 0 0 4 106 3758 0 0 10 /**
 *
 */ 2 4 this 3 3774  5 value 1 3611  
104 0 0 4 107 3758 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3775  
105 0 0 6 108 3614 0 0 0 0 
106 0 0 4 109 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3774  10 fill_value 1 3611  
107 0 0 4 110 3758 0 0 10 /**
 *
 */ 3 4 this 3 3774  1 x 1 3611  1 y 1 3611  
108 0 0 6 111 3611 0 0 10 /**
 *
 */ 2 4 this 3 3775  5 other 1 3775  
109 0 0 6 112 3611 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3775  
110 0 0 6 113 3611 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3775  
111 0 0 6 114 3763 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3774  
112 0 0 7 115 3774 2150 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3775  
113 0 0 7 116 3774 2150 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3775  4 onto 1 3775  
114 0 0 6 117 3763 0 0 0 2 4 this 3 3775  5 other 1 3775  
115 0 0 6 118 3763 0 0 0 2 4 this 3 3775  5 other 1 3775  
116 0 0 6 119 3763 0 0 0 2 4 this 3 3775  5 other 1 3775  
117 0 0 6 120 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3775  5 other 1 3775  
118 0 0 6 120 3614 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3775  5 other 1 3775  9 threshold 1 3611  
119 0 0 6 121 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3775  
120 0 0 6 121 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3775  9 threshold 1 3611  
121 0 0 6 122 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3775  4 hash 1 3756  
122 0 0 6 122 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3775  4 hash 1 3756  9 threshold 1 3611  
123 0 0 4 123 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3775  7 hashgen 1 3764  
124 0 0 4 123 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3775  7 hashgen 1 3764  9 threshold 1 3611  
125 0 0 7 124 3774 2150 0 0 1 4 this 3 3775  
126 0 0 7 125 3774 2150 0 0 2 4 this 3 3775  5 other 1 3775  
127 0 0 7 126 3774 2150 0 0 2 4 this 3 3775  5 other 1 3775  
128 0 0 7 127 3774 2150 0 0 2 4 this 3 3775  6 scalar 1 3611  
129 0 0 7 128 3774 2150 0 0 2 4 this 3 3775  6 scalar 1 3611  
130 0 0 6 129 3774 0 0 0 2 4 this 3 3774  5 other 1 3775  
131 0 0 6 130 3774 0 0 0 2 4 this 3 3774  5 other 1 3775  
132 0 0 6 131 3774 0 0 0 2 4 this 3 3774  6 scalar 1 3611  
133 0 0 6 132 3774 0 0 0 2 4 this 3 3774  6 scalar 1 3611  
134 0 0 4 133 3758 0 0 10 /**
 *
 */ 2 4 this 3 3774  5 other 1 3775  
135 0 0 38 134 3759 0 0 0 2 4 this 3 3775  6 scalar 1 3611  
136 0 0 38 135 3759 0 0 0 2 4 this 3 3774  6 scalar 1 3611  
137 0 0 38 136 3759 0 0 0 2 4 this 3 3775  8 exponent 1 3611  
138 0 0 38 137 3759 0 0 0 2 4 this 3 3774  8 exponent 1 3611  
139 0 0 38 138 3759 0 0 0 1 4 this 3 3774  
140 0 0 38 139 3759 0 0 0 1 4 this 3 3774  
141 0 0 38 140 3759 0 0 0 1 4 this 3 3774  
142 0 0 7 141 3774 2150 0 10 /**
 *
 */ 2 4 this 3 3775  5 other 1 3775  
143 0 0 7 142 3774 2150 0 10 /**
 *
 */ 2 4 this 3 3775  5 other 1 3775  
144 0 0 6 143 3763 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3775  5 other 1 3775  
145 0 0 6 143 3763 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3775  5 other 1 3775  9 threshold 1 3611  
146 0 0 4 144 3758 0 0 10 /**
 *
 */ 2 4 this 3 3775  3 out 1 3766  
147 0 0 38 145 3762 0 0 0 1 4 this 3 3775  
148 0 0 4 146 3758 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3775  11 destination 1 3768  
149 0 0 4 147 3758 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3774  6 source 1 3770  
150 0 0 4 148 3758 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3775  11 destination 1 3768  
151 0 0 4 149 3758 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3774  6 source 1 3770  
152 0 0 7 150 3773 0 0 0 0 
153 0 0 7 154 3777 2214 0 0 0 
154 0 0 15 154 3777 2214 0 0 1 6 param0 0 3778  
155 0 0 23 154 3777 2214 0 10 /**
 *
 */ 1 10 fill_value 1 3614  
156 0 0 23 154 3777 2214 0 10 /**
 *
 */ 2 1 x 1 3614  1 y 1 3614  
157 0 0 4 155 3758 0 0 0 2 4 this 3 3777  4 size 1 3756  
158 0 0 6 158 3777 0 0 0 2 4 this 3 3777  4 copy 1 3778  
159 0 0 6 158 3777 0 0 0 2 4 this 3 3777  10 fill_value 1 3614  
160 0 0 6 159 3778 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
161 0 0 6 160 3778 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
162 0 0 6 161 3778 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
163 0 0 38 162 3759 0 0 0 1 4 this 3 3778  
164 0 0 38 163 3759 0 0 0 2 4 this 3 3778  9 attr_name 1 3762  
165 0 0 38 164 3614 0 0 0 3 4 this 3 3777  9 attr_name 1 3762  6 assign 1 3759  
166 0 0 4 165 3758 0 0 10 /**
 *
 */ 3 4 this 3 3777  1 i 1 3614  10 assign_val 1 3614  
167 0 0 6 165 3614 0 0 0 2 4 this 3 3778  1 i 1 3614  
168 0 0 6 166 3614 0 0 0 0 
169 0 0 6 167 3763 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3778  
170 0 0 6 168 3614 0 0 10 /**
 *
 */ 2 4 this 3 3778  1 i 1 3614  
171 0 0 4 169 3758 0 0 10 /**
 *
 */ 3 4 this 3 3777  1 i 1 3614  5 value 1 3614  
172 0 0 6 170 3614 0 0 10 /**
 *
 */ 1 4 this 3 3778  
173 0 0 6 171 3614 0 0 10 /**
 *
 */ 1 4 this 3 3778  
174 0 0 4 172 3758 0 0 10 /**
 *
 */ 2 4 this 3 3777  5 value 1 3614  
175 0 0 4 173 3758 0 0 10 /**
 *
 */ 2 4 this 3 3777  5 value 1 3614  
176 0 0 4 177 3758 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3777  1 i 1 3614  5 value 1 3614  
177 0 0 4 178 3758 0 0 10 /**
 *
 */ 2 4 this 3 3777  5 value 1 3614  
178 0 0 4 179 3758 0 0 10 /**
 *
 */ 2 4 this 3 3777  5 value 1 3614  
179 0 0 4 180 3758 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3778  
180 0 0 6 181 3614 0 0 0 0 
181 0 0 4 182 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3777  10 fill_value 1 3614  
182 0 0 4 183 3758 0 0 10 /**
 *
 */ 3 4 this 3 3777  1 x 1 3614  1 y 1 3614  
183 0 0 6 184 3614 0 0 10 /**
 *
 */ 2 4 this 3 3778  5 other 1 3778  
184 0 0 6 185 3614 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3778  
185 0 0 6 186 3763 0 0 0 2 4 this 3 3778  5 other 1 3778  
186 0 0 6 187 3763 0 0 0 2 4 this 3 3778  5 other 1 3778  
187 0 0 6 188 3763 0 0 0 2 4 this 3 3778  5 other 1 3778  
188 0 0 6 189 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3778  5 other 1 3778  
189 0 0 6 190 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3778  
190 0 0 6 191 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3778  4 hash 1 3756  
191 0 0 4 192 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3778  7 hashgen 1 3764  
192 0 0 7 193 3777 2214 0 0 1 4 this 3 3778  
193 0 0 7 194 3777 2214 0 0 2 4 this 3 3778  5 other 1 3778  
194 0 0 7 195 3777 2214 0 0 2 4 this 3 3778  5 other 1 3778  
195 0 0 7 196 3777 2214 0 0 2 4 this 3 3778  6 scalar 1 3614  
196 0 0 7 197 3777 2214 0 0 2 4 this 3 3778  6 scalar 1 3614  
197 0 0 6 198 3777 0 0 0 2 4 this 3 3777  5 other 1 3778  
198 0 0 6 199 3777 0 0 0 2 4 this 3 3777  5 other 1 3778  
199 0 0 6 200 3777 0 0 0 2 4 this 3 3777  6 scalar 1 3614  
200 0 0 6 201 3777 0 0 0 2 4 this 3 3777  6 scalar 1 3614  
201 0 0 4 202 3758 0 0 10 /**
 *
 */ 2 4 this 3 3777  5 other 1 3778  
202 0 0 38 203 3759 0 0 0 2 4 this 3 3778  6 scalar 1 3614  
203 0 0 38 204 3759 0 0 0 2 4 this 3 3777  6 scalar 1 3614  
204 0 0 38 205 3759 0 0 0 2 4 this 3 3778  8 exponent 1 3614  
205 0 0 38 206 3759 0 0 0 2 4 this 3 3777  8 exponent 1 3614  
206 0 0 38 207 3759 0 0 0 1 4 this 3 3777  
207 0 0 38 208 3759 0 0 0 1 4 this 3 3777  
208 0 0 38 209 3759 0 0 0 1 4 this 3 3777  
209 0 0 7 210 3777 2214 0 10 /**
 *
 */ 2 4 this 3 3778  5 other 1 3778  
210 0 0 7 211 3777 2214 0 10 /**
 *
 */ 2 4 this 3 3778  5 other 1 3778  
211 0 0 6 212 3763 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3778  5 other 1 3778  
212 0 0 6 212 3763 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3778  5 other 1 3778  9 threshold 1 3614  
213 0 0 4 213 3758 0 0 10 /**
 *
 */ 2 4 this 3 3778  3 out 1 3766  
214 0 0 38 214 3762 0 0 0 1 4 this 3 3778  
215 0 0 4 215 3758 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3778  11 destination 1 3768  
216 0 0 4 216 3758 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3777  6 source 1 3770  
217 0 0 4 217 3758 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3778  11 destination 1 3768  
218 0 0 4 218 3758 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3777  6 source 1 3770  
219 0 0 7 219 3773 0 0 0 0 
220 0 0 7 222 3780 2232 0 0 0 
221 0 0 23 222 3780 2232 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3754  
222 0 0 15 222 3780 2232 0 0 1 6 param0 0 3781  
223 0 0 23 222 3780 2232 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3608  
224 0 0 23 222 3780 2232 0 10 /**
 *
 */ 2 1 x 1 3608  1 y 1 3608  
225 0 0 38 223 3759 0 0 0 2 4 this 3 3781  9 attr_name 1 3762  
226 0 0 38 224 3614 0 0 0 3 4 this 3 3780  9 attr_name 1 3762  6 assign 1 3759  
227 0 0 6 225 3781 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
228 0 0 6 226 3781 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
229 0 0 6 227 3781 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
230 0 0 7 228 3780 2232 0 0 1 4 this 3 3781  
231 0 0 7 229 3753 2082 0 0 2 4 this 3 3781  5 other 1 3754  
232 0 0 7 229 3780 2232 0 0 2 4 this 3 3781  5 other 1 3781  
233 0 0 7 230 3753 2082 0 0 2 4 this 3 3781  5 other 1 3754  
234 0 0 7 230 3780 2232 0 0 2 4 this 3 3781  5 other 1 3781  
235 0 0 7 231 3780 2232 0 0 2 4 this 3 3781  6 scalar 1 3608  
236 0 0 7 232 3780 2232 0 0 2 4 this 3 3781  6 scalar 1 3608  
237 0 0 7 233 3780 2232 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3781  
238 0 0 7 234 3780 2232 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3781  4 onto 1 3754  
239 0 0 6 235 3608 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3781  5 other 1 3781  
240 0 0 6 236 3608 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3781  5 other 1 3781  
241 0 0 38 237 3762 0 0 0 1 4 this 3 3781  
242 0 0 7 238 3773 0 0 0 0 
243 0 0 7 241 3783 2250 0 0 0 
244 0 0 23 241 3783 2250 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3775  
245 0 0 15 241 3783 2250 0 0 1 6 param0 0 3784  
246 0 0 23 241 3783 2250 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3611  
247 0 0 23 241 3783 2250 0 10 /**
 *
 */ 2 1 x 1 3611  1 y 1 3611  
248 0 0 38 242 3759 0 0 0 2 4 this 3 3784  9 attr_name 1 3762  
249 0 0 38 243 3614 0 0 0 3 4 this 3 3783  9 attr_name 1 3762  6 assign 1 3759  
250 0 0 6 244 3784 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
251 0 0 6 245 3784 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
252 0 0 6 246 3784 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
253 0 0 7 247 3783 2250 0 0 1 4 this 3 3784  
254 0 0 7 248 3774 2150 0 0 2 4 this 3 3784  5 other 1 3775  
255 0 0 7 248 3783 2250 0 0 2 4 this 3 3784  5 other 1 3784  
256 0 0 7 249 3774 2150 0 0 2 4 this 3 3784  5 other 1 3775  
257 0 0 7 249 3783 2250 0 0 2 4 this 3 3784  5 other 1 3784  
258 0 0 7 250 3783 2250 0 0 2 4 this 3 3784  6 scalar 1 3611  
259 0 0 7 251 3783 2250 0 0 2 4 this 3 3784  6 scalar 1 3611  
260 0 0 7 252 3783 2250 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3784  
261 0 0 7 253 3783 2250 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3784  4 onto 1 3775  
262 0 0 6 254 3611 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3784  5 other 1 3784  
263 0 0 6 255 3611 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3784  5 other 1 3784  
264 0 0 38 256 3762 0 0 0 1 4 this 3 3784  
265 0 0 7 257 3773 0 0 0 0 
266 0 0 7 260 3786 2264 0 0 0 
267 0 0 23 260 3786 2264 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3778  
268 0 0 15 260 3786 2264 0 0 1 6 param0 0 3787  
269 0 0 23 260 3786 2264 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3614  
270 0 0 23 260 3786 2264 0 10 /**
 *
 */ 2 1 x 1 3614  1 y 1 3614  
271 0 0 38 261 3759 0 0 0 2 4 this 3 3787  9 attr_name 1 3762  
272 0 0 38 262 3614 0 0 0 3 4 this 3 3786  9 attr_name 1 3762  6 assign 1 3759  
273 0 0 6 263 3787 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
274 0 0 6 264 3787 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
275 0 0 6 265 3787 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
276 0 0 7 266 3786 2264 0 0 1 4 this 3 3787  
277 0 0 7 267 3777 2214 0 0 2 4 this 3 3787  5 other 1 3778  
278 0 0 7 267 3786 2264 0 0 2 4 this 3 3787  5 other 1 3787  
279 0 0 7 268 3777 2214 0 0 2 4 this 3 3787  5 other 1 3778  
280 0 0 7 268 3786 2264 0 0 2 4 this 3 3787  5 other 1 3787  
281 0 0 7 269 3786 2264 0 0 2 4 this 3 3787  6 scalar 1 3614  
282 0 0 7 270 3786 2264 0 0 2 4 this 3 3787  6 scalar 1 3614  
283 0 0 38 271 3762 0 0 0 1 4 this 3 3787  
284 0 0 7 272 3773 0 0 0 0 
285 0 0 7 275 3789 2280 0 0 0 
286 0 0 15 275 3789 2280 0 0 1 6 param0 0 3790  
287 0 0 23 275 3789 2280 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3754  
288 0 0 23 275 3789 2280 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3608  
289 0 0 23 275 3789 2280 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3608  1 y 1 3608  
290 0 0 38 276 3759 0 0 0 2 4 this 3 3790  9 attr_name 1 3762  
291 0 0 38 277 3614 0 0 0 3 4 this 3 3789  9 attr_name 1 3762  6 assign 1 3759  
292 0 0 6 278 3790 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
293 0 0 6 279 3790 0 0 34 /**
 * Returns a unit X point.
 */ 0 
294 0 0 6 280 3790 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
295 0 0 7 281 3789 2280 0 0 1 4 this 3 3790  
296 0 0 7 282 3753 2082 0 0 2 4 this 3 3790  5 other 1 3754  
297 0 0 7 282 3789 2280 0 0 2 4 this 3 3790  5 other 1 3781  
298 0 0 7 283 3780 2232 0 0 2 4 this 3 3790  5 other 1 3790  
299 0 0 7 283 3753 2082 0 0 2 4 this 3 3790  5 other 1 3754  
300 0 0 7 283 3789 2280 0 0 2 4 this 3 3790  5 other 1 3781  
301 0 0 7 284 3789 2280 0 0 2 4 this 3 3790  6 scalar 1 3608  
302 0 0 7 285 3789 2280 0 0 2 4 this 3 3790  6 scalar 1 3608  
303 0 0 7 286 3789 2280 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3790  
304 0 0 7 287 3789 2280 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3790  4 onto 1 3754  
305 0 0 38 288 3762 0 0 0 1 4 this 3 3790  
306 0 0 7 289 3773 0 0 0 0 
307 0 0 7 292 3792 2296 0 0 0 
308 0 0 15 292 3792 2296 0 0 1 6 param0 0 3793  
309 0 0 23 292 3792 2296 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3775  
310 0 0 23 292 3792 2296 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3611  
311 0 0 23 292 3792 2296 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3611  1 y 1 3611  
312 0 0 38 293 3759 0 0 0 2 4 this 3 3793  9 attr_name 1 3762  
313 0 0 38 294 3614 0 0 0 3 4 this 3 3792  9 attr_name 1 3762  6 assign 1 3759  
314 0 0 6 295 3793 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
315 0 0 6 296 3793 0 0 34 /**
 * Returns a unit X point.
 */ 0 
316 0 0 6 297 3793 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
317 0 0 7 298 3792 2296 0 0 1 4 this 3 3793  
318 0 0 7 299 3774 2150 0 0 2 4 this 3 3793  5 other 1 3775  
319 0 0 7 299 3792 2296 0 0 2 4 this 3 3793  5 other 1 3784  
320 0 0 7 300 3783 2250 0 0 2 4 this 3 3793  5 other 1 3793  
321 0 0 7 300 3774 2150 0 0 2 4 this 3 3793  5 other 1 3775  
322 0 0 7 300 3792 2296 0 0 2 4 this 3 3793  5 other 1 3784  
323 0 0 7 301 3792 2296 0 0 2 4 this 3 3793  6 scalar 1 3611  
324 0 0 7 302 3792 2296 0 0 2 4 this 3 3793  6 scalar 1 3611  
325 0 0 7 303 3792 2296 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3793  
326 0 0 7 304 3792 2296 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3793  4 onto 1 3775  
327 0 0 38 305 3762 0 0 0 1 4 this 3 3793  
328 0 0 7 306 3773 0 0 0 0 
329 0 0 7 309 3795 2310 0 0 0 
330 0 0 15 309 3795 2310 0 0 1 6 param0 0 3796  
331 0 0 23 309 3795 2310 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3778  
332 0 0 23 309 3795 2310 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3614  
333 0 0 23 309 3795 2310 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3614  1 y 1 3614  
334 0 0 38 310 3759 0 0 0 2 4 this 3 3796  9 attr_name 1 3762  
335 0 0 38 311 3614 0 0 0 3 4 this 3 3795  9 attr_name 1 3762  6 assign 1 3759  
336 0 0 6 312 3796 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
337 0 0 6 313 3796 0 0 34 /**
 * Returns a unit X point.
 */ 0 
338 0 0 6 314 3796 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
339 0 0 7 315 3795 2310 0 0 1 4 this 3 3796  
340 0 0 7 316 3777 2214 0 0 2 4 this 3 3796  5 other 1 3778  
341 0 0 7 316 3795 2310 0 0 2 4 this 3 3796  5 other 1 3787  
342 0 0 7 317 3786 2264 0 0 2 4 this 3 3796  5 other 1 3796  
343 0 0 7 317 3777 2214 0 0 2 4 this 3 3796  5 other 1 3778  
344 0 0 7 317 3795 2310 0 0 2 4 this 3 3796  5 other 1 3787  
345 0 0 7 318 3795 2310 0 0 2 4 this 3 3796  6 scalar 1 3614  
346 0 0 7 319 3795 2310 0 0 2 4 this 3 3796  6 scalar 1 3614  
347 0 0 38 320 3762 0 0 0 1 4 this 3 3796  
348 0 0 7 321 3773 0 0 0 0 
349 0 0 7 325 3798 2388 0 0 0 
350 0 0 23 325 3798 2388 0 10 /**
 *
 */ 2 4 copy 1 3754  1 z 1 3608  
351 0 0 15 325 3798 2388 0 0 1 6 param0 0 3799  
352 0 0 23 325 3798 2388 0 10 /**
 *
 */ 1 10 fill_value 1 3608  
353 0 0 23 325 3798 2388 0 10 /**
 *
 */ 3 1 x 1 3608  1 y 1 3608  1 z 1 3608  
354 0 0 4 326 3758 0 0 0 2 4 this 3 3798  4 size 1 3756  
355 0 0 6 329 3798 0 0 0 2 4 this 3 3798  4 copy 1 3799  
356 0 0 6 329 3798 0 0 0 2 4 this 3 3798  10 fill_value 1 3608  
357 0 0 6 330 3799 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
358 0 0 6 331 3799 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
359 0 0 6 332 3799 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
360 0 0 6 333 3799 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
361 0 0 38 334 3759 0 0 0 1 4 this 3 3799  
362 0 0 38 335 3759 0 0 0 2 4 this 3 3799  9 attr_name 1 3762  
363 0 0 38 336 3614 0 0 0 3 4 this 3 3798  9 attr_name 1 3762  6 assign 1 3759  
364 0 0 4 337 3758 0 0 10 /**
 *
 */ 3 4 this 3 3798  1 i 1 3614  10 assign_val 1 3608  
365 0 0 6 337 3608 0 0 0 2 4 this 3 3799  1 i 1 3614  
366 0 0 6 338 3614 0 0 0 0 
367 0 0 6 339 3763 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3799  
368 0 0 6 340 3608 0 0 10 /**
 *
 */ 2 4 this 3 3799  1 i 1 3614  
369 0 0 6 341 3608 0 0 10 /**
 *
 */ 1 4 this 3 3799  
370 0 0 6 342 3608 0 0 10 /**
 *
 */ 1 4 this 3 3799  
371 0 0 6 343 3608 0 0 10 /**
 *
 */ 1 4 this 3 3799  
372 0 0 4 344 3758 0 0 10 /**
 *
 */ 3 4 this 3 3798  1 i 1 3614  5 value 1 3608  
373 0 0 4 345 3758 0 0 10 /**
 *
 */ 2 4 this 3 3798  5 value 1 3608  
374 0 0 4 346 3758 0 0 10 /**
 *
 */ 2 4 this 3 3798  5 value 1 3608  
375 0 0 4 347 3758 0 0 10 /**
 *
 */ 2 4 this 3 3798  5 value 1 3608  
376 0 0 7 348 3753 2082 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3799  
377 0 0 7 349 3753 2082 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3799  
378 0 0 7 350 3753 2082 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3799  
379 0 0 4 357 3758 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3798  1 i 1 3614  5 value 1 3608  
380 0 0 4 358 3758 0 0 10 /**
 *
 */ 2 4 this 3 3798  5 value 1 3608  
381 0 0 4 359 3758 0 0 10 /**
 *
 */ 2 4 this 3 3798  5 value 1 3608  
382 0 0 4 360 3758 0 0 10 /**
 *
 */ 2 4 this 3 3798  5 value 1 3608  
383 0 0 4 361 3758 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3799  
384 0 0 6 362 3614 0 0 0 0 
385 0 0 4 363 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3798  10 fill_value 1 3608  
386 0 0 4 364 3758 0 0 10 /**
 *
 */ 4 4 this 3 3798  1 x 1 3608  1 y 1 3608  1 z 1 3608  
387 0 0 6 365 3608 0 0 10 /**
 *
 */ 2 4 this 3 3799  5 other 1 3799  
388 0 0 6 366 3608 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3799  
389 0 0 6 367 3608 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3799  
390 0 0 6 368 3763 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3798  
391 0 0 7 369 3798 2388 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3799  
392 0 0 7 370 3798 2388 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3799  4 onto 1 3799  
393 0 0 7 371 3798 2388 0 10 /**
 *
 */ 2 4 this 3 3799  5 other 1 3799  
394 0 0 6 372 3763 0 0 0 2 4 this 3 3799  5 other 1 3799  
395 0 0 6 373 3763 0 0 0 2 4 this 3 3799  5 other 1 3799  
396 0 0 6 374 3763 0 0 0 2 4 this 3 3799  5 other 1 3799  
397 0 0 7 375 3798 2388 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3799  
398 0 0 6 376 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3799  5 other 1 3799  
399 0 0 6 376 3614 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3799  5 other 1 3799  9 threshold 1 3608  
400 0 0 6 377 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3799  
401 0 0 6 377 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3799  9 threshold 1 3608  
402 0 0 6 378 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3799  4 hash 1 3756  
403 0 0 6 378 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3799  4 hash 1 3756  9 threshold 1 3608  
404 0 0 4 379 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3799  7 hashgen 1 3764  
405 0 0 4 379 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3799  7 hashgen 1 3764  9 threshold 1 3608  
406 0 0 7 380 3798 2388 0 0 1 4 this 3 3799  
407 0 0 7 381 3798 2388 0 0 2 4 this 3 3799  5 other 1 3799  
408 0 0 7 382 3798 2388 0 0 2 4 this 3 3799  5 other 1 3799  
409 0 0 7 383 3798 2388 0 0 2 4 this 3 3799  6 scalar 1 3608  
410 0 0 7 384 3798 2388 0 0 2 4 this 3 3799  6 scalar 1 3608  
411 0 0 6 385 3798 0 0 0 2 4 this 3 3798  5 other 1 3799  
412 0 0 6 386 3798 0 0 0 2 4 this 3 3798  5 other 1 3799  
413 0 0 6 387 3798 0 0 0 2 4 this 3 3798  6 scalar 1 3608  
414 0 0 6 388 3798 0 0 0 2 4 this 3 3798  6 scalar 1 3608  
415 0 0 4 389 3758 0 0 10 /**
 *
 */ 2 4 this 3 3798  5 other 1 3799  
416 0 0 38 390 3759 0 0 0 2 4 this 3 3799  6 scalar 1 3608  
417 0 0 38 391 3759 0 0 0 2 4 this 3 3798  6 scalar 1 3608  
418 0 0 38 392 3759 0 0 0 2 4 this 3 3799  8 exponent 1 3608  
419 0 0 38 393 3759 0 0 0 2 4 this 3 3798  8 exponent 1 3608  
420 0 0 38 394 3759 0 0 0 1 4 this 3 3798  
421 0 0 38 395 3759 0 0 0 1 4 this 3 3798  
422 0 0 38 396 3759 0 0 0 1 4 this 3 3798  
423 0 0 7 397 3798 2388 0 10 /**
 *
 */ 2 4 this 3 3799  5 other 1 3799  
424 0 0 7 398 3798 2388 0 10 /**
 *
 */ 2 4 this 3 3799  5 other 1 3799  
425 0 0 4 399 3758 0 0 10 /**
 *
 */ 2 4 this 3 3798  5 other 1 3799  
426 0 0 6 400 3763 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3799  5 other 1 3799  
427 0 0 6 400 3763 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3799  5 other 1 3799  9 threshold 1 3608  
428 0 0 4 401 3758 0 0 10 /**
 *
 */ 2 4 this 3 3799  3 out 1 3766  
429 0 0 38 402 3762 0 0 0 1 4 this 3 3799  
430 0 0 4 403 3758 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3799  11 destination 1 3768  
431 0 0 4 404 3758 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3798  6 source 1 3770  
432 0 0 4 405 3758 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3799  11 destination 1 3768  
433 0 0 4 406 3758 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3798  6 source 1 3770  
434 0 0 7 407 3773 0 0 0 0 
435 0 0 7 411 3801 2466 0 0 0 
436 0 0 23 411 3801 2466 0 10 /**
 *
 */ 2 4 copy 1 3775  1 z 1 3611  
437 0 0 15 411 3801 2466 0 0 1 6 param0 0 3802  
438 0 0 23 411 3801 2466 0 10 /**
 *
 */ 1 10 fill_value 1 3611  
439 0 0 23 411 3801 2466 0 10 /**
 *
 */ 3 1 x 1 3611  1 y 1 3611  1 z 1 3611  
440 0 0 4 412 3758 0 0 0 2 4 this 3 3801  4 size 1 3756  
441 0 0 6 415 3801 0 0 0 2 4 this 3 3801  4 copy 1 3802  
442 0 0 6 415 3801 0 0 0 2 4 this 3 3801  10 fill_value 1 3611  
443 0 0 6 416 3802 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
444 0 0 6 417 3802 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
445 0 0 6 418 3802 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
446 0 0 6 419 3802 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
447 0 0 38 420 3759 0 0 0 1 4 this 3 3802  
448 0 0 38 421 3759 0 0 0 2 4 this 3 3802  9 attr_name 1 3762  
449 0 0 38 422 3614 0 0 0 3 4 this 3 3801  9 attr_name 1 3762  6 assign 1 3759  
450 0 0 4 423 3758 0 0 10 /**
 *
 */ 3 4 this 3 3801  1 i 1 3614  10 assign_val 1 3611  
451 0 0 6 423 3611 0 0 0 2 4 this 3 3802  1 i 1 3614  
452 0 0 6 424 3614 0 0 0 0 
453 0 0 6 425 3763 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3802  
454 0 0 6 426 3611 0 0 10 /**
 *
 */ 2 4 this 3 3802  1 i 1 3614  
455 0 0 6 427 3611 0 0 10 /**
 *
 */ 1 4 this 3 3802  
456 0 0 6 428 3611 0 0 10 /**
 *
 */ 1 4 this 3 3802  
457 0 0 6 429 3611 0 0 10 /**
 *
 */ 1 4 this 3 3802  
458 0 0 4 430 3758 0 0 10 /**
 *
 */ 3 4 this 3 3801  1 i 1 3614  5 value 1 3611  
459 0 0 4 431 3758 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3611  
460 0 0 4 432 3758 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3611  
461 0 0 4 433 3758 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3611  
462 0 0 7 434 3774 2150 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3802  
463 0 0 7 435 3774 2150 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3802  
464 0 0 7 436 3774 2150 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3802  
465 0 0 4 443 3758 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3801  1 i 1 3614  5 value 1 3611  
466 0 0 4 444 3758 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3611  
467 0 0 4 445 3758 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3611  
468 0 0 4 446 3758 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 value 1 3611  
469 0 0 4 447 3758 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3802  
470 0 0 6 448 3614 0 0 0 0 
471 0 0 4 449 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3801  10 fill_value 1 3611  
472 0 0 4 450 3758 0 0 10 /**
 *
 */ 4 4 this 3 3801  1 x 1 3611  1 y 1 3611  1 z 1 3611  
473 0 0 6 451 3611 0 0 10 /**
 *
 */ 2 4 this 3 3802  5 other 1 3802  
474 0 0 6 452 3611 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3802  
475 0 0 6 453 3611 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3802  
476 0 0 6 454 3763 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3801  
477 0 0 7 455 3801 2466 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3802  
478 0 0 7 456 3801 2466 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3802  4 onto 1 3802  
479 0 0 7 457 3801 2466 0 10 /**
 *
 */ 2 4 this 3 3802  5 other 1 3802  
480 0 0 6 458 3763 0 0 0 2 4 this 3 3802  5 other 1 3802  
481 0 0 6 459 3763 0 0 0 2 4 this 3 3802  5 other 1 3802  
482 0 0 6 460 3763 0 0 0 2 4 this 3 3802  5 other 1 3802  
483 0 0 7 461 3801 2466 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3802  
484 0 0 6 462 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3802  5 other 1 3802  
485 0 0 6 462 3614 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3802  5 other 1 3802  9 threshold 1 3611  
486 0 0 6 463 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3802  
487 0 0 6 463 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3802  9 threshold 1 3611  
488 0 0 6 464 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3802  4 hash 1 3756  
489 0 0 6 464 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3802  4 hash 1 3756  9 threshold 1 3611  
490 0 0 4 465 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3802  7 hashgen 1 3764  
491 0 0 4 465 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3802  7 hashgen 1 3764  9 threshold 1 3611  
492 0 0 7 466 3801 2466 0 0 1 4 this 3 3802  
493 0 0 7 467 3801 2466 0 0 2 4 this 3 3802  5 other 1 3802  
494 0 0 7 468 3801 2466 0 0 2 4 this 3 3802  5 other 1 3802  
495 0 0 7 469 3801 2466 0 0 2 4 this 3 3802  6 scalar 1 3611  
496 0 0 7 470 3801 2466 0 0 2 4 this 3 3802  6 scalar 1 3611  
497 0 0 6 471 3801 0 0 0 2 4 this 3 3801  5 other 1 3802  
498 0 0 6 472 3801 0 0 0 2 4 this 3 3801  5 other 1 3802  
499 0 0 6 473 3801 0 0 0 2 4 this 3 3801  6 scalar 1 3611  
500 0 0 6 474 3801 0 0 0 2 4 this 3 3801  6 scalar 1 3611  
501 0 0 4 475 3758 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 other 1 3802  
502 0 0 38 476 3759 0 0 0 2 4 this 3 3802  6 scalar 1 3611  
503 0 0 38 477 3759 0 0 0 2 4 this 3 3801  6 scalar 1 3611  
504 0 0 38 478 3759 0 0 0 2 4 this 3 3802  8 exponent 1 3611  
505 0 0 38 479 3759 0 0 0 2 4 this 3 3801  8 exponent 1 3611  
506 0 0 38 480 3759 0 0 0 1 4 this 3 3801  
507 0 0 38 481 3759 0 0 0 1 4 this 3 3801  
508 0 0 38 482 3759 0 0 0 1 4 this 3 3801  
509 0 0 7 483 3801 2466 0 10 /**
 *
 */ 2 4 this 3 3802  5 other 1 3802  
510 0 0 7 484 3801 2466 0 10 /**
 *
 */ 2 4 this 3 3802  5 other 1 3802  
511 0 0 4 485 3758 0 0 10 /**
 *
 */ 2 4 this 3 3801  5 other 1 3802  
512 0 0 6 486 3763 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3802  5 other 1 3802  
513 0 0 6 486 3763 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3802  5 other 1 3802  9 threshold 1 3611  
514 0 0 4 487 3758 0 0 10 /**
 *
 */ 2 4 this 3 3802  3 out 1 3766  
515 0 0 38 488 3762 0 0 0 1 4 this 3 3802  
516 0 0 4 489 3758 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3802  11 destination 1 3768  
517 0 0 4 490 3758 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3801  6 source 1 3770  
518 0 0 4 491 3758 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3802  11 destination 1 3768  
519 0 0 4 492 3758 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3801  6 source 1 3770  
520 0 0 7 493 3773 0 0 0 0 
521 0 0 7 497 3804 2539 0 0 0 
522 0 0 23 497 3804 2539 0 10 /**
 *
 */ 2 4 copy 1 3778  1 z 1 3614  
523 0 0 15 497 3804 2539 0 0 1 6 param0 0 3805  
524 0 0 23 497 3804 2539 0 10 /**
 *
 */ 1 10 fill_value 1 3614  
525 0 0 23 497 3804 2539 0 10 /**
 *
 */ 3 1 x 1 3614  1 y 1 3614  1 z 1 3614  
526 0 0 4 498 3758 0 0 0 2 4 this 3 3804  4 size 1 3756  
527 0 0 6 501 3804 0 0 0 2 4 this 3 3804  4 copy 1 3805  
528 0 0 6 501 3804 0 0 0 2 4 this 3 3804  10 fill_value 1 3614  
529 0 0 6 502 3805 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
530 0 0 6 503 3805 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
531 0 0 6 504 3805 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
532 0 0 6 505 3805 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
533 0 0 38 506 3759 0 0 0 1 4 this 3 3805  
534 0 0 38 507 3759 0 0 0 2 4 this 3 3805  9 attr_name 1 3762  
535 0 0 38 508 3614 0 0 0 3 4 this 3 3804  9 attr_name 1 3762  6 assign 1 3759  
536 0 0 4 509 3758 0 0 10 /**
 *
 */ 3 4 this 3 3804  1 i 1 3614  10 assign_val 1 3614  
537 0 0 6 509 3614 0 0 0 2 4 this 3 3805  1 i 1 3614  
538 0 0 6 510 3614 0 0 0 0 
539 0 0 6 511 3763 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3805  
540 0 0 6 512 3614 0 0 10 /**
 *
 */ 2 4 this 3 3805  1 i 1 3614  
541 0 0 6 513 3614 0 0 10 /**
 *
 */ 1 4 this 3 3805  
542 0 0 6 514 3614 0 0 10 /**
 *
 */ 1 4 this 3 3805  
543 0 0 6 515 3614 0 0 10 /**
 *
 */ 1 4 this 3 3805  
544 0 0 4 516 3758 0 0 10 /**
 *
 */ 3 4 this 3 3804  1 i 1 3614  5 value 1 3614  
545 0 0 4 517 3758 0 0 10 /**
 *
 */ 2 4 this 3 3804  5 value 1 3614  
546 0 0 4 518 3758 0 0 10 /**
 *
 */ 2 4 this 3 3804  5 value 1 3614  
547 0 0 4 519 3758 0 0 10 /**
 *
 */ 2 4 this 3 3804  5 value 1 3614  
548 0 0 7 520 3777 2214 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3805  
549 0 0 7 521 3777 2214 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3805  
550 0 0 7 522 3777 2214 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3805  
551 0 0 4 529 3758 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3804  1 i 1 3614  5 value 1 3614  
552 0 0 4 530 3758 0 0 10 /**
 *
 */ 2 4 this 3 3804  5 value 1 3614  
553 0 0 4 531 3758 0 0 10 /**
 *
 */ 2 4 this 3 3804  5 value 1 3614  
554 0 0 4 532 3758 0 0 10 /**
 *
 */ 2 4 this 3 3804  5 value 1 3614  
555 0 0 4 533 3758 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3805  
556 0 0 6 534 3614 0 0 0 0 
557 0 0 4 535 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3804  10 fill_value 1 3614  
558 0 0 4 536 3758 0 0 10 /**
 *
 */ 4 4 this 3 3804  1 x 1 3614  1 y 1 3614  1 z 1 3614  
559 0 0 6 537 3614 0 0 10 /**
 *
 */ 2 4 this 3 3805  5 other 1 3805  
560 0 0 6 538 3614 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3805  
561 0 0 7 539 3804 2539 0 10 /**
 *
 */ 2 4 this 3 3805  5 other 1 3805  
562 0 0 6 540 3763 0 0 0 2 4 this 3 3805  5 other 1 3805  
563 0 0 6 541 3763 0 0 0 2 4 this 3 3805  5 other 1 3805  
564 0 0 6 542 3763 0 0 0 2 4 this 3 3805  5 other 1 3805  
565 0 0 6 543 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3805  5 other 1 3805  
566 0 0 6 544 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3805  
567 0 0 6 545 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3805  4 hash 1 3756  
568 0 0 4 546 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3805  7 hashgen 1 3764  
569 0 0 7 547 3804 2539 0 0 1 4 this 3 3805  
570 0 0 7 548 3804 2539 0 0 2 4 this 3 3805  5 other 1 3805  
571 0 0 7 549 3804 2539 0 0 2 4 this 3 3805  5 other 1 3805  
572 0 0 7 550 3804 2539 0 0 2 4 this 3 3805  6 scalar 1 3614  
573 0 0 7 551 3804 2539 0 0 2 4 this 3 3805  6 scalar 1 3614  
574 0 0 6 552 3804 0 0 0 2 4 this 3 3804  5 other 1 3805  
575 0 0 6 553 3804 0 0 0 2 4 this 3 3804  5 other 1 3805  
576 0 0 6 554 3804 0 0 0 2 4 this 3 3804  6 scalar 1 3614  
577 0 0 6 555 3804 0 0 0 2 4 this 3 3804  6 scalar 1 3614  
578 0 0 4 556 3758 0 0 10 /**
 *
 */ 2 4 this 3 3804  5 other 1 3805  
579 0 0 38 557 3759 0 0 0 2 4 this 3 3805  6 scalar 1 3614  
580 0 0 38 558 3759 0 0 0 2 4 this 3 3804  6 scalar 1 3614  
581 0 0 38 559 3759 0 0 0 2 4 this 3 3805  8 exponent 1 3614  
582 0 0 38 560 3759 0 0 0 2 4 this 3 3804  8 exponent 1 3614  
583 0 0 38 561 3759 0 0 0 1 4 this 3 3804  
584 0 0 38 562 3759 0 0 0 1 4 this 3 3804  
585 0 0 38 563 3759 0 0 0 1 4 this 3 3804  
586 0 0 7 564 3804 2539 0 10 /**
 *
 */ 2 4 this 3 3805  5 other 1 3805  
587 0 0 7 565 3804 2539 0 10 /**
 *
 */ 2 4 this 3 3805  5 other 1 3805  
588 0 0 4 566 3758 0 0 10 /**
 *
 */ 2 4 this 3 3804  5 other 1 3805  
589 0 0 6 567 3763 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3805  5 other 1 3805  
590 0 0 6 567 3763 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3805  5 other 1 3805  9 threshold 1 3614  
591 0 0 4 568 3758 0 0 10 /**
 *
 */ 2 4 this 3 3805  3 out 1 3766  
592 0 0 38 569 3762 0 0 0 1 4 this 3 3805  
593 0 0 4 570 3758 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3805  11 destination 1 3768  
594 0 0 4 571 3758 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3804  6 source 1 3770  
595 0 0 4 572 3758 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3805  11 destination 1 3768  
596 0 0 4 573 3758 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3804  6 source 1 3770  
597 0 0 7 574 3773 0 0 0 0 
598 0 0 7 582 3807 2577 0 0 0 
599 0 0 23 582 3807 2577 0 10 /**
 *
 */ 2 4 copy 1 3754  1 z 1 3608  
600 0 0 23 582 3807 2577 0 10 /**
 *
 */ 1 4 copy 1 3799  
601 0 0 15 582 3807 2577 0 0 1 6 param0 0 3808  
602 0 0 23 582 3807 2577 0 10 /**
 *
 */ 1 10 fill_value 1 3608  
603 0 0 23 582 3807 2577 0 10 /**
 *
 */ 3 1 x 1 3608  1 y 1 3608  1 z 1 3608  
604 0 0 38 583 3759 0 0 0 2 4 this 3 3808  9 attr_name 1 3762  
605 0 0 38 584 3614 0 0 0 3 4 this 3 3807  9 attr_name 1 3762  6 assign 1 3759  
606 0 0 6 585 3808 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
607 0 0 6 586 3808 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
608 0 0 6 587 3808 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
609 0 0 6 588 3808 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
610 0 0 7 589 3780 2232 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3808  
611 0 0 7 590 3780 2232 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3808  
612 0 0 7 591 3780 2232 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3808  
613 0 0 7 595 3807 2577 0 0 1 4 this 3 3808  
614 0 0 7 596 3798 2388 0 0 2 4 this 3 3808  5 other 1 3799  
615 0 0 7 596 3807 2577 0 0 2 4 this 3 3808  5 other 1 3808  
616 0 0 7 597 3798 2388 0 0 2 4 this 3 3808  5 other 1 3799  
617 0 0 7 597 3807 2577 0 0 2 4 this 3 3808  5 other 1 3808  
618 0 0 7 598 3807 2577 0 10 /**
 *
 */ 2 4 this 3 3808  5 other 1 3799  
619 0 0 7 599 3807 2577 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3808  
620 0 0 7 600 3807 2577 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3808  4 onto 1 3799  
621 0 0 6 601 3608 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3808  5 other 1 3808  
622 0 0 6 602 3608 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3808  5 other 1 3808  
623 0 0 6 603 3608 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3808  5 other 1 3808  3 ref 1 3808  
624 0 0 6 604 3608 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3808  5 other 1 3808  3 ref 1 3808  
625 0 0 6 605 3608 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3808  5 other 1 3808  
626 0 0 6 606 3608 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3808  5 other 1 3808  
627 0 0 7 607 3807 2577 0 0 2 4 this 3 3808  6 scalar 1 3608  
628 0 0 7 608 3807 2577 0 0 2 4 this 3 3808  6 scalar 1 3608  
629 0 0 7 609 3807 2577 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 5 3627  
630 0 0 7 610 3807 2577 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 5 3627  
631 0 0 7 611 3807 2577 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 5 3627  
632 0 0 7 612 3807 2577 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 5 3627  
633 0 0 7 613 3807 2577 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 5 3627  
634 0 0 7 614 3807 2577 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 5 3627  
635 0 0 7 615 3807 2577 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3608  3 fwd 1 3608  2 up 1 3608  2 cs 5 3627  
636 0 0 38 616 3762 0 0 0 1 4 this 3 3808  
637 0 0 7 617 3773 0 0 0 0 
638 0 0 7 620 3810 2611 0 0 0 
639 0 0 23 620 3810 2611 0 10 /**
 *
 */ 2 4 copy 1 3775  1 z 1 3611  
640 0 0 23 620 3810 2611 0 10 /**
 *
 */ 1 4 copy 1 3802  
641 0 0 15 620 3810 2611 0 0 1 6 param0 0 3811  
642 0 0 23 620 3810 2611 0 10 /**
 *
 */ 1 10 fill_value 1 3611  
643 0 0 23 620 3810 2611 0 10 /**
 *
 */ 3 1 x 1 3611  1 y 1 3611  1 z 1 3611  
644 0 0 38 621 3759 0 0 0 2 4 this 3 3811  9 attr_name 1 3762  
645 0 0 38 622 3614 0 0 0 3 4 this 3 3810  9 attr_name 1 3762  6 assign 1 3759  
646 0 0 6 623 3811 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
647 0 0 6 624 3811 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
648 0 0 6 625 3811 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
649 0 0 6 626 3811 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
650 0 0 7 627 3783 2250 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3811  
651 0 0 7 628 3783 2250 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3811  
652 0 0 7 629 3783 2250 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3811  
653 0 0 7 633 3810 2611 0 0 1 4 this 3 3811  
654 0 0 7 634 3801 2466 0 0 2 4 this 3 3811  5 other 1 3802  
655 0 0 7 634 3810 2611 0 0 2 4 this 3 3811  5 other 1 3811  
656 0 0 7 635 3801 2466 0 0 2 4 this 3 3811  5 other 1 3802  
657 0 0 7 635 3810 2611 0 0 2 4 this 3 3811  5 other 1 3811  
658 0 0 7 636 3810 2611 0 10 /**
 *
 */ 2 4 this 3 3811  5 other 1 3802  
659 0 0 7 637 3810 2611 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3811  
660 0 0 7 638 3810 2611 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3811  4 onto 1 3802  
661 0 0 6 639 3611 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3811  5 other 1 3811  
662 0 0 6 640 3611 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3811  5 other 1 3811  
663 0 0 6 641 3611 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3811  5 other 1 3811  3 ref 1 3811  
664 0 0 6 642 3611 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3811  5 other 1 3811  3 ref 1 3811  
665 0 0 6 643 3611 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3811  5 other 1 3811  
666 0 0 6 644 3611 0 0 34 /**
 * @deprecated Do not use.
 */ 2 4 this 3 3811  5 other 1 3811  
667 0 0 7 645 3810 2611 0 0 2 4 this 3 3811  6 scalar 1 3611  
668 0 0 7 646 3810 2611 0 0 2 4 this 3 3811  6 scalar 1 3611  
669 0 0 7 647 3810 2611 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 5 3627  
670 0 0 7 648 3810 2611 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 5 3627  
671 0 0 7 649 3810 2611 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 5 3627  
672 0 0 7 650 3810 2611 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 5 3627  
673 0 0 7 651 3810 2611 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 5 3627  
674 0 0 7 652 3810 2611 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 5 3627  
675 0 0 7 653 3810 2611 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3611  3 fwd 1 3611  2 up 1 3611  2 cs 5 3627  
676 0 0 38 654 3762 0 0 0 1 4 this 3 3811  
677 0 0 7 655 3773 0 0 0 0 
678 0 0 7 658 3813 2637 0 0 0 
679 0 0 23 658 3813 2637 0 10 /**
 *
 */ 2 4 copy 1 3778  1 z 1 3614  
680 0 0 23 658 3813 2637 0 10 /**
 *
 */ 1 4 copy 1 3805  
681 0 0 15 658 3813 2637 0 0 1 6 param0 0 3814  
682 0 0 23 658 3813 2637 0 10 /**
 *
 */ 1 10 fill_value 1 3614  
683 0 0 23 658 3813 2637 0 10 /**
 *
 */ 3 1 x 1 3614  1 y 1 3614  1 z 1 3614  
684 0 0 38 659 3759 0 0 0 2 4 this 3 3814  9 attr_name 1 3762  
685 0 0 38 660 3614 0 0 0 3 4 this 3 3813  9 attr_name 1 3762  6 assign 1 3759  
686 0 0 6 661 3814 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
687 0 0 6 662 3814 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
688 0 0 6 663 3814 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
689 0 0 6 664 3814 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
690 0 0 7 665 3786 2264 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3814  
691 0 0 7 666 3786 2264 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3814  
692 0 0 7 667 3786 2264 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3814  
693 0 0 7 671 3813 2637 0 0 1 4 this 3 3814  
694 0 0 7 672 3804 2539 0 0 2 4 this 3 3814  5 other 1 3805  
695 0 0 7 672 3813 2637 0 0 2 4 this 3 3814  5 other 1 3814  
696 0 0 7 673 3804 2539 0 0 2 4 this 3 3814  5 other 1 3805  
697 0 0 7 673 3813 2637 0 0 2 4 this 3 3814  5 other 1 3814  
698 0 0 7 674 3813 2637 0 10 /**
 *
 */ 2 4 this 3 3814  5 other 1 3805  
699 0 0 7 675 3813 2637 0 0 2 4 this 3 3814  6 scalar 1 3614  
700 0 0 7 676 3813 2637 0 0 2 4 this 3 3814  6 scalar 1 3614  
701 0 0 7 677 3813 2637 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 5 3627  
702 0 0 7 678 3813 2637 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 5 3627  
703 0 0 7 679 3813 2637 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 5 3627  
704 0 0 7 680 3813 2637 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 5 3627  
705 0 0 7 681 3813 2637 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 5 3627  
706 0 0 7 682 3813 2637 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 5 3627  
707 0 0 7 683 3813 2637 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3614  3 fwd 1 3614  2 up 1 3614  2 cs 5 3627  
708 0 0 38 684 3762 0 0 0 1 4 this 3 3814  
709 0 0 7 685 3773 0 0 0 0 
710 0 0 7 688 3816 2660 0 0 0 
711 0 0 15 688 3816 2660 0 0 1 6 param0 0 3817  
712 0 0 23 688 3816 2660 0 10 /**
 *
 */ 2 4 copy 1 3754  1 z 1 3608  
713 0 0 23 688 3816 2660 0 10 /**
 *
 */ 1 4 copy 1 3799  
714 0 0 23 688 3816 2660 0 10 /**
 *
 */ 1 10 fill_value 1 3608  
715 0 0 23 688 3816 2660 0 10 /**
 *
 */ 3 1 x 1 3608  1 y 1 3608  1 z 1 3608  
716 0 0 38 689 3759 0 0 0 2 4 this 3 3817  9 attr_name 1 3762  
717 0 0 38 690 3614 0 0 0 3 4 this 3 3816  9 attr_name 1 3762  6 assign 1 3759  
718 0 0 6 691 3817 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
719 0 0 6 692 3817 0 0 34 /**
 * Returns a unit X point.
 */ 0 
720 0 0 6 693 3817 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
721 0 0 6 694 3817 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
722 0 0 7 695 3789 2280 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3817  
723 0 0 7 696 3789 2280 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3817  
724 0 0 7 697 3789 2280 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3817  
725 0 0 7 701 3816 2660 0 0 1 4 this 3 3817  
726 0 0 7 702 3798 2388 0 0 2 4 this 3 3817  5 other 1 3799  
727 0 0 7 702 3816 2660 0 0 2 4 this 3 3817  5 other 1 3808  
728 0 0 7 703 3807 2577 0 0 2 4 this 3 3817  5 other 1 3817  
729 0 0 7 703 3798 2388 0 0 2 4 this 3 3817  5 other 1 3799  
730 0 0 7 703 3816 2660 0 0 2 4 this 3 3817  5 other 1 3808  
731 0 0 7 704 3816 2660 0 10 /**
 *
 */ 2 4 this 3 3817  5 other 1 3799  
732 0 0 7 705 3816 2660 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3817  
733 0 0 7 706 3816 2660 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3817  4 onto 1 3799  
734 0 0 7 707 3816 2660 0 0 2 4 this 3 3817  6 scalar 1 3608  
735 0 0 7 708 3816 2660 0 0 2 4 this 3 3817  6 scalar 1 3608  
736 0 0 6 709 3817 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 5 3627  
737 0 0 7 710 3816 2660 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3608  3 fwd 1 3608  2 up 1 3608  2 cs 5 3627  
738 0 0 38 711 3762 0 0 0 1 4 this 3 3817  
739 0 0 7 712 3773 0 0 0 0 
740 0 0 7 715 3819 2683 0 0 0 
741 0 0 15 715 3819 2683 0 0 1 6 param0 0 3820  
742 0 0 23 715 3819 2683 0 10 /**
 *
 */ 2 4 copy 1 3775  1 z 1 3611  
743 0 0 23 715 3819 2683 0 10 /**
 *
 */ 1 4 copy 1 3802  
744 0 0 23 715 3819 2683 0 10 /**
 *
 */ 1 10 fill_value 1 3611  
745 0 0 23 715 3819 2683 0 10 /**
 *
 */ 3 1 x 1 3611  1 y 1 3611  1 z 1 3611  
746 0 0 38 716 3759 0 0 0 2 4 this 3 3820  9 attr_name 1 3762  
747 0 0 38 717 3614 0 0 0 3 4 this 3 3819  9 attr_name 1 3762  6 assign 1 3759  
748 0 0 6 718 3820 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
749 0 0 6 719 3820 0 0 34 /**
 * Returns a unit X point.
 */ 0 
750 0 0 6 720 3820 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
751 0 0 6 721 3820 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
752 0 0 7 722 3792 2296 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3820  
753 0 0 7 723 3792 2296 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3820  
754 0 0 7 724 3792 2296 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3820  
755 0 0 7 728 3819 2683 0 0 1 4 this 3 3820  
756 0 0 7 729 3801 2466 0 0 2 4 this 3 3820  5 other 1 3802  
757 0 0 7 729 3819 2683 0 0 2 4 this 3 3820  5 other 1 3811  
758 0 0 7 730 3810 2611 0 0 2 4 this 3 3820  5 other 1 3820  
759 0 0 7 730 3801 2466 0 0 2 4 this 3 3820  5 other 1 3802  
760 0 0 7 730 3819 2683 0 0 2 4 this 3 3820  5 other 1 3811  
761 0 0 7 731 3819 2683 0 10 /**
 *
 */ 2 4 this 3 3820  5 other 1 3802  
762 0 0 7 732 3819 2683 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3820  
763 0 0 7 733 3819 2683 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3820  4 onto 1 3802  
764 0 0 7 734 3819 2683 0 0 2 4 this 3 3820  6 scalar 1 3611  
765 0 0 7 735 3819 2683 0 0 2 4 this 3 3820  6 scalar 1 3611  
766 0 0 6 736 3820 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 5 3627  
767 0 0 7 737 3819 2683 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3611  3 fwd 1 3611  2 up 1 3611  2 cs 5 3627  
768 0 0 38 738 3762 0 0 0 1 4 this 3 3820  
769 0 0 7 739 3773 0 0 0 0 
770 0 0 7 742 3822 2704 0 0 0 
771 0 0 15 742 3822 2704 0 0 1 6 param0 0 3823  
772 0 0 23 742 3822 2704 0 10 /**
 *
 */ 2 4 copy 1 3778  1 z 1 3614  
773 0 0 23 742 3822 2704 0 10 /**
 *
 */ 1 4 copy 1 3805  
774 0 0 23 742 3822 2704 0 10 /**
 *
 */ 1 10 fill_value 1 3614  
775 0 0 23 742 3822 2704 0 10 /**
 *
 */ 3 1 x 1 3614  1 y 1 3614  1 z 1 3614  
776 0 0 38 743 3759 0 0 0 2 4 this 3 3823  9 attr_name 1 3762  
777 0 0 38 744 3614 0 0 0 3 4 this 3 3822  9 attr_name 1 3762  6 assign 1 3759  
778 0 0 6 745 3823 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
779 0 0 6 746 3823 0 0 34 /**
 * Returns a unit X point.
 */ 0 
780 0 0 6 747 3823 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
781 0 0 6 748 3823 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
782 0 0 7 749 3795 2310 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3823  
783 0 0 7 750 3795 2310 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3823  
784 0 0 7 751 3795 2310 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3823  
785 0 0 7 755 3822 2704 0 0 1 4 this 3 3823  
786 0 0 7 756 3804 2539 0 0 2 4 this 3 3823  5 other 1 3805  
787 0 0 7 756 3822 2704 0 0 2 4 this 3 3823  5 other 1 3814  
788 0 0 7 757 3813 2637 0 0 2 4 this 3 3823  5 other 1 3823  
789 0 0 7 757 3804 2539 0 0 2 4 this 3 3823  5 other 1 3805  
790 0 0 7 757 3822 2704 0 0 2 4 this 3 3823  5 other 1 3814  
791 0 0 7 758 3822 2704 0 10 /**
 *
 */ 2 4 this 3 3823  5 other 1 3805  
792 0 0 7 759 3822 2704 0 0 2 4 this 3 3823  6 scalar 1 3614  
793 0 0 7 760 3822 2704 0 0 2 4 this 3 3823  6 scalar 1 3614  
794 0 0 6 761 3823 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 5 3627  
795 0 0 7 762 3822 2704 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3614  3 fwd 1 3614  2 up 1 3614  2 cs 5 3627  
796 0 0 38 763 3762 0 0 0 1 4 this 3 3823  
797 0 0 7 764 3773 0 0 0 0 
798 0 0 7 768 3825 2783 0 0 0 
799 0 0 23 768 3825 2783 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3817  
800 0 0 23 768 3825 2783 0 10 /**
 *
 */ 2 4 copy 1 3799  1 w 1 3608  
801 0 0 15 768 3825 2783 0 0 1 6 param0 0 3826  
802 0 0 23 768 3825 2783 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3808  
803 0 0 23 768 3825 2783 0 10 /**
 *
 */ 1 4 copy 1 3828  
804 0 0 23 768 3825 2783 0 10 /**
 *
 */ 1 10 fill_value 1 3608  
805 0 0 23 768 3825 2783 0 10 /**
 *
 */ 4 1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  
806 0 0 4 769 3758 0 0 0 2 4 this 3 3825  4 size 1 3756  
807 0 0 6 772 3825 0 0 0 2 4 this 3 3825  4 copy 1 3826  
808 0 0 6 772 3825 0 0 0 2 4 this 3 3825  10 fill_value 1 3608  
809 0 0 6 773 3826 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
810 0 0 6 774 3826 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
811 0 0 6 775 3826 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
812 0 0 6 776 3826 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
813 0 0 6 777 3826 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
814 0 0 38 778 3759 0 0 0 1 4 this 3 3826  
815 0 0 38 779 3759 0 0 0 2 4 this 3 3826  9 attr_name 1 3762  
816 0 0 38 780 3614 0 0 0 3 4 this 3 3825  9 attr_name 1 3762  6 assign 1 3759  
817 0 0 4 781 3758 0 0 10 /**
 *
 */ 3 4 this 3 3825  1 i 1 3614  10 assign_val 1 3608  
818 0 0 6 781 3608 0 0 0 2 4 this 3 3826  1 i 1 3614  
819 0 0 6 782 3614 0 0 0 0 
820 0 0 6 783 3763 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3826  
821 0 0 6 784 3608 0 0 10 /**
 *
 */ 2 4 this 3 3826  1 i 1 3614  
822 0 0 4 785 3758 0 0 10 /**
 *
 */ 3 4 this 3 3825  1 i 1 3614  5 value 1 3608  
823 0 0 6 786 3608 0 0 10 /**
 *
 */ 1 4 this 3 3826  
824 0 0 6 787 3608 0 0 10 /**
 *
 */ 1 4 this 3 3826  
825 0 0 6 788 3608 0 0 10 /**
 *
 */ 1 4 this 3 3826  
826 0 0 6 789 3608 0 0 10 /**
 *
 */ 1 4 this 3 3826  
827 0 0 7 790 3798 2388 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3826  
828 0 0 7 791 3753 2082 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3826  
829 0 0 4 792 3758 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 value 1 3608  
830 0 0 4 793 3758 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 value 1 3608  
831 0 0 4 794 3758 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 value 1 3608  
832 0 0 4 795 3758 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 value 1 3608  
833 0 0 4 801 3758 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3825  1 i 1 3614  5 value 1 3608  
834 0 0 4 802 3758 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 value 1 3608  
835 0 0 4 803 3758 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 value 1 3608  
836 0 0 4 804 3758 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 value 1 3608  
837 0 0 4 805 3758 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 value 1 3608  
838 0 0 4 806 3758 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3826  
839 0 0 6 807 3614 0 0 0 0 
840 0 0 4 809 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3825  10 fill_value 1 3608  
841 0 0 4 810 3758 0 0 10 /**
 *
 */ 5 4 this 3 3825  1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  
842 0 0 6 811 3608 0 0 10 /**
 *
 */ 2 4 this 3 3826  5 other 1 3826  
843 0 0 6 812 3608 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3826  
844 0 0 6 813 3608 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3826  
845 0 0 6 814 3763 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3825  
846 0 0 7 815 3825 2783 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3826  
847 0 0 7 816 3825 2783 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3826  4 onto 1 3826  
848 0 0 6 817 3763 0 0 0 2 4 this 3 3826  5 other 1 3826  
849 0 0 6 818 3763 0 0 0 2 4 this 3 3826  5 other 1 3826  
850 0 0 6 819 3763 0 0 0 2 4 this 3 3826  5 other 1 3826  
851 0 0 6 820 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3826  5 other 1 3826  
852 0 0 6 820 3614 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3826  5 other 1 3826  9 threshold 1 3608  
853 0 0 6 821 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3826  
854 0 0 6 821 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3826  9 threshold 1 3608  
855 0 0 6 822 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3826  4 hash 1 3756  
856 0 0 6 822 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3826  4 hash 1 3756  9 threshold 1 3608  
857 0 0 4 823 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3826  7 hashgen 1 3764  
858 0 0 4 823 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3826  7 hashgen 1 3764  9 threshold 1 3608  
859 0 0 7 824 3825 2783 0 0 1 4 this 3 3826  
860 0 0 7 825 3825 2783 0 0 2 4 this 3 3826  5 other 1 3826  
861 0 0 7 826 3825 2783 0 0 2 4 this 3 3826  5 other 1 3826  
862 0 0 7 827 3825 2783 0 0 2 4 this 3 3826  6 scalar 1 3608  
863 0 0 7 828 3825 2783 0 0 2 4 this 3 3826  6 scalar 1 3608  
864 0 0 6 829 3825 0 0 0 2 4 this 3 3825  5 other 1 3826  
865 0 0 6 830 3825 0 0 0 2 4 this 3 3825  5 other 1 3826  
866 0 0 6 831 3825 0 0 0 2 4 this 3 3825  6 scalar 1 3608  
867 0 0 6 832 3825 0 0 0 2 4 this 3 3825  6 scalar 1 3608  
868 0 0 4 833 3758 0 0 10 /**
 *
 */ 2 4 this 3 3825  5 other 1 3826  
869 0 0 38 834 3759 0 0 0 2 4 this 3 3826  6 scalar 1 3608  
870 0 0 38 835 3759 0 0 0 2 4 this 3 3825  6 scalar 1 3608  
871 0 0 38 836 3759 0 0 0 2 4 this 3 3826  8 exponent 1 3608  
872 0 0 38 837 3759 0 0 0 2 4 this 3 3825  8 exponent 1 3608  
873 0 0 38 838 3759 0 0 0 1 4 this 3 3825  
874 0 0 38 839 3759 0 0 0 1 4 this 3 3825  
875 0 0 38 840 3759 0 0 0 1 4 this 3 3825  
876 0 0 7 841 3825 2783 0 10 /**
 *
 */ 2 4 this 3 3826  5 other 1 3826  
877 0 0 7 842 3825 2783 0 10 /**
 *
 */ 2 4 this 3 3826  5 other 1 3826  
878 0 0 6 843 3763 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3826  5 other 1 3826  
879 0 0 6 843 3763 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3826  5 other 1 3826  9 threshold 1 3608  
880 0 0 4 844 3758 0 0 10 /**
 *
 */ 2 4 this 3 3826  3 out 1 3766  
881 0 0 38 845 3762 0 0 0 1 4 this 3 3826  
882 0 0 4 846 3758 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3826  11 destination 1 3768  
883 0 0 4 847 3758 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3825  6 source 1 3770  
884 0 0 4 848 3758 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3826  11 destination 1 3768  
885 0 0 4 849 3758 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3825  6 source 1 3770  
886 0 0 7 850 3773 0 0 0 0 
887 0 0 7 854 3830 2794 0 0 0 
888 0 0 23 854 3830 2794 0 10 /**
 *
 */ 1 4 copy 1 3826  
889 0 0 15 854 3830 2794 0 0 1 6 param0 0 3828  
890 0 0 23 854 3830 2794 0 10 /**
 *
 */ 1 10 fill_value 1 3608  
891 0 0 23 854 3830 2794 0 10 /**
 *
 */ 4 1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  
892 0 0 4 855 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3830  10 fill_value 1 3608  
893 0 0 4 856 3758 0 0 10 /**
 *
 */ 5 4 this 3 3830  1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  
894 0 0 4 857 3758 0 0 10 /**
 *
 */ 3 4 this 3 3830  1 i 1 3614  10 assign_val 1 3608  
895 0 0 6 857 3608 0 0 0 2 4 this 3 3828  1 i 1 3614  
896 0 0 6 858 3614 0 0 0 0 
897 0 0 4 859 3758 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3828  
898 0 0 6 860 3614 0 0 0 0 
899 0 0 6 861 3763 0 0 0 2 4 this 3 3828  5 other 1 3828  
900 0 0 6 862 3763 0 0 0 2 4 this 3 3828  5 other 1 3828  
901 0 0 7 863 3773 0 0 0 0 
902 0 0 7 867 3831 2873 0 0 0 
903 0 0 23 867 3831 2873 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3820  
904 0 0 23 867 3831 2873 0 10 /**
 *
 */ 2 4 copy 1 3802  1 w 1 3611  
905 0 0 15 867 3831 2873 0 0 1 6 param0 0 3832  
906 0 0 23 867 3831 2873 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3811  
907 0 0 23 867 3831 2873 0 10 /**
 *
 */ 1 4 copy 1 3834  
908 0 0 23 867 3831 2873 0 10 /**
 *
 */ 1 10 fill_value 1 3611  
909 0 0 23 867 3831 2873 0 10 /**
 *
 */ 4 1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  
910 0 0 4 868 3758 0 0 0 2 4 this 3 3831  4 size 1 3756  
911 0 0 6 871 3831 0 0 0 2 4 this 3 3831  4 copy 1 3832  
912 0 0 6 871 3831 0 0 0 2 4 this 3 3831  10 fill_value 1 3611  
913 0 0 6 872 3832 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
914 0 0 6 873 3832 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
915 0 0 6 874 3832 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
916 0 0 6 875 3832 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
917 0 0 6 876 3832 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
918 0 0 38 877 3759 0 0 0 1 4 this 3 3832  
919 0 0 38 878 3759 0 0 0 2 4 this 3 3832  9 attr_name 1 3762  
920 0 0 38 879 3614 0 0 0 3 4 this 3 3831  9 attr_name 1 3762  6 assign 1 3759  
921 0 0 4 880 3758 0 0 10 /**
 *
 */ 3 4 this 3 3831  1 i 1 3614  10 assign_val 1 3611  
922 0 0 6 880 3611 0 0 0 2 4 this 3 3832  1 i 1 3614  
923 0 0 6 881 3614 0 0 0 0 
924 0 0 6 882 3763 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3832  
925 0 0 6 883 3611 0 0 10 /**
 *
 */ 2 4 this 3 3832  1 i 1 3614  
926 0 0 4 884 3758 0 0 10 /**
 *
 */ 3 4 this 3 3831  1 i 1 3614  5 value 1 3611  
927 0 0 6 885 3611 0 0 10 /**
 *
 */ 1 4 this 3 3832  
928 0 0 6 886 3611 0 0 10 /**
 *
 */ 1 4 this 3 3832  
929 0 0 6 887 3611 0 0 10 /**
 *
 */ 1 4 this 3 3832  
930 0 0 6 888 3611 0 0 10 /**
 *
 */ 1 4 this 3 3832  
931 0 0 7 889 3801 2466 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3832  
932 0 0 7 890 3774 2150 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3832  
933 0 0 4 891 3758 0 0 10 /**
 *
 */ 2 4 this 3 3831  5 value 1 3611  
934 0 0 4 892 3758 0 0 10 /**
 *
 */ 2 4 this 3 3831  5 value 1 3611  
935 0 0 4 893 3758 0 0 10 /**
 *
 */ 2 4 this 3 3831  5 value 1 3611  
936 0 0 4 894 3758 0 0 10 /**
 *
 */ 2 4 this 3 3831  5 value 1 3611  
937 0 0 4 900 3758 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3831  1 i 1 3614  5 value 1 3611  
938 0 0 4 901 3758 0 0 10 /**
 *
 */ 2 4 this 3 3831  5 value 1 3611  
939 0 0 4 902 3758 0 0 10 /**
 *
 */ 2 4 this 3 3831  5 value 1 3611  
940 0 0 4 903 3758 0 0 10 /**
 *
 */ 2 4 this 3 3831  5 value 1 3611  
941 0 0 4 904 3758 0 0 10 /**
 *
 */ 2 4 this 3 3831  5 value 1 3611  
942 0 0 4 905 3758 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3832  
943 0 0 6 906 3614 0 0 0 0 
944 0 0 4 908 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3831  10 fill_value 1 3611  
945 0 0 4 909 3758 0 0 10 /**
 *
 */ 5 4 this 3 3831  1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  
946 0 0 6 910 3611 0 0 10 /**
 *
 */ 2 4 this 3 3832  5 other 1 3832  
947 0 0 6 911 3611 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3832  
948 0 0 6 912 3611 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3832  
949 0 0 6 913 3763 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3831  
950 0 0 7 914 3831 2873 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3832  
951 0 0 7 915 3831 2873 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3832  4 onto 1 3832  
952 0 0 6 916 3763 0 0 0 2 4 this 3 3832  5 other 1 3832  
953 0 0 6 917 3763 0 0 0 2 4 this 3 3832  5 other 1 3832  
954 0 0 6 918 3763 0 0 0 2 4 this 3 3832  5 other 1 3832  
955 0 0 6 919 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3832  5 other 1 3832  
956 0 0 6 919 3614 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3832  5 other 1 3832  9 threshold 1 3611  
957 0 0 6 920 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3832  
958 0 0 6 920 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3832  9 threshold 1 3611  
959 0 0 6 921 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3832  4 hash 1 3756  
960 0 0 6 921 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3832  4 hash 1 3756  9 threshold 1 3611  
961 0 0 4 922 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3832  7 hashgen 1 3764  
962 0 0 4 922 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3832  7 hashgen 1 3764  9 threshold 1 3611  
963 0 0 7 923 3831 2873 0 0 1 4 this 3 3832  
964 0 0 7 924 3831 2873 0 0 2 4 this 3 3832  5 other 1 3832  
965 0 0 7 925 3831 2873 0 0 2 4 this 3 3832  5 other 1 3832  
966 0 0 7 926 3831 2873 0 0 2 4 this 3 3832  6 scalar 1 3611  
967 0 0 7 927 3831 2873 0 0 2 4 this 3 3832  6 scalar 1 3611  
968 0 0 6 928 3831 0 0 0 2 4 this 3 3831  5 other 1 3832  
969 0 0 6 929 3831 0 0 0 2 4 this 3 3831  5 other 1 3832  
970 0 0 6 930 3831 0 0 0 2 4 this 3 3831  6 scalar 1 3611  
971 0 0 6 931 3831 0 0 0 2 4 this 3 3831  6 scalar 1 3611  
972 0 0 4 932 3758 0 0 10 /**
 *
 */ 2 4 this 3 3831  5 other 1 3832  
973 0 0 38 933 3759 0 0 0 2 4 this 3 3832  6 scalar 1 3611  
974 0 0 38 934 3759 0 0 0 2 4 this 3 3831  6 scalar 1 3611  
975 0 0 38 935 3759 0 0 0 2 4 this 3 3832  8 exponent 1 3611  
976 0 0 38 936 3759 0 0 0 2 4 this 3 3831  8 exponent 1 3611  
977 0 0 38 937 3759 0 0 0 1 4 this 3 3831  
978 0 0 38 938 3759 0 0 0 1 4 this 3 3831  
979 0 0 38 939 3759 0 0 0 1 4 this 3 3831  
980 0 0 7 940 3831 2873 0 10 /**
 *
 */ 2 4 this 3 3832  5 other 1 3832  
981 0 0 7 941 3831 2873 0 10 /**
 *
 */ 2 4 this 3 3832  5 other 1 3832  
982 0 0 6 942 3763 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3832  5 other 1 3832  
983 0 0 6 942 3763 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3832  5 other 1 3832  9 threshold 1 3611  
984 0 0 4 943 3758 0 0 10 /**
 *
 */ 2 4 this 3 3832  3 out 1 3766  
985 0 0 38 944 3762 0 0 0 1 4 this 3 3832  
986 0 0 4 945 3758 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3832  11 destination 1 3768  
987 0 0 4 946 3758 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3831  6 source 1 3770  
988 0 0 4 947 3758 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3832  11 destination 1 3768  
989 0 0 4 948 3758 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3831  6 source 1 3770  
990 0 0 7 949 3773 0 0 0 0 
991 0 0 7 953 3836 2884 0 0 0 
992 0 0 23 953 3836 2884 0 10 /**
 *
 */ 1 4 copy 1 3832  
993 0 0 15 953 3836 2884 0 0 1 6 param0 0 3834  
994 0 0 23 953 3836 2884 0 10 /**
 *
 */ 1 10 fill_value 1 3611  
995 0 0 23 953 3836 2884 0 10 /**
 *
 */ 4 1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  
996 0 0 4 954 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3836  10 fill_value 1 3611  
997 0 0 4 955 3758 0 0 10 /**
 *
 */ 5 4 this 3 3836  1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  
998 0 0 4 956 3758 0 0 10 /**
 *
 */ 3 4 this 3 3836  1 i 1 3614  10 assign_val 1 3611  
999 0 0 6 956 3611 0 0 0 2 4 this 3 3834  1 i 1 3614  
1000 0 0 6 957 3614 0 0 0 0 
1001 0 0 4 958 3758 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3834  
1002 0 0 6 959 3614 0 0 0 0 
1003 0 0 6 960 3763 0 0 0 2 4 this 3 3834  5 other 1 3834  
1004 0 0 6 961 3763 0 0 0 2 4 this 3 3834  5 other 1 3834  
1005 0 0 7 962 3773 0 0 0 0 
1006 0 0 7 966 3837 2959 0 0 0 
1007 0 0 23 966 3837 2959 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3823  
1008 0 0 23 966 3837 2959 0 10 /**
 *
 */ 2 4 copy 1 3805  1 w 1 3614  
1009 0 0 15 966 3837 2959 0 0 1 6 param0 0 3838  
1010 0 0 23 966 3837 2959 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3814  
1011 0 0 23 966 3837 2959 0 10 /**
 *
 */ 1 4 copy 1 3840  
1012 0 0 23 966 3837 2959 0 10 /**
 *
 */ 1 10 fill_value 1 3614  
1013 0 0 23 966 3837 2959 0 10 /**
 *
 */ 4 1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  
1014 0 0 4 967 3758 0 0 0 2 4 this 3 3837  4 size 1 3756  
1015 0 0 6 970 3837 0 0 0 2 4 this 3 3837  4 copy 1 3838  
1016 0 0 6 970 3837 0 0 0 2 4 this 3 3837  10 fill_value 1 3614  
1017 0 0 6 971 3838 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1018 0 0 6 972 3838 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1019 0 0 6 973 3838 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1020 0 0 6 974 3838 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1021 0 0 6 975 3838 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1022 0 0 38 976 3759 0 0 0 1 4 this 3 3838  
1023 0 0 38 977 3759 0 0 0 2 4 this 3 3838  9 attr_name 1 3762  
1024 0 0 38 978 3614 0 0 0 3 4 this 3 3837  9 attr_name 1 3762  6 assign 1 3759  
1025 0 0 4 979 3758 0 0 10 /**
 *
 */ 3 4 this 3 3837  1 i 1 3614  10 assign_val 1 3614  
1026 0 0 6 979 3614 0 0 0 2 4 this 3 3838  1 i 1 3614  
1027 0 0 6 980 3614 0 0 0 0 
1028 0 0 6 981 3763 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3838  
1029 0 0 6 982 3614 0 0 10 /**
 *
 */ 2 4 this 3 3838  1 i 1 3614  
1030 0 0 4 983 3758 0 0 10 /**
 *
 */ 3 4 this 3 3837  1 i 1 3614  5 value 1 3614  
1031 0 0 6 984 3614 0 0 10 /**
 *
 */ 1 4 this 3 3838  
1032 0 0 6 985 3614 0 0 10 /**
 *
 */ 1 4 this 3 3838  
1033 0 0 6 986 3614 0 0 10 /**
 *
 */ 1 4 this 3 3838  
1034 0 0 6 987 3614 0 0 10 /**
 *
 */ 1 4 this 3 3838  
1035 0 0 7 988 3804 2539 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3838  
1036 0 0 7 989 3777 2214 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3838  
1037 0 0 4 990 3758 0 0 10 /**
 *
 */ 2 4 this 3 3837  5 value 1 3614  
1038 0 0 4 991 3758 0 0 10 /**
 *
 */ 2 4 this 3 3837  5 value 1 3614  
1039 0 0 4 992 3758 0 0 10 /**
 *
 */ 2 4 this 3 3837  5 value 1 3614  
1040 0 0 4 993 3758 0 0 10 /**
 *
 */ 2 4 this 3 3837  5 value 1 3614  
1041 0 0 4 999 3758 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3837  1 i 1 3614  5 value 1 3614  
1042 0 0 4 1000 3758 0 0 10 /**
 *
 */ 2 4 this 3 3837  5 value 1 3614  
1043 0 0 4 1001 3758 0 0 10 /**
 *
 */ 2 4 this 3 3837  5 value 1 3614  
1044 0 0 4 1002 3758 0 0 10 /**
 *
 */ 2 4 this 3 3837  5 value 1 3614  
1045 0 0 4 1003 3758 0 0 10 /**
 *
 */ 2 4 this 3 3837  5 value 1 3614  
1046 0 0 4 1004 3758 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3838  
1047 0 0 6 1005 3614 0 0 0 0 
1048 0 0 4 1007 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3837  10 fill_value 1 3614  
1049 0 0 4 1008 3758 0 0 10 /**
 *
 */ 5 4 this 3 3837  1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  
1050 0 0 6 1009 3614 0 0 10 /**
 *
 */ 2 4 this 3 3838  5 other 1 3838  
1051 0 0 6 1010 3614 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3838  
1052 0 0 6 1011 3763 0 0 0 2 4 this 3 3838  5 other 1 3838  
1053 0 0 6 1012 3763 0 0 0 2 4 this 3 3838  5 other 1 3838  
1054 0 0 6 1013 3763 0 0 0 2 4 this 3 3838  5 other 1 3838  
1055 0 0 6 1014 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3838  5 other 1 3838  
1056 0 0 6 1015 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3838  
1057 0 0 6 1016 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3838  4 hash 1 3756  
1058 0 0 4 1017 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3838  7 hashgen 1 3764  
1059 0 0 7 1018 3837 2959 0 0 1 4 this 3 3838  
1060 0 0 7 1019 3837 2959 0 0 2 4 this 3 3838  5 other 1 3838  
1061 0 0 7 1020 3837 2959 0 0 2 4 this 3 3838  5 other 1 3838  
1062 0 0 7 1021 3837 2959 0 0 2 4 this 3 3838  6 scalar 1 3614  
1063 0 0 7 1022 3837 2959 0 0 2 4 this 3 3838  6 scalar 1 3614  
1064 0 0 6 1023 3837 0 0 0 2 4 this 3 3837  5 other 1 3838  
1065 0 0 6 1024 3837 0 0 0 2 4 this 3 3837  5 other 1 3838  
1066 0 0 6 1025 3837 0 0 0 2 4 this 3 3837  6 scalar 1 3614  
1067 0 0 6 1026 3837 0 0 0 2 4 this 3 3837  6 scalar 1 3614  
1068 0 0 4 1027 3758 0 0 10 /**
 *
 */ 2 4 this 3 3837  5 other 1 3838  
1069 0 0 38 1028 3759 0 0 0 2 4 this 3 3838  6 scalar 1 3614  
1070 0 0 38 1029 3759 0 0 0 2 4 this 3 3837  6 scalar 1 3614  
1071 0 0 38 1030 3759 0 0 0 2 4 this 3 3838  8 exponent 1 3614  
1072 0 0 38 1031 3759 0 0 0 2 4 this 3 3837  8 exponent 1 3614  
1073 0 0 38 1032 3759 0 0 0 1 4 this 3 3837  
1074 0 0 38 1033 3759 0 0 0 1 4 this 3 3837  
1075 0 0 38 1034 3759 0 0 0 1 4 this 3 3837  
1076 0 0 7 1035 3837 2959 0 10 /**
 *
 */ 2 4 this 3 3838  5 other 1 3838  
1077 0 0 7 1036 3837 2959 0 10 /**
 *
 */ 2 4 this 3 3838  5 other 1 3838  
1078 0 0 6 1037 3763 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3838  5 other 1 3838  
1079 0 0 6 1037 3763 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3838  5 other 1 3838  9 threshold 1 3614  
1080 0 0 4 1038 3758 0 0 10 /**
 *
 */ 2 4 this 3 3838  3 out 1 3766  
1081 0 0 38 1039 3762 0 0 0 1 4 this 3 3838  
1082 0 0 4 1040 3758 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3838  11 destination 1 3768  
1083 0 0 4 1041 3758 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3837  6 source 1 3770  
1084 0 0 4 1042 3758 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3838  11 destination 1 3768  
1085 0 0 4 1043 3758 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3837  6 source 1 3770  
1086 0 0 7 1044 3773 0 0 0 0 
1087 0 0 7 1048 3842 2970 0 0 0 
1088 0 0 23 1048 3842 2970 0 10 /**
 *
 */ 1 4 copy 1 3838  
1089 0 0 15 1048 3842 2970 0 0 1 6 param0 0 3840  
1090 0 0 23 1048 3842 2970 0 10 /**
 *
 */ 1 10 fill_value 1 3614  
1091 0 0 23 1048 3842 2970 0 10 /**
 *
 */ 4 1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  
1092 0 0 4 1049 3758 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3842  10 fill_value 1 3614  
1093 0 0 4 1050 3758 0 0 10 /**
 *
 */ 5 4 this 3 3842  1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  
1094 0 0 4 1051 3758 0 0 10 /**
 *
 */ 3 4 this 3 3842  1 i 1 3614  10 assign_val 1 3614  
1095 0 0 6 1051 3614 0 0 0 2 4 this 3 3840  1 i 1 3614  
1096 0 0 6 1052 3614 0 0 0 0 
1097 0 0 4 1053 3758 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3840  
1098 0 0 6 1054 3614 0 0 0 0 
1099 0 0 6 1055 3763 0 0 0 2 4 this 3 3840  5 other 1 3840  
1100 0 0 6 1056 3763 0 0 0 2 4 this 3 3840  5 other 1 3840  
1101 0 0 7 1057 3773 0 0 0 0 
1102 0 0 7 1060 3843 2990 0 0 0 
1103 0 0 23 1060 3843 2990 0 10 /**
 *
 */ 2 4 copy 1 3799  1 w 1 3608  
1104 0 0 23 1060 3843 2990 0 10 /**
 *
 */ 1 4 copy 1 3826  
1105 0 0 15 1060 3843 2990 0 0 1 6 param0 0 3844  
1106 0 0 23 1060 3843 2990 0 10 /**
 *
 */ 1 10 fill_value 1 3608  
1107 0 0 23 1060 3843 2990 0 10 /**
 *
 */ 4 1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  
1108 0 0 38 1061 3759 0 0 0 2 4 this 3 3844  9 attr_name 1 3762  
1109 0 0 38 1062 3614 0 0 0 3 4 this 3 3843  9 attr_name 1 3762  6 assign 1 3759  
1110 0 0 6 1063 3844 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1111 0 0 6 1064 3844 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1112 0 0 6 1065 3844 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1113 0 0 6 1066 3844 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1114 0 0 6 1067 3844 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1115 0 0 7 1068 3807 2577 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3844  
1116 0 0 7 1069 3780 2232 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3844  
1117 0 0 7 1072 3843 2990 0 0 1 4 this 3 3844  
1118 0 0 7 1073 3825 2783 0 0 2 4 this 3 3844  5 other 1 3826  
1119 0 0 7 1073 3843 2990 0 0 2 4 this 3 3844  5 other 1 3844  
1120 0 0 7 1074 3825 2783 0 0 2 4 this 3 3844  5 other 1 3826  
1121 0 0 7 1074 3843 2990 0 0 2 4 this 3 3844  5 other 1 3844  
1122 0 0 7 1075 3843 2990 0 0 2 4 this 3 3844  6 scalar 1 3608  
1123 0 0 7 1076 3843 2990 0 0 2 4 this 3 3844  6 scalar 1 3608  
1124 0 0 7 1077 3843 2990 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3844  
1125 0 0 7 1078 3843 2990 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3844  4 onto 1 3826  
1126 0 0 38 1079 3762 0 0 0 1 4 this 3 3844  
1127 0 0 7 1080 3773 0 0 0 0 
1128 0 0 7 1083 3846 3010 0 0 0 
1129 0 0 23 1083 3846 3010 0 10 /**
 *
 */ 2 4 copy 1 3802  1 w 1 3611  
1130 0 0 23 1083 3846 3010 0 10 /**
 *
 */ 1 4 copy 1 3832  
1131 0 0 15 1083 3846 3010 0 0 1 6 param0 0 3847  
1132 0 0 23 1083 3846 3010 0 10 /**
 *
 */ 1 10 fill_value 1 3611  
1133 0 0 23 1083 3846 3010 0 10 /**
 *
 */ 4 1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  
1134 0 0 38 1084 3759 0 0 0 2 4 this 3 3847  9 attr_name 1 3762  
1135 0 0 38 1085 3614 0 0 0 3 4 this 3 3846  9 attr_name 1 3762  6 assign 1 3759  
1136 0 0 6 1086 3847 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1137 0 0 6 1087 3847 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1138 0 0 6 1088 3847 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1139 0 0 6 1089 3847 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1140 0 0 6 1090 3847 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1141 0 0 7 1091 3810 2611 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3847  
1142 0 0 7 1092 3783 2250 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3847  
1143 0 0 7 1095 3846 3010 0 0 1 4 this 3 3847  
1144 0 0 7 1096 3831 2873 0 0 2 4 this 3 3847  5 other 1 3832  
1145 0 0 7 1096 3846 3010 0 0 2 4 this 3 3847  5 other 1 3847  
1146 0 0 7 1097 3831 2873 0 0 2 4 this 3 3847  5 other 1 3832  
1147 0 0 7 1097 3846 3010 0 0 2 4 this 3 3847  5 other 1 3847  
1148 0 0 7 1098 3846 3010 0 0 2 4 this 3 3847  6 scalar 1 3611  
1149 0 0 7 1099 3846 3010 0 0 2 4 this 3 3847  6 scalar 1 3611  
1150 0 0 7 1100 3846 3010 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3847  
1151 0 0 7 1101 3846 3010 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3847  4 onto 1 3832  
1152 0 0 38 1102 3762 0 0 0 1 4 this 3 3847  
1153 0 0 7 1103 3773 0 0 0 0 
1154 0 0 7 1106 3849 3028 0 0 0 
1155 0 0 23 1106 3849 3028 0 10 /**
 *
 */ 2 4 copy 1 3805  1 w 1 3614  
1156 0 0 23 1106 3849 3028 0 10 /**
 *
 */ 1 4 copy 1 3838  
1157 0 0 15 1106 3849 3028 0 0 1 6 param0 0 3850  
1158 0 0 23 1106 3849 3028 0 10 /**
 *
 */ 1 10 fill_value 1 3614  
1159 0 0 23 1106 3849 3028 0 10 /**
 *
 */ 4 1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  
1160 0 0 38 1107 3759 0 0 0 2 4 this 3 3850  9 attr_name 1 3762  
1161 0 0 38 1108 3614 0 0 0 3 4 this 3 3849  9 attr_name 1 3762  6 assign 1 3759  
1162 0 0 6 1109 3850 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1163 0 0 6 1110 3850 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1164 0 0 6 1111 3850 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1165 0 0 6 1112 3850 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1166 0 0 6 1113 3850 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1167 0 0 7 1114 3813 2637 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3850  
1168 0 0 7 1115 3786 2264 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3850  
1169 0 0 7 1118 3849 3028 0 0 1 4 this 3 3850  
1170 0 0 7 1119 3837 2959 0 0 2 4 this 3 3850  5 other 1 3838  
1171 0 0 7 1119 3849 3028 0 0 2 4 this 3 3850  5 other 1 3850  
1172 0 0 7 1120 3837 2959 0 0 2 4 this 3 3850  5 other 1 3838  
1173 0 0 7 1120 3849 3028 0 0 2 4 this 3 3850  5 other 1 3850  
1174 0 0 7 1121 3849 3028 0 0 2 4 this 3 3850  6 scalar 1 3614  
1175 0 0 7 1122 3849 3028 0 0 2 4 this 3 3850  6 scalar 1 3614  
1176 0 0 38 1123 3762 0 0 0 1 4 this 3 3850  
1177 0 0 7 1124 3773 0 0 0 0 
1178 0 0 7 1127 3852 3048 0 0 0 
1179 0 0 15 1127 3852 3048 0 0 1 6 param0 0 3853  
1180 0 0 23 1127 3852 3048 0 10 /**
 *
 */ 2 4 copy 1 3799  1 w 1 3608  
1181 0 0 23 1127 3852 3048 0 10 /**
 *
 */ 1 4 copy 1 3826  
1182 0 0 23 1127 3852 3048 0 10 /**
 *
 */ 1 10 fill_value 1 3608  
1183 0 0 23 1127 3852 3048 0 10 /**
 *
 */ 4 1 x 1 3608  1 y 1 3608  1 z 1 3608  1 w 1 3608  
1184 0 0 38 1128 3759 0 0 0 2 4 this 3 3853  9 attr_name 1 3762  
1185 0 0 38 1129 3614 0 0 0 3 4 this 3 3852  9 attr_name 1 3762  6 assign 1 3759  
1186 0 0 6 1130 3853 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1187 0 0 6 1131 3853 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1188 0 0 6 1132 3853 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1189 0 0 6 1133 3853 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1190 0 0 6 1134 3853 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1191 0 0 7 1135 3816 2660 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3853  
1192 0 0 7 1136 3789 2280 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3853  
1193 0 0 7 1139 3852 3048 0 0 1 4 this 3 3853  
1194 0 0 7 1140 3825 2783 0 0 2 4 this 3 3853  5 other 1 3826  
1195 0 0 7 1140 3852 3048 0 0 2 4 this 3 3853  5 other 1 3844  
1196 0 0 7 1141 3843 2990 0 0 2 4 this 3 3853  5 other 1 3853  
1197 0 0 7 1141 3825 2783 0 0 2 4 this 3 3853  5 other 1 3826  
1198 0 0 7 1141 3852 3048 0 0 2 4 this 3 3853  5 other 1 3844  
1199 0 0 7 1142 3852 3048 0 0 2 4 this 3 3853  6 scalar 1 3608  
1200 0 0 7 1143 3852 3048 0 0 2 4 this 3 3853  6 scalar 1 3608  
1201 0 0 7 1144 3852 3048 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3853  
1202 0 0 7 1145 3852 3048 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3853  4 onto 1 3826  
1203 0 0 38 1146 3762 0 0 0 1 4 this 3 3853  
1204 0 0 7 1147 3773 0 0 0 0 
1205 0 0 7 1150 3855 3068 0 0 0 
1206 0 0 15 1150 3855 3068 0 0 1 6 param0 0 3856  
1207 0 0 23 1150 3855 3068 0 10 /**
 *
 */ 2 4 copy 1 3802  1 w 1 3611  
1208 0 0 23 1150 3855 3068 0 10 /**
 *
 */ 1 4 copy 1 3832  
1209 0 0 23 1150 3855 3068 0 10 /**
 *
 */ 1 10 fill_value 1 3611  
1210 0 0 23 1150 3855 3068 0 10 /**
 *
 */ 4 1 x 1 3611  1 y 1 3611  1 z 1 3611  1 w 1 3611  
1211 0 0 38 1151 3759 0 0 0 2 4 this 3 3856  9 attr_name 1 3762  
1212 0 0 38 1152 3614 0 0 0 3 4 this 3 3855  9 attr_name 1 3762  6 assign 1 3759  
1213 0 0 6 1153 3856 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1214 0 0 6 1154 3856 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1215 0 0 6 1155 3856 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1216 0 0 6 1156 3856 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1217 0 0 6 1157 3856 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1218 0 0 7 1158 3819 2683 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3856  
1219 0 0 7 1159 3792 2296 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3856  
1220 0 0 7 1162 3855 3068 0 0 1 4 this 3 3856  
1221 0 0 7 1163 3831 2873 0 0 2 4 this 3 3856  5 other 1 3832  
1222 0 0 7 1163 3855 3068 0 0 2 4 this 3 3856  5 other 1 3847  
1223 0 0 7 1164 3846 3010 0 0 2 4 this 3 3856  5 other 1 3856  
1224 0 0 7 1164 3831 2873 0 0 2 4 this 3 3856  5 other 1 3832  
1225 0 0 7 1164 3855 3068 0 0 2 4 this 3 3856  5 other 1 3847  
1226 0 0 7 1165 3855 3068 0 0 2 4 this 3 3856  6 scalar 1 3611  
1227 0 0 7 1166 3855 3068 0 0 2 4 this 3 3856  6 scalar 1 3611  
1228 0 0 7 1167 3855 3068 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3856  
1229 0 0 7 1168 3855 3068 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3856  4 onto 1 3832  
1230 0 0 38 1169 3762 0 0 0 1 4 this 3 3856  
1231 0 0 7 1170 3773 0 0 0 0 
1232 0 0 7 1173 3858 3086 0 0 0 
1233 0 0 15 1173 3858 3086 0 0 1 6 param0 0 3859  
1234 0 0 23 1173 3858 3086 0 10 /**
 *
 */ 2 4 copy 1 3805  1 w 1 3614  
1235 0 0 23 1173 3858 3086 0 10 /**
 *
 */ 1 4 copy 1 3838  
1236 0 0 23 1173 3858 3086 0 10 /**
 *
 */ 1 10 fill_value 1 3614  
1237 0 0 23 1173 3858 3086 0 10 /**
 *
 */ 4 1 x 1 3614  1 y 1 3614  1 z 1 3614  1 w 1 3614  
1238 0 0 38 1174 3759 0 0 0 2 4 this 3 3859  9 attr_name 1 3762  
1239 0 0 38 1175 3614 0 0 0 3 4 this 3 3858  9 attr_name 1 3762  6 assign 1 3759  
1240 0 0 6 1176 3859 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1241 0 0 6 1177 3859 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1242 0 0 6 1178 3859 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1243 0 0 6 1179 3859 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1244 0 0 6 1180 3859 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1245 0 0 7 1181 3822 2704 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3859  
1246 0 0 7 1182 3795 2310 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3859  
1247 0 0 7 1185 3858 3086 0 0 1 4 this 3 3859  
1248 0 0 7 1186 3837 2959 0 0 2 4 this 3 3859  5 other 1 3838  
1249 0 0 7 1186 3858 3086 0 0 2 4 this 3 3859  5 other 1 3850  
1250 0 0 7 1187 3849 3028 0 0 2 4 this 3 3859  5 other 1 3859  
1251 0 0 7 1187 3837 2959 0 0 2 4 this 3 3859  5 other 1 3838  
1252 0 0 7 1187 3858 3086 0 0 2 4 this 3 3859  5 other 1 3850  
1253 0 0 7 1188 3858 3086 0 0 2 4 this 3 3859  6 scalar 1 3614  
1254 0 0 7 1189 3858 3086 0 0 2 4 this 3 3859  6 scalar 1 3614  
1255 0 0 38 1190 3762 0 0 0 1 4 this 3 3859  
1256 0 0 7 1191 3773 0 0 0 0 
1257 0 0 7 1207 3861 3172 0 10 /**
 *
 */ 0 
1258 0 0 15 1207 3861 3172 0 10 /**
 *
 */ 1 5 other 1 3862  
1259 0 0 23 1207 3861 3172 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3799  6 param1 0 3799  6 param2 0 3799  
1260 0 0 23 1207 3861 3172 0 10 /**
 *
 */ 9 6 param0 0 3608  6 param1 0 3608  6 param2 0 3608  6 param3 0 3608  6 param4 0 3608  6 param5 0 3608  6 param6 0 3608  6 param7 0 3608  6 param8 0 3608  
1261 0 0 6 1208 3861 0 0 10 /**
 *
 */ 2 4 this 3 3861  5 other 1 3862  
1262 0 0 6 1208 3861 0 0 10 /**
 *
 */ 2 4 this 3 3861  10 fill_value 1 3608  
1263 0 0 4 1209 3758 0 0 0 2 4 this 3 3861  4 size 1 3756  
1264 0 0 38 1212 3759 0 0 0 1 4 this 3 3862  
1265 0 0 4 1213 3758 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3861  10 fill_value 1 3608  
1266 0 0 4 1214 3758 0 0 10 /**
 *
 */ 10 4 this 3 3861  3 e00 1 3608  3 e01 1 3608  3 e02 1 3608  3 e10 1 3608  3 e11 1 3608  3 e12 1 3608  3 e20 1 3608  3 e21 1 3608  3 e22 1 3608  
1267 0 0 7 1215 3864 3091 0 0 2 4 this 3 3861  1 i 1 3614  
1268 0 0 7 1215 3865 3096 0 0 2 4 this 3 3862  1 i 1 3614  
1269 0 0 6 1216 3614 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1270 0 0 4 1217 3758 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3861  3 row 1 3614  1 v 1 3754  
1271 0 0 4 1217 3758 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3861  3 row 1 3614  1 v 1 3799  
1272 0 0 4 1218 3758 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3861  3 col 1 3614  1 v 1 3754  
1273 0 0 4 1218 3758 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3861  3 col 1 3614  1 v 1 3799  
1274 0 0 4 1219 3758 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3862  10 result_vec 1 3798  3 row 1 3614  
1275 0 0 7 1219 3798 2388 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3862  3 row 1 3614  
1276 0 0 7 1220 3798 2388 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3862  3 col 1 3614  
1277 0 0 7 1225 3753 2082 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3862  3 row 1 3614  
1278 0 0 7 1226 3753 2082 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3862  3 col 1 3614  
1279 0 0 4 1229 3758 0 0 10 /**
 *
 */ 3 4 this 3 3861  3 row 1 3614  3 col 1 3614  
1280 0 0 6 1229 3608 0 0 0 3 4 this 3 3862  3 row 1 3614  3 col 1 3614  
1281 0 0 6 1230 3763 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3862  
1282 0 0 6 1231 3763 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3862  
1283 0 0 6 1232 3608 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3862  3 row 1 3614  3 col 1 3614  
1284 0 0 4 1233 3758 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3861  3 row 1 3614  3 col 1 3614  5 value 1 3608  
1285 0 0 4 1234 3758 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3862  
1286 0 0 6 1235 3614 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3862  
1287 0 0 6 1236 3763 0 0 0 2 4 this 3 3862  5 other 1 3862  
1288 0 0 6 1237 3763 0 0 0 2 4 this 3 3862  5 other 1 3862  
1289 0 0 6 1238 3763 0 0 0 2 4 this 3 3862  5 other 1 3862  
1290 0 0 6 1239 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3862  5 other 1 3862  
1291 0 0 6 1239 3614 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3862  5 other 1 3862  9 threshold 1 3608  
1292 0 0 6 1240 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3862  
1293 0 0 6 1240 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3862  9 threshold 1 3608  
1294 0 0 6 1241 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3862  4 hash 1 3756  
1295 0 0 6 1241 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3862  4 hash 1 3756  9 threshold 1 3608  
1296 0 0 7 1242 3798 2388 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3862  1 v 1 3799  
1297 0 0 7 1243 3753 2082 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3862  1 v 1 3754  
1298 0 0 7 1244 3753 2082 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3862  1 v 1 3754  
1299 0 0 7 1244 3798 2388 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3862  1 v 1 3799  
1300 0 0 7 1245 3798 2388 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3862  1 v 1 3799  
1301 0 0 4 1246 3758 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3862  1 v 1 3798  
1302 0 0 4 1247 3758 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3862  1 v 1 3753  
1303 0 0 4 1248 3758 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3862  1 v 1 3753  
1304 0 0 4 1248 3758 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3862  1 v 1 3798  
1305 0 0 4 1249 3758 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3862  1 v 1 3798  
1306 0 0 4 1250 3758 0 0 25 // this = other1 * other2 3 4 this 3 3861  6 other1 1 3862  6 other2 1 3862  
1307 0 0 7 1251 3861 3172 0 0 2 4 this 3 3862  5 other 1 3862  
1308 0 0 7 1251 3861 3172 0 0 2 4 this 3 3862  6 scalar 1 3608  
1309 0 0 7 1252 3861 3172 0 0 2 4 this 3 3862  6 scalar 1 3608  
1310 0 0 6 1253 3861 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3861  5 other 1 3862  
1311 0 0 6 1254 3861 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3861  5 other 1 3862  
1312 0 0 6 1255 3861 0 0 10 /**
 *
 */ 2 4 this 3 3861  5 other 1 3862  
1313 0 0 6 1255 3861 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3861  6 scalar 1 3608  
1314 0 0 6 1256 3861 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3861  6 scalar 1 3608  
1315 0 0 4 1257 3758 0 0 10 /**
 *
 */ 2 4 this 3 3861  5 other 1 3862  
1316 0 0 6 1258 3608 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3862  
1317 0 0 4 1259 3758 0 0 10 /**
 *
 */ 2 4 this 3 3861  5 other 1 3862  
1318 0 0 4 1260 3758 0 0 10 /**
 *
 */ 1 4 this 3 3861  
1319 0 0 6 1261 3763 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3861  5 other 1 3862  
1320 0 0 6 1262 3763 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3861  
1321 0 0 6 1263 3763 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3861  5 other 1 3862  
1322 0 0 6 1263 3763 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3861  5 other 1 3866  
1323 0 0 6 1264 3862 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1324 0 0 4 1265 3758 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3861  5 trans 1 3754  
1325 0 0 4 1266 3758 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3861  5 angle 1 3608  
1326 0 0 4 1266 3758 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3861  5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  
1327 0 0 4 1267 3758 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3861  5 scale 1 3754  
1328 0 0 4 1267 3758 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3861  5 scale 1 3799  
1329 0 0 7 1268 3861 3172 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3754  
1330 0 0 7 1268 3861 3172 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3608  2 ty 1 3608  
1331 0 0 7 1269 3861 3172 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3608  
1332 0 0 7 1269 3861 3172 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  
1333 0 0 7 1270 3861 3172 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3754  
1334 0 0 7 1270 3861 3172 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3799  
1335 0 0 7 1270 3861 3172 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3608  2 sy 1 3608  
1336 0 0 7 1270 3861 3172 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3608  2 sy 1 3608  2 sz 1 3608  
1337 0 0 4 1271 3758 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3861  5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  
1338 0 0 7 1272 3861 3172 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  
1339 0 0 4 1273 3758 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3861  5 shear 1 3799  2 cs 5 3627  
1340 0 0 7 1274 3861 3172 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3799  2 cs 5 3627  
1341 0 0 7 1274 3861 3172 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3608  4 shxz 1 3608  4 shyz 1 3608  2 cs 5 3627  
1342 0 0 4 1275 3758 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3861  5 scale 1 3799  5 shear 1 3799  2 cs 5 3627  
1343 0 0 7 1276 3861 3172 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3799  5 shear 1 3799  2 cs 5 3627  
1344 0 0 7 1276 3861 3172 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3608  2 sy 1 3608  2 sz 1 3608  4 shxy 1 3608  4 shxz 1 3608  4 shyz 1 3608  2 cs 5 3627  
1345 0 0 6 1277 3862 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3627  2 to 1 3627  
1346 0 0 6 1278 3763 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3862  5 other 1 3862  
1347 0 0 6 1278 3763 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3862  5 other 1 3862  9 threshold 1 3608  
1348 0 0 4 1279 3758 0 0 10 /**
 *
 */ 2 4 this 3 3862  3 out 1 3766  
1349 0 0 4 1280 3758 0 0 10 /**
 *
 */ 3 4 this 3 3862  3 out 1 3766  12 indent_level 5 3614  
1350 0 0 38 1281 3762 0 0 0 1 4 this 3 3862  
1351 0 0 4 1282 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3862  7 hashgen 1 3764  
1352 0 0 4 1282 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3862  7 hashgen 1 3764  9 threshold 1 3608  
1353 0 0 4 1283 3758 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3862  11 destination 1 3768  
1354 0 0 4 1284 3758 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3861  4 scan 1 3770  
1355 0 0 4 1285 3758 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3862  11 destination 1 3768  
1356 0 0 4 1286 3758 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3861  6 source 1 3770  
1357 0 0 7 1287 3773 0 0 0 0 
1358 0 0 15 1199 3864 3091 0 0 1 6 param0 0 3868  
1359 0 0 4 1196 3758 0 0 10 /**
 *
 */ 3 4 this 3 3864  1 i 1 3614  10 assign_val 1 3608  
1360 0 0 6 1196 3608 0 0 0 2 4 this 3 3868  1 i 1 3614  
1361 0 0 6 1197 3614 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1362 0 0 6 1198 3799 0 0 0 1 4 this 3 3868  
1363 0 0 15 1205 3865 3096 0 0 1 6 param0 0 3870  
1364 0 0 6 1202 3608 0 0 0 2 4 this 3 3870  1 i 1 3614  
1365 0 0 6 1203 3614 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1366 0 0 6 1204 3799 0 0 0 1 4 this 3 3870  
1367 0 0 7 1305 3872 3270 0 10 /**
 *
 */ 0 
1368 0 0 23 1305 3872 3270 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3862  
1369 0 0 23 1305 3872 3270 0 10 /**
 *
 */ 2 6 upper3 1 3862  5 trans 1 3799  
1370 0 0 15 1305 3872 3270 0 10 /**
 *
 */ 1 5 other 1 3866  
1371 0 0 23 1305 3872 3270 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3826  6 param1 0 3826  6 param2 0 3826  6 param3 0 3826  
1372 0 0 23 1305 3872 3270 0 10 /**
 *
 */ 1 5 other 1 3873  
1373 0 0 23 1305 3872 3270 0 10 /**
 *
 */ 16 6 param0 0 3608  6 param1 0 3608  6 param2 0 3608  6 param3 0 3608  6 param4 0 3608  6 param5 0 3608  6 param6 0 3608  6 param7 0 3608  6 param8 0 3608  6 param9 0 3608  7 param10 0 3608  7 param11 0 3608  7 param12 0 3608  7 param13 0 3608  7 param14 0 3608  7 param15 0 3608  
1374 0 0 6 1306 3872 0 0 10 /**
 *
 */ 2 4 this 3 3872  5 other 1 3866  
1375 0 0 6 1306 3872 0 0 10 /**
 *
 */ 2 4 this 3 3872  5 other 1 3873  
1376 0 0 6 1306 3872 0 0 10 /**
 *
 */ 2 4 this 3 3872  10 fill_value 1 3608  
1377 0 0 4 1307 3758 0 0 0 2 4 this 3 3872  4 size 1 3756  
1378 0 0 38 1310 3759 0 0 0 1 4 this 3 3866  
1379 0 0 4 1311 3758 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3872  10 fill_value 1 3608  
1380 0 0 4 1312 3758 0 0 10 /**
 *
 */ 17 4 this 3 3872  3 e00 1 3608  3 e01 1 3608  3 e02 1 3608  3 e03 1 3608  3 e10 1 3608  3 e11 1 3608  3 e12 1 3608  3 e13 1 3608  3 e20 1 3608  3 e21 1 3608  3 e22 1 3608  3 e23 1 3608  3 e30 1 3608  3 e31 1 3608  3 e32 1 3608  3 e33 1 3608  
1381 0 0 4 1313 3758 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3872  6 upper3 1 3862  
1382 0 0 7 1314 3861 3172 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3866  
1383 0 0 7 1315 3875 3179 0 0 2 4 this 3 3872  1 i 1 3614  
1384 0 0 7 1315 3876 3184 0 0 2 4 this 3 3866  1 i 1 3614  
1385 0 0 6 1316 3614 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1386 0 0 4 1317 3758 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3872  3 row 1 3614  1 v 1 3799  
1387 0 0 4 1317 3758 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3872  3 row 1 3614  1 v 1 3826  
1388 0 0 4 1318 3758 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3872  3 col 1 3614  1 v 1 3799  
1389 0 0 4 1318 3758 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3872  3 col 1 3614  1 v 1 3826  
1390 0 0 4 1319 3758 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3866  10 result_vec 1 3825  3 row 1 3614  
1391 0 0 7 1319 3825 2783 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3866  3 row 1 3614  
1392 0 0 7 1320 3825 2783 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3866  3 col 1 3614  
1393 0 0 4 1321 3758 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3866  10 result_vec 1 3798  3 row 1 3614  
1394 0 0 7 1321 3798 2388 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3866  3 row 1 3614  
1395 0 0 7 1327 3798 2388 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3866  3 col 1 3614  
1396 0 0 4 1328 3758 0 0 10 /**
 *
 */ 3 4 this 3 3872  3 row 1 3614  3 col 1 3614  
1397 0 0 6 1328 3608 0 0 0 3 4 this 3 3866  3 row 1 3614  3 col 1 3614  
1398 0 0 6 1329 3763 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3866  
1399 0 0 6 1330 3763 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3866  
1400 0 0 6 1331 3608 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3866  3 row 1 3614  3 col 1 3614  
1401 0 0 4 1332 3758 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3872  3 row 1 3614  3 col 1 3614  5 value 1 3608  
1402 0 0 4 1333 3758 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3866  
1403 0 0 6 1334 3614 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3866  
1404 0 0 4 1335 3758 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3872  
1405 0 0 4 1335 3758 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3866  
1406 0 0 4 1336 3758 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3872  
1407 0 0 4 1336 3758 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3866  
1408 0 0 6 1337 3763 0 0 0 2 4 this 3 3866  5 other 1 3866  
1409 0 0 6 1338 3763 0 0 0 2 4 this 3 3866  5 other 1 3866  
1410 0 0 6 1339 3763 0 0 0 2 4 this 3 3866  5 other 1 3866  
1411 0 0 6 1340 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3866  5 other 1 3866  
1412 0 0 6 1340 3614 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3866  5 other 1 3866  9 threshold 1 3608  
1413 0 0 6 1341 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3866  
1414 0 0 6 1341 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3866  9 threshold 1 3608  
1415 0 0 6 1342 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3866  4 hash 1 3756  
1416 0 0 6 1342 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3866  4 hash 1 3756  9 threshold 1 3608  
1417 0 0 7 1343 3825 2783 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3866  1 v 1 3826  
1418 0 0 7 1344 3798 2388 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3866  1 v 1 3799  
1419 0 0 7 1345 3798 2388 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3866  1 v 1 3799  
1420 0 0 7 1346 3798 2388 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3866  1 v 1 3799  
1421 0 0 7 1347 3798 2388 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3866  1 v 1 3799  
1422 0 0 4 1348 3758 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3866  1 v 1 3825  
1423 0 0 4 1349 3758 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3866  1 v 1 3798  
1424 0 0 4 1350 3758 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3866  1 v 1 3798  
1425 0 0 4 1351 3758 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3866  1 v 1 3798  
1426 0 0 4 1352 3758 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3866  1 v 1 3798  
1427 0 0 4 1353 3758 0 0 25 // this = other1 * other2 3 4 this 3 3872  6 other1 1 3866  6 other2 1 3866  
1428 0 0 7 1354 3872 3270 0 0 2 4 this 3 3866  5 other 1 3866  
1429 0 0 7 1354 3872 3270 0 0 2 4 this 3 3866  6 scalar 1 3608  
1430 0 0 7 1355 3872 3270 0 0 2 4 this 3 3866  6 scalar 1 3608  
1431 0 0 6 1356 3872 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3872  5 other 1 3866  
1432 0 0 6 1357 3872 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3872  5 other 1 3866  
1433 0 0 6 1358 3872 0 0 10 /**
 *
 */ 2 4 this 3 3872  5 other 1 3866  
1434 0 0 6 1358 3872 0 0 10 /**
 *
 */ 2 4 this 3 3872  6 scalar 1 3608  
1435 0 0 6 1359 3872 0 0 10 /**
 *
 */ 2 4 this 3 3872  6 scalar 1 3608  
1436 0 0 4 1360 3758 0 0 10 /**
 *
 */ 2 4 this 3 3872  5 other 1 3866  
1437 0 0 4 1361 3758 0 0 10 /**
 *
 */ 2 4 this 3 3872  5 other 1 3866  
1438 0 0 4 1362 3758 0 0 10 /**
 *
 */ 1 4 this 3 3872  
1439 0 0 6 1363 3763 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3872  5 other 1 3866  
1440 0 0 6 1364 3763 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3872  5 other 1 3866  
1441 0 0 6 1365 3763 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3872  
1442 0 0 4 1366 3758 0 0 48 /**
 * Computes `(*this) += other * weight`.
 */ 3 4 this 3 3872  5 other 1 3866  6 weight 1 3608  
1443 0 0 6 1367 3866 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1444 0 0 6 1368 3866 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1445 0 0 6 1369 3866 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1446 0 0 4 1370 3758 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3872  5 trans 1 3799  
1447 0 0 4 1371 3758 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3872  5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  
1448 0 0 4 1372 3758 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3872  5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  
1449 0 0 4 1373 3758 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3872  5 scale 1 3799  
1450 0 0 4 1374 3758 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3872  5 shear 1 3799  2 cs 5 3627  
1451 0 0 4 1375 3758 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3872  5 scale 1 3799  5 shear 1 3799  2 cs 5 3627  
1452 0 0 7 1376 3872 3270 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3799  
1453 0 0 7 1376 3872 3270 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3608  2 ty 1 3608  2 tz 1 3608  
1454 0 0 7 1377 3872 3270 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  
1455 0 0 7 1378 3872 3270 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3608  4 axis 1 3799  2 cs 5 3627  
1456 0 0 7 1379 3872 3270 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3799  
1457 0 0 7 1379 3872 3270 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3608  
1458 0 0 7 1379 3872 3270 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3608  2 sy 1 3608  2 sz 1 3608  
1459 0 0 7 1380 3872 3270 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3799  2 cs 5 3627  
1460 0 0 7 1380 3872 3270 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3608  4 shxz 1 3608  4 shyz 1 3608  2 cs 5 3627  
1461 0 0 7 1381 3872 3270 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3799  5 shear 1 3799  2 cs 5 3627  
1462 0 0 7 1381 3872 3270 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3608  2 sy 1 3608  2 sz 1 3608  4 shxy 1 3608  4 shxz 1 3608  4 shyz 1 3608  2 cs 5 3627  
1463 0 0 6 1382 3866 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1464 0 0 6 1383 3866 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1465 0 0 6 1384 3866 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3627  2 to 1 3627  
1466 0 0 6 1385 3763 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3866  5 other 1 3866  
1467 0 0 6 1385 3763 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3866  5 other 1 3866  9 threshold 1 3608  
1468 0 0 4 1386 3758 0 0 10 /**
 *
 */ 2 4 this 3 3866  3 out 1 3766  
1469 0 0 4 1387 3758 0 0 10 /**
 *
 */ 3 4 this 3 3866  3 out 1 3766  12 indent_level 5 3614  
1470 0 0 38 1388 3762 0 0 0 1 4 this 3 3866  
1471 0 0 4 1389 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3866  7 hashgen 1 3764  
1472 0 0 4 1389 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3866  7 hashgen 1 3764  5 scale 1 3608  
1473 0 0 4 1390 3758 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3866  11 destination 1 3768  
1474 0 0 4 1391 3758 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3872  4 scan 1 3770  
1475 0 0 4 1392 3758 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3866  11 destination 1 3768  
1476 0 0 4 1393 3758 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3872  6 source 1 3770  
1477 0 0 7 1394 3773 0 0 0 0 
1478 0 0 15 1297 3875 3179 0 0 1 6 param0 0 3877  
1479 0 0 4 1294 3758 0 0 10 /**
 *
 */ 3 4 this 3 3875  1 i 1 3614  10 assign_val 1 3608  
1480 0 0 6 1294 3608 0 0 0 2 4 this 3 3877  1 i 1 3614  
1481 0 0 6 1295 3614 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1482 0 0 6 1296 3826 0 0 0 1 4 this 3 3877  
1483 0 0 15 1303 3876 3184 0 0 1 6 param0 0 3879  
1484 0 0 6 1300 3608 0 0 0 2 4 this 3 3879  1 i 1 3614  
1485 0 0 6 1301 3614 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1486 0 0 6 1302 3826 0 0 0 1 4 this 3 3879  
1487 0 0 7 1398 3881 3280 0 10 /**
 *
 */ 0 
1488 0 0 23 1398 3881 3280 0 10 /**
 *
 */ 1 4 copy 1 3866  
1489 0 0 15 1398 3881 3280 0 10 /**
 *
 */ 1 4 copy 1 3873  
1490 0 0 23 1398 3881 3280 0 10 /**
 *
 */ 16 3 e00 1 3608  3 e01 1 3608  3 e02 1 3608  3 e03 1 3608  3 e10 1 3608  3 e11 1 3608  3 e12 1 3608  3 e13 1 3608  3 e20 1 3608  3 e21 1 3608  3 e22 1 3608  3 e23 1 3608  3 e30 1 3608  3 e31 1 3608  3 e32 1 3608  3 e33 1 3608  
1491 0 0 6 1399 3881 0 0 10 /**
 *
 */ 2 4 this 3 3881  4 copy 1 3866  
1492 0 0 6 1399 3881 0 0 10 /**
 *
 */ 2 4 this 3 3881  4 copy 1 3873  
1493 0 0 4 1400 3758 0 0 10 /**
 *
 */ 17 4 this 3 3881  3 e00 1 3608  3 e01 1 3608  3 e02 1 3608  3 e03 1 3608  3 e10 1 3608  3 e11 1 3608  3 e12 1 3608  3 e13 1 3608  3 e20 1 3608  3 e21 1 3608  3 e22 1 3608  3 e23 1 3608  3 e30 1 3608  3 e31 1 3608  3 e32 1 3608  3 e33 1 3608  
1494 0 0 4 1401 3758 0 0 10 /**
 *
 */ 3 4 this 3 3881  3 row 1 3614  3 col 1 3614  
1495 0 0 6 1401 3608 0 0 0 3 4 this 3 3873  3 row 1 3614  3 col 1 3614  
1496 0 0 4 1402 3758 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3873  
1497 0 0 6 1403 3614 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3873  
1498 0 0 6 1404 3763 0 0 0 2 4 this 3 3873  5 other 1 3873  
1499 0 0 6 1405 3763 0 0 0 2 4 this 3 3873  5 other 1 3873  
1500 0 0 7 1406 3773 0 0 0 0 
1501 0 0 7 1422 3882 3366 0 10 /**
 *
 */ 0 
1502 0 0 15 1422 3882 3366 0 10 /**
 *
 */ 1 5 other 1 3883  
1503 0 0 23 1422 3882 3366 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3802  6 param1 0 3802  6 param2 0 3802  
1504 0 0 23 1422 3882 3366 0 10 /**
 *
 */ 9 6 param0 0 3611  6 param1 0 3611  6 param2 0 3611  6 param3 0 3611  6 param4 0 3611  6 param5 0 3611  6 param6 0 3611  6 param7 0 3611  6 param8 0 3611  
1505 0 0 6 1423 3882 0 0 10 /**
 *
 */ 2 4 this 3 3882  5 other 1 3883  
1506 0 0 6 1423 3882 0 0 10 /**
 *
 */ 2 4 this 3 3882  10 fill_value 1 3611  
1507 0 0 4 1424 3758 0 0 0 2 4 this 3 3882  4 size 1 3756  
1508 0 0 38 1427 3759 0 0 0 1 4 this 3 3883  
1509 0 0 4 1428 3758 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3882  10 fill_value 1 3611  
1510 0 0 4 1429 3758 0 0 10 /**
 *
 */ 10 4 this 3 3882  3 e00 1 3611  3 e01 1 3611  3 e02 1 3611  3 e10 1 3611  3 e11 1 3611  3 e12 1 3611  3 e20 1 3611  3 e21 1 3611  3 e22 1 3611  
1511 0 0 7 1430 3885 3285 0 0 2 4 this 3 3882  1 i 1 3614  
1512 0 0 7 1430 3886 3290 0 0 2 4 this 3 3883  1 i 1 3614  
1513 0 0 6 1431 3614 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1514 0 0 4 1432 3758 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3882  3 row 1 3614  1 v 1 3775  
1515 0 0 4 1432 3758 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3882  3 row 1 3614  1 v 1 3802  
1516 0 0 4 1433 3758 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3882  3 col 1 3614  1 v 1 3775  
1517 0 0 4 1433 3758 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3882  3 col 1 3614  1 v 1 3802  
1518 0 0 4 1434 3758 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3883  10 result_vec 1 3801  3 row 1 3614  
1519 0 0 7 1434 3801 2466 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3883  3 row 1 3614  
1520 0 0 7 1435 3801 2466 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3883  3 col 1 3614  
1521 0 0 7 1440 3774 2150 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3883  3 row 1 3614  
1522 0 0 7 1441 3774 2150 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3883  3 col 1 3614  
1523 0 0 4 1444 3758 0 0 10 /**
 *
 */ 3 4 this 3 3882  3 row 1 3614  3 col 1 3614  
1524 0 0 6 1444 3611 0 0 0 3 4 this 3 3883  3 row 1 3614  3 col 1 3614  
1525 0 0 6 1445 3763 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3883  
1526 0 0 6 1446 3763 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3883  
1527 0 0 6 1447 3611 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3883  3 row 1 3614  3 col 1 3614  
1528 0 0 4 1448 3758 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3882  3 row 1 3614  3 col 1 3614  5 value 1 3611  
1529 0 0 4 1449 3758 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3883  
1530 0 0 6 1450 3614 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3883  
1531 0 0 6 1451 3763 0 0 0 2 4 this 3 3883  5 other 1 3883  
1532 0 0 6 1452 3763 0 0 0 2 4 this 3 3883  5 other 1 3883  
1533 0 0 6 1453 3763 0 0 0 2 4 this 3 3883  5 other 1 3883  
1534 0 0 6 1454 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3883  5 other 1 3883  
1535 0 0 6 1454 3614 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3883  5 other 1 3883  9 threshold 1 3611  
1536 0 0 6 1455 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3883  
1537 0 0 6 1455 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3883  9 threshold 1 3611  
1538 0 0 6 1456 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3883  4 hash 1 3756  
1539 0 0 6 1456 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3883  4 hash 1 3756  9 threshold 1 3611  
1540 0 0 7 1457 3801 2466 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3883  1 v 1 3802  
1541 0 0 7 1458 3774 2150 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3883  1 v 1 3775  
1542 0 0 7 1459 3774 2150 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3883  1 v 1 3775  
1543 0 0 7 1459 3801 2466 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3883  1 v 1 3802  
1544 0 0 7 1460 3801 2466 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3883  1 v 1 3802  
1545 0 0 4 1461 3758 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3883  1 v 1 3801  
1546 0 0 4 1462 3758 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3883  1 v 1 3774  
1547 0 0 4 1463 3758 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3883  1 v 1 3774  
1548 0 0 4 1463 3758 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3883  1 v 1 3801  
1549 0 0 4 1464 3758 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3883  1 v 1 3801  
1550 0 0 4 1465 3758 0 0 25 // this = other1 * other2 3 4 this 3 3882  6 other1 1 3883  6 other2 1 3883  
1551 0 0 7 1466 3882 3366 0 0 2 4 this 3 3883  5 other 1 3883  
1552 0 0 7 1466 3882 3366 0 0 2 4 this 3 3883  6 scalar 1 3611  
1553 0 0 7 1467 3882 3366 0 0 2 4 this 3 3883  6 scalar 1 3611  
1554 0 0 6 1468 3882 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3882  5 other 1 3883  
1555 0 0 6 1469 3882 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3882  5 other 1 3883  
1556 0 0 6 1470 3882 0 0 10 /**
 *
 */ 2 4 this 3 3882  5 other 1 3883  
1557 0 0 6 1470 3882 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3882  6 scalar 1 3611  
1558 0 0 6 1471 3882 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3882  6 scalar 1 3611  
1559 0 0 4 1472 3758 0 0 10 /**
 *
 */ 2 4 this 3 3882  5 other 1 3883  
1560 0 0 6 1473 3611 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3883  
1561 0 0 4 1474 3758 0 0 10 /**
 *
 */ 2 4 this 3 3882  5 other 1 3883  
1562 0 0 4 1475 3758 0 0 10 /**
 *
 */ 1 4 this 3 3882  
1563 0 0 6 1476 3763 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3882  5 other 1 3883  
1564 0 0 6 1477 3763 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3882  
1565 0 0 6 1478 3763 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3882  5 other 1 3883  
1566 0 0 6 1478 3763 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3882  5 other 1 3887  
1567 0 0 6 1479 3883 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1568 0 0 4 1480 3758 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3882  5 trans 1 3775  
1569 0 0 4 1481 3758 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3882  5 angle 1 3611  
1570 0 0 4 1481 3758 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3882  5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  
1571 0 0 4 1482 3758 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3882  5 scale 1 3775  
1572 0 0 4 1482 3758 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3882  5 scale 1 3802  
1573 0 0 7 1483 3882 3366 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3775  
1574 0 0 7 1483 3882 3366 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3611  2 ty 1 3611  
1575 0 0 7 1484 3882 3366 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3611  
1576 0 0 7 1484 3882 3366 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  
1577 0 0 7 1485 3882 3366 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3775  
1578 0 0 7 1485 3882 3366 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3802  
1579 0 0 7 1485 3882 3366 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3611  2 sy 1 3611  
1580 0 0 7 1485 3882 3366 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3611  2 sy 1 3611  2 sz 1 3611  
1581 0 0 4 1486 3758 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3882  5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  
1582 0 0 7 1487 3882 3366 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  
1583 0 0 4 1488 3758 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3882  5 shear 1 3802  2 cs 5 3627  
1584 0 0 7 1489 3882 3366 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3802  2 cs 5 3627  
1585 0 0 7 1489 3882 3366 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3611  4 shxz 1 3611  4 shyz 1 3611  2 cs 5 3627  
1586 0 0 4 1490 3758 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3882  5 scale 1 3802  5 shear 1 3802  2 cs 5 3627  
1587 0 0 7 1491 3882 3366 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3802  5 shear 1 3802  2 cs 5 3627  
1588 0 0 7 1491 3882 3366 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3611  2 sy 1 3611  2 sz 1 3611  4 shxy 1 3611  4 shxz 1 3611  4 shyz 1 3611  2 cs 5 3627  
1589 0 0 6 1492 3883 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3627  2 to 1 3627  
1590 0 0 6 1493 3763 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3883  5 other 1 3883  
1591 0 0 6 1493 3763 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3883  5 other 1 3883  9 threshold 1 3611  
1592 0 0 4 1494 3758 0 0 10 /**
 *
 */ 2 4 this 3 3883  3 out 1 3766  
1593 0 0 4 1495 3758 0 0 10 /**
 *
 */ 3 4 this 3 3883  3 out 1 3766  12 indent_level 5 3614  
1594 0 0 38 1496 3762 0 0 0 1 4 this 3 3883  
1595 0 0 4 1497 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3883  7 hashgen 1 3764  
1596 0 0 4 1497 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3883  7 hashgen 1 3764  9 threshold 1 3611  
1597 0 0 4 1498 3758 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3883  11 destination 1 3768  
1598 0 0 4 1499 3758 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3882  4 scan 1 3770  
1599 0 0 4 1500 3758 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3883  11 destination 1 3768  
1600 0 0 4 1501 3758 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3882  6 source 1 3770  
1601 0 0 7 1502 3773 0 0 0 0 
1602 0 0 15 1414 3885 3285 0 0 1 6 param0 0 3889  
1603 0 0 4 1411 3758 0 0 10 /**
 *
 */ 3 4 this 3 3885  1 i 1 3614  10 assign_val 1 3611  
1604 0 0 6 1411 3611 0 0 0 2 4 this 3 3889  1 i 1 3614  
1605 0 0 6 1412 3614 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1606 0 0 6 1413 3802 0 0 0 1 4 this 3 3889  
1607 0 0 15 1420 3886 3290 0 0 1 6 param0 0 3891  
1608 0 0 6 1417 3611 0 0 0 2 4 this 3 3891  1 i 1 3614  
1609 0 0 6 1418 3614 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1610 0 0 6 1419 3802 0 0 0 1 4 this 3 3891  
1611 0 0 7 1518 3893 3462 0 10 /**
 *
 */ 0 
1612 0 0 23 1518 3893 3462 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3883  
1613 0 0 23 1518 3893 3462 0 10 /**
 *
 */ 2 6 upper3 1 3883  5 trans 1 3802  
1614 0 0 15 1518 3893 3462 0 10 /**
 *
 */ 1 5 other 1 3887  
1615 0 0 23 1518 3893 3462 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3832  6 param1 0 3832  6 param2 0 3832  6 param3 0 3832  
1616 0 0 23 1518 3893 3462 0 10 /**
 *
 */ 1 5 other 1 3894  
1617 0 0 23 1518 3893 3462 0 10 /**
 *
 */ 16 6 param0 0 3611  6 param1 0 3611  6 param2 0 3611  6 param3 0 3611  6 param4 0 3611  6 param5 0 3611  6 param6 0 3611  6 param7 0 3611  6 param8 0 3611  6 param9 0 3611  7 param10 0 3611  7 param11 0 3611  7 param12 0 3611  7 param13 0 3611  7 param14 0 3611  7 param15 0 3611  
1618 0 0 6 1519 3893 0 0 10 /**
 *
 */ 2 4 this 3 3893  5 other 1 3887  
1619 0 0 6 1519 3893 0 0 10 /**
 *
 */ 2 4 this 3 3893  5 other 1 3894  
1620 0 0 6 1519 3893 0 0 10 /**
 *
 */ 2 4 this 3 3893  10 fill_value 1 3611  
1621 0 0 4 1520 3758 0 0 0 2 4 this 3 3893  4 size 1 3756  
1622 0 0 38 1523 3759 0 0 0 1 4 this 3 3887  
1623 0 0 4 1524 3758 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3893  10 fill_value 1 3611  
1624 0 0 4 1525 3758 0 0 10 /**
 *
 */ 17 4 this 3 3893  3 e00 1 3611  3 e01 1 3611  3 e02 1 3611  3 e03 1 3611  3 e10 1 3611  3 e11 1 3611  3 e12 1 3611  3 e13 1 3611  3 e20 1 3611  3 e21 1 3611  3 e22 1 3611  3 e23 1 3611  3 e30 1 3611  3 e31 1 3611  3 e32 1 3611  3 e33 1 3611  
1625 0 0 4 1526 3758 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3893  6 upper3 1 3883  
1626 0 0 7 1527 3882 3366 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3887  
1627 0 0 7 1528 3896 3371 0 0 2 4 this 3 3893  1 i 1 3614  
1628 0 0 7 1528 3897 3376 0 0 2 4 this 3 3887  1 i 1 3614  
1629 0 0 6 1529 3614 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1630 0 0 4 1530 3758 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3893  3 row 1 3614  1 v 1 3802  
1631 0 0 4 1530 3758 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3893  3 row 1 3614  1 v 1 3832  
1632 0 0 4 1531 3758 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3893  3 col 1 3614  1 v 1 3802  
1633 0 0 4 1531 3758 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3893  3 col 1 3614  1 v 1 3832  
1634 0 0 4 1532 3758 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3887  10 result_vec 1 3831  3 row 1 3614  
1635 0 0 7 1532 3831 2873 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3887  3 row 1 3614  
1636 0 0 7 1533 3831 2873 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3887  3 col 1 3614  
1637 0 0 4 1534 3758 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3887  10 result_vec 1 3801  3 row 1 3614  
1638 0 0 7 1534 3801 2466 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3887  3 row 1 3614  
1639 0 0 7 1540 3801 2466 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3887  3 col 1 3614  
1640 0 0 4 1541 3758 0 0 10 /**
 *
 */ 3 4 this 3 3893  3 row 1 3614  3 col 1 3614  
1641 0 0 6 1541 3611 0 0 0 3 4 this 3 3887  3 row 1 3614  3 col 1 3614  
1642 0 0 6 1542 3763 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3887  
1643 0 0 6 1543 3763 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3887  
1644 0 0 6 1544 3611 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3887  3 row 1 3614  3 col 1 3614  
1645 0 0 4 1545 3758 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3893  3 row 1 3614  3 col 1 3614  5 value 1 3611  
1646 0 0 4 1546 3758 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3887  
1647 0 0 6 1547 3614 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3887  
1648 0 0 4 1548 3758 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3893  
1649 0 0 4 1548 3758 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3887  
1650 0 0 4 1549 3758 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3893  
1651 0 0 4 1549 3758 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3887  
1652 0 0 6 1550 3763 0 0 0 2 4 this 3 3887  5 other 1 3887  
1653 0 0 6 1551 3763 0 0 0 2 4 this 3 3887  5 other 1 3887  
1654 0 0 6 1552 3763 0 0 0 2 4 this 3 3887  5 other 1 3887  
1655 0 0 6 1553 3614 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3887  5 other 1 3887  
1656 0 0 6 1553 3614 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3887  5 other 1 3887  9 threshold 1 3611  
1657 0 0 6 1554 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3887  
1658 0 0 6 1554 3756 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3887  9 threshold 1 3611  
1659 0 0 6 1555 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3887  4 hash 1 3756  
1660 0 0 6 1555 3756 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3887  4 hash 1 3756  9 threshold 1 3611  
1661 0 0 7 1556 3831 2873 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3887  1 v 1 3832  
1662 0 0 7 1557 3801 2466 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3887  1 v 1 3802  
1663 0 0 7 1558 3801 2466 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3887  1 v 1 3802  
1664 0 0 7 1559 3801 2466 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3887  1 v 1 3802  
1665 0 0 7 1560 3801 2466 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3887  1 v 1 3802  
1666 0 0 4 1561 3758 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3887  1 v 1 3831  
1667 0 0 4 1562 3758 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3887  1 v 1 3801  
1668 0 0 4 1563 3758 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3887  1 v 1 3801  
1669 0 0 4 1564 3758 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3887  1 v 1 3801  
1670 0 0 4 1565 3758 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3887  1 v 1 3801  
1671 0 0 4 1566 3758 0 0 25 // this = other1 * other2 3 4 this 3 3893  6 other1 1 3887  6 other2 1 3887  
1672 0 0 7 1567 3893 3462 0 0 2 4 this 3 3887  5 other 1 3887  
1673 0 0 7 1567 3893 3462 0 0 2 4 this 3 3887  6 scalar 1 3611  
1674 0 0 7 1568 3893 3462 0 0 2 4 this 3 3887  6 scalar 1 3611  
1675 0 0 6 1569 3893 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3893  5 other 1 3887  
1676 0 0 6 1570 3893 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3893  5 other 1 3887  
1677 0 0 6 1571 3893 0 0 10 /**
 *
 */ 2 4 this 3 3893  5 other 1 3887  
1678 0 0 6 1571 3893 0 0 10 /**
 *
 */ 2 4 this 3 3893  6 scalar 1 3611  
1679 0 0 6 1572 3893 0 0 10 /**
 *
 */ 2 4 this 3 3893  6 scalar 1 3611  
1680 0 0 4 1573 3758 0 0 10 /**
 *
 */ 2 4 this 3 3893  5 other 1 3887  
1681 0 0 4 1574 3758 0 0 10 /**
 *
 */ 2 4 this 3 3893  5 other 1 3887  
1682 0 0 4 1575 3758 0 0 10 /**
 *
 */ 1 4 this 3 3893  
1683 0 0 6 1576 3763 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3893  5 other 1 3887  
1684 0 0 6 1577 3763 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3893  5 other 1 3887  
1685 0 0 6 1578 3763 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3893  
1686 0 0 4 1579 3758 0 0 48 /**
 * Computes `(*this) += other * weight`.
 */ 3 4 this 3 3893  5 other 1 3887  6 weight 1 3611  
1687 0 0 6 1580 3887 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1688 0 0 6 1581 3887 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1689 0 0 6 1582 3887 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1690 0 0 4 1583 3758 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3893  5 trans 1 3802  
1691 0 0 4 1584 3758 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3893  5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  
1692 0 0 4 1585 3758 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3893  5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  
1693 0 0 4 1586 3758 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3893  5 scale 1 3802  
1694 0 0 4 1587 3758 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3893  5 shear 1 3802  2 cs 5 3627  
1695 0 0 4 1588 3758 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3893  5 scale 1 3802  5 shear 1 3802  2 cs 5 3627  
1696 0 0 7 1589 3893 3462 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3802  
1697 0 0 7 1589 3893 3462 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3611  2 ty 1 3611  2 tz 1 3611  
1698 0 0 7 1590 3893 3462 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  
1699 0 0 7 1591 3893 3462 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3611  4 axis 1 3802  2 cs 5 3627  
1700 0 0 7 1592 3893 3462 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3802  
1701 0 0 7 1592 3893 3462 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3611  
1702 0 0 7 1592 3893 3462 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3611  2 sy 1 3611  2 sz 1 3611  
1703 0 0 7 1593 3893 3462 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3802  2 cs 5 3627  
1704 0 0 7 1593 3893 3462 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3611  4 shxz 1 3611  4 shyz 1 3611  2 cs 5 3627  
1705 0 0 7 1594 3893 3462 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3802  5 shear 1 3802  2 cs 5 3627  
1706 0 0 7 1594 3893 3462 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3611  2 sy 1 3611  2 sz 1 3611  4 shxy 1 3611  4 shxz 1 3611  4 shyz 1 3611  2 cs 5 3627  
1707 0 0 6 1595 3887 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1708 0 0 6 1596 3887 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1709 0 0 6 1597 3887 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3627  2 to 1 3627  
1710 0 0 6 1598 3763 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3887  5 other 1 3887  
1711 0 0 6 1598 3763 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3887  5 other 1 3887  9 threshold 1 3611  
1712 0 0 4 1599 3758 0 0 10 /**
 *
 */ 2 4 this 3 3887  3 out 1 3766  
1713 0 0 4 1600 3758 0 0 10 /**
 *
 */ 3 4 this 3 3887  3 out 1 3766  12 indent_level 5 3614  
1714 0 0 38 1601 3762 0 0 0 1 4 this 3 3887  
1715 0 0 4 1602 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3887  7 hashgen 1 3764  
1716 0 0 4 1602 3758 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3887  7 hashgen 1 3764  5 scale 1 3611  
1717 0 0 4 1603 3758 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3887  11 destination 1 3768  
1718 0 0 4 1604 3758 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3893  4 scan 1 3770  
1719 0 0 4 1605 3758 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3887  11 destination 1 3768  
1720 0 0 4 1606 3758 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3893  6 source 1 3770  
1721 0 0 7 1607 3773 0 0 0 0 
1722 0 0 15 1510 3896 3371 0 0 1 6 param0 0 3898  
1723 0 0 4 1507 3758 0 0 10 /**
 *
 */ 3 4 this 3 3896  1 i 1 3614  10 assign_val 1 3611  
1724 0 0 6 1507 3611 0 0 0 2 4 this 3 3898  1 i 1 3614  
1725 0 0 6 1508 3614 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1726 0 0 6 1509 3832 0 0 0 1 4 this 3 3898  
1727 0 0 15 1516 3897 3376 0 0 1 6 param0 0 3900  
1728 0 0 6 1513 3611 0 0 0 2 4 this 3 3900  1 i 1 3614  
1729 0 0 6 1514 3614 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1730 0 0 6 1515 3832 0 0 0 1 4 this 3 3900  
1731 0 0 7 1611 3902 3472 0 10 /**
 *
 */ 0 
1732 0 0 23 1611 3902 3472 0 10 /**
 *
 */ 1 4 copy 1 3887  
1733 0 0 15 1611 3902 3472 0 10 /**
 *
 */ 1 4 copy 1 3894  
1734 0 0 23 1611 3902 3472 0 10 /**
 *
 */ 16 3 e00 1 3611  3 e01 1 3611  3 e02 1 3611  3 e03 1 3611  3 e10 1 3611  3 e11 1 3611  3 e12 1 3611  3 e13 1 3611  3 e20 1 3611  3 e21 1 3611  3 e22 1 3611  3 e23 1 3611  3 e30 1 3611  3 e31 1 3611  3 e32 1 3611  3 e33 1 3611  
1735 0 0 6 1612 3902 0 0 10 /**
 *
 */ 2 4 this 3 3902  4 copy 1 3887  
1736 0 0 6 1612 3902 0 0 10 /**
 *
 */ 2 4 this 3 3902  4 copy 1 3894  
1737 0 0 4 1613 3758 0 0 10 /**
 *
 */ 17 4 this 3 3902  3 e00 1 3611  3 e01 1 3611  3 e02 1 3611  3 e03 1 3611  3 e10 1 3611  3 e11 1 3611  3 e12 1 3611  3 e13 1 3611  3 e20 1 3611  3 e21 1 3611  3 e22 1 3611  3 e23 1 3611  3 e30 1 3611  3 e31 1 3611  3 e32 1 3611  3 e33 1 3611  
1738 0 0 4 1614 3758 0 0 10 /**
 *
 */ 3 4 this 3 3902  3 row 1 3614  3 col 1 3614  
1739 0 0 6 1614 3611 0 0 0 3 4 this 3 3894  3 row 1 3614  3 col 1 3614  
1740 0 0 4 1615 3758 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3894  
1741 0 0 6 1616 3614 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3894  
1742 0 0 6 1617 3763 0 0 0 2 4 this 3 3894  5 other 1 3894  
1743 0 0 6 1618 3763 0 0 0 2 4 this 3 3894  5 other 1 3894  
1744 0 0 7 1619 3773 0 0 0 0 
1745 0 0 7 1630 3903 3529 0 10 /**
 *
 */ 0 
1746 0 0 15 1630 3903 3529 0 0 1 6 param0 0 3904  
1747 0 0 23 1630 3903 3529 0 10 /**
 *
 */ 1 4 copy 1 3826  
1748 0 0 23 1630 3903 3529 0 10 /**
 *
 */ 2 1 r 1 3608  4 copy 1 3799  
1749 0 0 23 1630 3903 3529 0 10 /**
 *
 */ 4 1 r 1 3608  1 i 1 3608  1 j 1 3608  1 k 1 3608  
1750 0 0 7 1631 3903 3529 0 10 /**
 *
 */ 1 1 v 1 3808  
1751 0 0 7 1632 3903 3529 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3904  
1752 0 0 7 1633 3798 2388 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3904  1 v 1 3799  
1753 0 0 7 1633 3825 2783 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3904  1 v 1 3826  
1754 0 0 7 1634 3903 3529 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3904  3 rhs 1 3904  
1755 0 0 7 1635 3903 3529 0 0 1 4 this 3 3904  
1756 0 0 7 1636 3903 3529 0 0 2 4 this 3 3904  5 other 1 3904  
1757 0 0 7 1637 3903 3529 0 0 2 4 this 3 3904  5 other 1 3904  
1758 0 0 6 1638 3608 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3904  5 other 1 3904  
1759 0 0 6 1639 3608 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3904  5 other 1 3904  
1760 0 0 7 1640 3861 3172 0 0 2 4 this 3 3903  6 param0 0 3862  
1761 0 0 7 1640 3872 3270 0 0 2 4 this 3 3903  6 param0 0 3866  
1762 0 0 7 1640 3903 3529 0 0 2 4 this 3 3904  6 param0 0 3904  
1763 0 0 7 1640 3903 3529 0 0 2 4 this 3 3904  6 scalar 1 3608  
1764 0 0 7 1641 3903 3529 0 0 2 4 this 3 3904  6 scalar 1 3608  
1765 0 0 6 1642 3903 0 0 10 /**
 *
 */ 2 4 this 3 3903  6 param0 0 3904  
1766 0 0 7 1643 3903 3529 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 3904  6 param0 0 3608  
1767 0 0 6 1644 3763 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3904  5 other 1 3904  
1768 0 0 6 1644 3763 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3904  5 other 1 3904  9 threshold 1 3608  
1769 0 0 6 1645 3763 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3904  5 other 1 3904  
1770 0 0 6 1646 3763 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3904  5 other 1 3904  9 threshold 1 3608  
1771 0 0 4 1647 3758 0 0 10 /**
 *
 */ 2 4 this 3 3904  6 param0 0 3766  
1772 0 0 4 1648 3758 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3904  1 m 1 3861  
1773 0 0 4 1648 3758 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3904  1 m 1 3872  
1774 0 0 4 1649 3758 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3903  1 m 1 3862  
1775 0 0 4 1649 3758 0 0 10 /**
 *
 */ 2 4 this 3 3903  1 m 1 3866  
1776 0 0 4 1650 3758 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3903  3 hpr 1 3799  2 cs 5 3627  
1777 0 0 7 1651 3798 2388 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3904  2 cs 5 3627  
1778 0 0 7 1652 3807 2577 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3904  
1779 0 0 7 1653 3807 2577 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3904  
1780 0 0 6 1654 3608 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3904  
1781 0 0 6 1655 3608 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3904  
1782 0 0 4 1656 3758 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3903  9 angle_rad 1 3608  4 axis 1 3808  
1783 0 0 4 1657 3758 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3903  9 angle_deg 1 3608  4 axis 1 3808  
1784 0 0 7 1658 3807 2577 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3904  2 cs 5 3627  
1785 0 0 7 1659 3807 2577 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3904  2 cs 5 3627  
1786 0 0 7 1660 3807 2577 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3904  2 cs 5 3627  
1787 0 0 6 1661 3608 0 0 10 /**
 *
 */ 1 4 this 3 3904  
1788 0 0 6 1662 3608 0 0 10 /**
 *
 */ 1 4 this 3 3904  
1789 0 0 6 1663 3608 0 0 10 /**
 *
 */ 1 4 this 3 3904  
1790 0 0 6 1664 3608 0 0 10 /**
 *
 */ 1 4 this 3 3904  
1791 0 0 4 1665 3758 0 0 10 /**
 *
 */ 2 4 this 3 3903  1 r 1 3608  
1792 0 0 4 1666 3758 0 0 10 /**
 *
 */ 2 4 this 3 3903  1 i 1 3608  
1793 0 0 4 1667 3758 0 0 10 /**
 *
 */ 2 4 this 3 3903  1 j 1 3608  
1794 0 0 4 1668 3758 0 0 10 /**
 *
 */ 2 4 this 3 3903  1 k 1 3608  
1795 0 0 6 1669 3763 0 0 10 /**
 *
 */ 1 4 this 3 3903  
1796 0 0 6 1670 3763 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3903  5 other 1 3904  
1797 0 0 6 1671 3763 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3903  
1798 0 0 6 1672 3763 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3903  5 other 1 3904  
1799 0 0 6 1673 3763 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3903  
1800 0 0 6 1674 3763 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3904  
1801 0 0 6 1675 3763 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3904  9 tolerance 1 3608  
1802 0 0 6 1676 3904 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1803 0 0 7 1677 3773 0 0 0 0 
1804 0 0 7 1680 3906 3578 0 10 /**
 *
 */ 0 
1805 0 0 15 1680 3906 3578 0 0 1 6 param0 0 3907  
1806 0 0 23 1680 3906 3578 0 10 /**
 *
 */ 1 4 copy 1 3832  
1807 0 0 23 1680 3906 3578 0 10 /**
 *
 */ 2 1 r 1 3611  4 copy 1 3802  
1808 0 0 23 1680 3906 3578 0 10 /**
 *
 */ 4 1 r 1 3611  1 i 1 3611  1 j 1 3611  1 k 1 3611  
1809 0 0 7 1681 3906 3578 0 10 /**
 *
 */ 1 1 v 1 3811  
1810 0 0 7 1682 3906 3578 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3907  
1811 0 0 7 1683 3801 2466 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3907  1 v 1 3802  
1812 0 0 7 1683 3831 2873 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3907  1 v 1 3832  
1813 0 0 7 1684 3906 3578 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3907  3 rhs 1 3907  
1814 0 0 7 1685 3906 3578 0 0 1 4 this 3 3907  
1815 0 0 7 1686 3906 3578 0 0 2 4 this 3 3907  5 other 1 3907  
1816 0 0 7 1687 3906 3578 0 0 2 4 this 3 3907  5 other 1 3907  
1817 0 0 6 1688 3611 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3907  5 other 1 3907  
1818 0 0 6 1689 3611 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3907  5 other 1 3907  
1819 0 0 7 1690 3882 3366 0 0 2 4 this 3 3906  6 param0 0 3883  
1820 0 0 7 1690 3893 3462 0 0 2 4 this 3 3906  6 param0 0 3887  
1821 0 0 7 1690 3906 3578 0 0 2 4 this 3 3907  6 param0 0 3907  
1822 0 0 7 1690 3906 3578 0 0 2 4 this 3 3907  6 scalar 1 3611  
1823 0 0 7 1691 3906 3578 0 0 2 4 this 3 3907  6 scalar 1 3611  
1824 0 0 6 1692 3906 0 0 10 /**
 *
 */ 2 4 this 3 3906  6 param0 0 3907  
1825 0 0 7 1693 3906 3578 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 3907  6 param0 0 3611  
1826 0 0 6 1694 3763 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3907  5 other 1 3907  
1827 0 0 6 1694 3763 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3907  5 other 1 3907  9 threshold 1 3611  
1828 0 0 6 1695 3763 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3907  5 other 1 3907  
1829 0 0 6 1696 3763 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3907  5 other 1 3907  9 threshold 1 3611  
1830 0 0 4 1697 3758 0 0 10 /**
 *
 */ 2 4 this 3 3907  6 param0 0 3766  
1831 0 0 4 1698 3758 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3907  1 m 1 3882  
1832 0 0 4 1698 3758 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3907  1 m 1 3893  
1833 0 0 4 1699 3758 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3906  1 m 1 3883  
1834 0 0 4 1699 3758 0 0 10 /**
 *
 */ 2 4 this 3 3906  1 m 1 3887  
1835 0 0 4 1700 3758 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3906  3 hpr 1 3802  2 cs 5 3627  
1836 0 0 7 1701 3801 2466 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3907  2 cs 5 3627  
1837 0 0 7 1702 3810 2611 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3907  
1838 0 0 7 1703 3810 2611 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3907  
1839 0 0 6 1704 3611 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3907  
1840 0 0 6 1705 3611 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3907  
1841 0 0 4 1706 3758 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3906  9 angle_rad 1 3611  4 axis 1 3811  
1842 0 0 4 1707 3758 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3906  9 angle_deg 1 3611  4 axis 1 3811  
1843 0 0 7 1708 3810 2611 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3907  2 cs 5 3627  
1844 0 0 7 1709 3810 2611 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3907  2 cs 5 3627  
1845 0 0 7 1710 3810 2611 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3907  2 cs 5 3627  
1846 0 0 6 1711 3611 0 0 10 /**
 *
 */ 1 4 this 3 3907  
1847 0 0 6 1712 3611 0 0 10 /**
 *
 */ 1 4 this 3 3907  
1848 0 0 6 1713 3611 0 0 10 /**
 *
 */ 1 4 this 3 3907  
1849 0 0 6 1714 3611 0 0 10 /**
 *
 */ 1 4 this 3 3907  
1850 0 0 4 1715 3758 0 0 10 /**
 *
 */ 2 4 this 3 3906  1 r 1 3611  
1851 0 0 4 1716 3758 0 0 10 /**
 *
 */ 2 4 this 3 3906  1 i 1 3611  
1852 0 0 4 1717 3758 0 0 10 /**
 *
 */ 2 4 this 3 3906  1 j 1 3611  
1853 0 0 4 1718 3758 0 0 10 /**
 *
 */ 2 4 this 3 3906  1 k 1 3611  
1854 0 0 6 1719 3763 0 0 10 /**
 *
 */ 1 4 this 3 3906  
1855 0 0 6 1720 3763 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3906  5 other 1 3907  
1856 0 0 6 1721 3763 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3906  
1857 0 0 6 1722 3763 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3906  5 other 1 3907  
1858 0 0 6 1723 3763 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3906  
1859 0 0 6 1724 3763 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3907  
1860 0 0 6 1725 3763 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3907  9 tolerance 1 3611  
1861 0 0 6 1726 3907 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1862 0 0 7 1727 3773 0 0 0 0 
1863 0 0 7 1730 3909 3583 0 10 /**
 *
 */ 0 
1864 0 0 23 1730 3909 3583 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3862  
1865 0 0 23 1730 3909 3583 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3866  
1866 0 0 23 1730 3909 3583 0 10 /**
 *
 */ 1 1 c 1 3904  
1867 0 0 15 1730 3909 3583 0 0 1 6 param0 0 3910  
1868 0 0 23 1730 3909 3583 0 10 /**
 *
 */ 1 4 copy 1 3826  
1869 0 0 23 1730 3909 3583 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3808  5 angle 1 3608  
1870 0 0 23 1730 3909 3583 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3608  1 p 1 3608  1 r 1 3608  
1871 0 0 23 1730 3909 3583 0 10 /**
 *
 */ 4 1 r 1 3608  1 i 1 3608  1 j 1 3608  1 k 1 3608  
1872 0 0 7 1731 3903 3529 0 0 2 4 this 3 3910  5 other 1 3904  
1873 0 0 7 1731 3909 3583 0 0 2 4 this 3 3910  5 other 1 3910  
1874 0 0 7 1731 3909 3583 0 0 2 4 this 3 3910  6 scalar 1 3608  
1875 0 0 7 1732 3909 3583 0 0 2 4 this 3 3910  6 scalar 1 3608  
1876 0 0 7 1733 3773 0 0 0 0 
1877 0 0 7 1736 3912 3588 0 10 /**
 *
 */ 0 
1878 0 0 23 1736 3912 3588 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3883  
1879 0 0 23 1736 3912 3588 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3887  
1880 0 0 23 1736 3912 3588 0 10 /**
 *
 */ 1 1 c 1 3907  
1881 0 0 15 1736 3912 3588 0 0 1 6 param0 0 3913  
1882 0 0 23 1736 3912 3588 0 10 /**
 *
 */ 1 4 copy 1 3832  
1883 0 0 23 1736 3912 3588 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3811  5 angle 1 3611  
1884 0 0 23 1736 3912 3588 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3611  1 p 1 3611  1 r 1 3611  
1885 0 0 23 1736 3912 3588 0 10 /**
 *
 */ 4 1 r 1 3611  1 i 1 3611  1 j 1 3611  1 k 1 3611  
1886 0 0 7 1737 3906 3578 0 0 2 4 this 3 3913  5 other 1 3907  
1887 0 0 7 1737 3912 3588 0 0 2 4 this 3 3913  5 other 1 3913  
1888 0 0 7 1737 3912 3588 0 0 2 4 this 3 3913  6 scalar 1 3611  
1889 0 0 7 1738 3912 3588 0 0 2 4 this 3 3913  6 scalar 1 3611  
1890 0 0 7 1739 3773 0 0 0 0 
1891 0 0 7 1742 3915 3592 0 10 /**
 *
 */ 0 
1892 0 0 23 1742 3915 3592 0 18 /**
 * matrix3
 */ 1 1 m 1 3862  
1893 0 0 23 1742 3915 3592 0 18 /**
 * matrix4
 */ 1 1 m 1 3866  
1894 0 0 15 1742 3915 3592 0 0 1 6 param0 0 3916  
1895 0 0 23 1742 3915 3592 0 10 /**
 *
 */ 1 1 c 1 3904  
1896 0 0 23 1742 3915 3592 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3808  5 twist 1 3608  
1897 0 0 23 1742 3915 3592 0 10 /**
 *
 */ 4 1 r 1 3608  1 i 1 3608  1 j 1 3608  1 k 1 3608  
1898 0 0 7 1743 3915 3592 0 0 2 4 this 3 3916  5 other 1 3904  
1899 0 0 7 1743 3915 3592 0 0 2 4 this 3 3916  5 other 1 3910  
1900 0 0 7 1744 3773 0 0 0 0 
1901 0 0 7 1747 3918 3596 0 10 /**
 *
 */ 0 
1902 0 0 23 1747 3918 3596 0 18 /**
 * matrix3
 */ 1 1 m 1 3883  
1903 0 0 23 1747 3918 3596 0 18 /**
 * matrix4
 */ 1 1 m 1 3887  
1904 0 0 15 1747 3918 3596 0 0 1 6 param0 0 3919  
1905 0 0 23 1747 3918 3596 0 10 /**
 *
 */ 1 1 c 1 3907  
1906 0 0 23 1747 3918 3596 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3811  5 twist 1 3611  
1907 0 0 23 1747 3918 3596 0 10 /**
 *
 */ 4 1 r 1 3611  1 i 1 3611  1 j 1 3611  1 k 1 3611  
1908 0 0 7 1748 3918 3596 0 0 2 4 this 3 3919  5 other 1 3907  
1909 0 0 7 1748 3918 3596 0 0 2 4 this 3 3919  5 other 1 3913  
1910 0 0 7 1749 3773 0 0 0 0 
1911 0 0 15 1823 3923 3604 0 0 1 6 param0 0 3921  
1912 0 0 23 1823 3923 3604 0 10 /**
 *
 */ 1 4 name 1 3762  
1913 0 0 23 1823 3923 3604 0 10 /**
 *
 */ 4 4 name 1 3762  13 default_value 1 3924  11 description 5 3762  5 flags 5 3614  
1914 0 0 23 1823 3923 3604 0 10 /**
 *
 */ 4 4 name 1 3762  13 default_value 1 3762  11 description 5 3762  5 flags 5 3614  
1915 0 0 6 1824 3923 0 0 0 2 4 this 3 3923  5 value 1 3924  
1916 0 0 6 1826 3926 0 0 0 2 4 this 3 3921  1 n 1 3614  
1917 0 0 4 1827 3758 0 0 48 /**
 * Reassigns the variable's local value.
 */ 2 4 this 3 3923  5 value 1 3924  
1918 0 0 6 1828 3924 0 0 40 /**
 * Returns the variable's value.
 */ 1 4 this 3 3921  
1919 0 0 7 1829 3927 0 0 48 /**
 * Returns the variable's default value.
 */ 1 4 this 3 3921  
1920 0 0 6 1825 3924 0 0 0 1 4 this 3 3921  
1921 0 0 6 4 3611 0 0 0 1 1 f 1 3611  
1922 0 0 6 4 3608 0 0 0 1 1 f 1 3608  
1923 0 0 6 5 3611 0 0 0 1 1 f 1 3611  
1924 0 0 6 5 3608 0 0 0 1 1 f 1 3608  
1925 0 0 6 577 3627 0 0 0 0 
1926 0 0 6 578 3627 0 0 0 1 3 str 1 3762  
1927 0 0 6 579 3762 0 0 0 1 2 cs 1 3627  
1928 0 0 6 580 3763 0 0 0 1 2 cs 5 3627  
1929 0 0 7 1289 3882 3366 0 0 1 1 a 1 3883  
1930 0 0 7 1289 3861 3172 0 0 1 1 a 1 3862  
1931 0 0 7 1289 3893 3462 0 0 1 1 a 1 3887  
1932 0 0 7 1289 3872 3270 0 0 1 1 a 1 3866  
1933 0 0 7 1290 3882 3366 0 0 1 1 a 1 3883  
1934 0 0 7 1290 3861 3172 0 0 1 1 a 1 3862  
1935 0 0 7 1290 3893 3462 0 0 1 1 a 1 3887  
1936 0 0 7 1290 3872 3270 0 0 1 1 a 1 3866  
1937 0 0 7 1290 3906 3578 0 0 1 1 a 1 3907  
1938 0 0 7 1290 3903 3529 0 0 1 1 a 1 3904  
1939 0 0 7 1621 3882 3366 0 0 2 1 m 1 3883  1 q 1 3907  
1940 0 0 7 1621 3861 3172 0 0 2 1 m 1 3862  1 q 1 3904  
1941 0 0 7 1621 3893 3462 0 0 2 1 m 1 3887  1 q 1 3907  
1942 0 0 7 1621 3872 3270 0 0 2 1 m 1 3866  1 q 1 3904  
1943 0 0 7 1621 3792 2296 0 0 2 1 v 1 3793  1 m 1 3883  
1944 0 0 7 1621 3789 2280 0 0 2 1 v 1 3790  1 m 1 3862  
1945 0 0 7 1621 3819 2683 0 0 2 1 v 1 3820  1 m 1 3883  
1946 0 0 7 1621 3819 2683 0 0 2 1 v 1 3820  1 m 1 3887  
1947 0 0 7 1621 3816 2660 0 0 2 1 v 1 3817  1 m 1 3862  
1948 0 0 7 1621 3816 2660 0 0 2 1 v 1 3817  1 m 1 3866  
1949 0 0 7 1621 3855 3068 0 0 2 1 v 1 3856  1 m 1 3887  
1950 0 0 7 1621 3852 3048 0 0 2 1 v 1 3853  1 m 1 3866  
1951 0 0 7 1621 3801 2466 0 0 2 1 v 1 3802  1 m 1 3883  
1952 0 0 7 1621 3798 2388 0 0 2 1 v 1 3799  1 m 1 3862  
1953 0 0 7 1621 3831 2873 0 0 2 1 v 1 3832  1 m 1 3887  
1954 0 0 7 1621 3825 2783 0 0 2 1 v 1 3826  1 m 1 3866  
1955 0 0 7 1621 3783 2250 0 0 2 1 v 1 3784  1 m 1 3883  
1956 0 0 7 1621 3780 2232 0 0 2 1 v 1 3781  1 m 1 3862  
1957 0 0 7 1621 3810 2611 0 0 2 1 v 1 3811  1 m 1 3883  
1958 0 0 7 1621 3810 2611 0 0 2 1 v 1 3811  1 m 1 3887  
1959 0 0 7 1621 3807 2577 0 0 2 1 v 1 3808  1 m 1 3862  
1960 0 0 7 1621 3807 2577 0 0 2 1 v 1 3808  1 m 1 3866  
1961 0 0 7 1621 3846 3010 0 0 2 1 v 1 3847  1 m 1 3887  
1962 0 0 7 1621 3843 2990 0 0 2 1 v 1 3844  1 m 1 3866  
1963 0 0 4 1622 3758 0 0 0 2 1 v 1 3792  1 m 1 3883  
1964 0 0 4 1622 3758 0 0 0 2 1 v 1 3789  1 m 1 3862  
1965 0 0 4 1622 3758 0 0 0 2 1 v 1 3819  1 m 1 3883  
1966 0 0 4 1622 3758 0 0 0 2 1 v 1 3819  1 m 1 3887  
1967 0 0 4 1622 3758 0 0 0 2 1 v 1 3816  1 m 1 3862  
1968 0 0 4 1622 3758 0 0 0 2 1 v 1 3816  1 m 1 3866  
1969 0 0 4 1622 3758 0 0 0 2 1 v 1 3801  1 m 1 3883  
1970 0 0 4 1622 3758 0 0 0 2 1 v 1 3798  1 m 1 3862  
1971 0 0 4 1622 3758 0 0 0 2 1 v 1 3831  1 m 1 3887  
1972 0 0 4 1622 3758 0 0 0 2 1 v 1 3825  1 m 1 3866  
1973 0 0 4 1622 3758 0 0 0 2 1 v 1 3783  1 m 1 3883  
1974 0 0 4 1622 3758 0 0 0 2 1 v 1 3780  1 m 1 3862  
1975 0 0 4 1622 3758 0 0 0 2 1 v 1 3810  1 m 1 3883  
1976 0 0 4 1622 3758 0 0 0 2 1 v 1 3810  1 m 1 3887  
1977 0 0 4 1622 3758 0 0 0 2 1 v 1 3807  1 m 1 3862  
1978 0 0 4 1622 3758 0 0 0 2 1 v 1 3807  1 m 1 3866  
1979 0 0 4 1623 3758 0 0 0 2 4 dest 1 3768  5 value 1 3883  
1980 0 0 4 1623 3758 0 0 0 2 4 dest 1 3768  5 value 1 3862  
1981 0 0 4 1623 3758 0 0 0 2 4 dest 1 3768  5 value 1 3887  
1982 0 0 4 1623 3758 0 0 0 2 4 dest 1 3768  5 value 1 3866  
1983 0 0 4 1624 3758 0 0 0 2 6 result 1 3882  6 source 1 3770  
1984 0 0 4 1624 3758 0 0 0 2 6 result 1 3861  6 source 1 3770  
1985 0 0 4 1624 3758 0 0 0 2 6 result 1 3893  6 source 1 3770  
1986 0 0 4 1624 3758 0 0 0 2 6 result 1 3872  6 source 1 3770  
1987 0 0 4 1625 3758 0 0 0 4 3 mat 1 3882  5 scale 1 3802  3 hpr 1 3802  2 cs 5 3627  
1988 0 0 4 1625 3758 0 0 0 5 3 mat 1 3882  5 scale 1 3802  5 shear 1 3802  3 hpr 1 3802  2 cs 5 3627  
1989 0 0 4 1625 3758 0 0 0 4 3 mat 1 3861  5 scale 1 3799  3 hpr 1 3799  2 cs 5 3627  
1990 0 0 4 1625 3758 0 0 0 5 3 mat 1 3861  5 scale 1 3799  5 shear 1 3799  3 hpr 1 3799  2 cs 5 3627  
1991 0 0 4 1625 3758 0 0 0 5 3 mat 1 3893  5 scale 1 3802  3 hpr 1 3802  9 translate 1 3802  2 cs 5 3627  
1992 0 0 4 1625 3758 0 0 0 6 3 mat 1 3893  5 scale 1 3802  5 shear 1 3802  3 hpr 1 3802  9 translate 1 3802  2 cs 5 3627  
1993 0 0 4 1625 3758 0 0 0 3 3 mat 1 3893  10 components 1 3928  2 cs 5 3627  
1994 0 0 4 1625 3758 0 0 0 5 3 mat 1 3872  5 scale 1 3799  3 hpr 1 3799  9 translate 1 3799  2 cs 5 3627  
1995 0 0 4 1625 3758 0 0 0 6 3 mat 1 3872  5 scale 1 3799  5 shear 1 3799  3 hpr 1 3799  9 translate 1 3799  2 cs 5 3627  
1996 0 0 4 1625 3758 0 0 0 3 3 mat 1 3872  10 components 1 3930  2 cs 5 3627  
1997 0 0 6 1626 3763 0 0 0 4 3 mat 1 3883  5 scale 1 3801  3 hpr 1 3801  2 cs 5 3627  
1998 0 0 6 1626 3763 0 0 0 5 3 mat 1 3883  5 scale 1 3801  5 shear 1 3801  3 hpr 1 3801  2 cs 5 3627  
1999 0 0 6 1626 3763 0 0 0 4 3 mat 1 3862  5 scale 1 3798  3 hpr 1 3798  2 cs 5 3627  
2000 0 0 6 1626 3763 0 0 0 5 3 mat 1 3862  5 scale 1 3798  5 shear 1 3798  3 hpr 1 3798  2 cs 5 3627  
2001 0 0 6 1626 3763 0 0 0 5 3 mat 1 3887  5 scale 1 3801  3 hpr 1 3801  9 translate 1 3801  2 cs 5 3627  
2002 0 0 6 1626 3763 0 0 0 6 3 mat 1 3887  5 scale 1 3801  5 shear 1 3801  3 hpr 1 3801  9 translate 1 3801  2 cs 5 3627  
2003 0 0 6 1626 3763 0 0 0 3 3 mat 1 3887  10 components 1 3932  2 CS 5 3627  
2004 0 0 6 1626 3763 0 0 0 5 3 mat 1 3866  5 scale 1 3798  3 hpr 1 3798  9 translate 1 3798  2 cs 5 3627  
2005 0 0 6 1626 3763 0 0 0 6 3 mat 1 3866  5 scale 1 3798  5 shear 1 3798  3 hpr 1 3798  9 translate 1 3798  2 cs 5 3627  
2006 0 0 6 1626 3763 0 0 0 3 3 mat 1 3866  10 components 1 3933  2 CS 5 3627  
2007 0 0 6 1627 3763 0 0 0 5 3 mat 1 3883  5 scale 1 3801  5 shear 1 3801  3 hpr 1 3801  2 cs 5 3627  
2008 0 0 6 1627 3763 0 0 0 5 3 mat 1 3862  5 scale 1 3798  5 shear 1 3798  3 hpr 1 3798  2 cs 5 3627  
2009 0 0 7 1628 3801 2466 0 0 1 7 old_hpr 1 3802  
2010 0 0 7 1628 3798 2388 0 0 1 7 old_hpr 1 3799  
329
3605 11 MathNumbers 0 141313 11 MathNumbers 11 MathNumbers 0 0 0 1 2011 2012 0 0 0 0 0 0 0 0

3606 10 LVecBase2f 0 141313 10 LVecBase2f 10 LVecBase2f 0 0 0 1 2015 2082 2 3934 3935 66 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 0 0 0 0 1 3607 75
/**
 * This is the base class for all two-component vectors and points.
 */

3607 0 0 794624 12 LVecBase2f:: 0 3606 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2f::num_components 0
2 6 is_int 18 LVecBase2f::is_int 0
0 0 0

3608 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3609 10 LVecBase2d 0 141313 10 LVecBase2d 10 LVecBase2d 0 0 0 1 2083 2150 2 3936 3937 66 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 0 0 0 0 1 3610 75
/**
 * This is the base class for all two-component vectors and points.
 */

3610 0 0 794624 12 LVecBase2d:: 0 3609 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2d::num_components 0
2 6 is_int 18 LVecBase2d::is_int 0
0 0 0

3611 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

3612 10 LVecBase2i 0 141313 10 LVecBase2i 10 LVecBase2i 0 0 0 1 2151 2214 2 3938 3939 62 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 0 0 0 0 1 3613 75
/**
 * This is the base class for all two-component vectors and points.
 */

3613 0 0 794624 12 LVecBase2i:: 0 3612 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2i::num_components 0
2 6 is_int 18 LVecBase2i::is_int 0
1 0 0

3614 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3615 9 LVector2f 0 141313 9 LVector2f 9 LVector2f 0 0 0 1 2215 2232 0 16 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 0 0 1 0 3606 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3616 9 LVector2d 0 141313 9 LVector2d 9 LVector2d 0 0 0 1 2233 2250 0 16 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 0 0 1 0 3609 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3617 9 LVector2i 0 141313 9 LVector2i 9 LVector2i 0 0 0 1 2251 2264 0 12 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 0 0 1 0 3612 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3618 8 LPoint2f 0 141313 8 LPoint2f 8 LPoint2f 0 0 0 1 2265 2280 0 14 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 0 0 1 0 3606 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3619 8 LPoint2d 0 141313 8 LPoint2d 8 LPoint2d 0 0 0 1 2281 2296 0 14 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 0 0 1 0 3609 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3620 8 LPoint2i 0 141313 8 LPoint2i 8 LPoint2i 0 0 0 1 2297 2310 0 12 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 0 0 1 0 3612 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3621 10 LVecBase3f 0 141313 10 LVecBase3f 10 LVecBase3f 0 0 0 1 2311 2388 6 3940 3941 3942 3943 3944 3945 76 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 0 0 0 0 1 3622 77
/**
 * This is the base class for all three-component vectors and points.
 */

3622 0 0 794624 12 LVecBase3f:: 0 3621 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3f::num_components 0
3 6 is_int 18 LVecBase3f::is_int 0
0 0 0

3623 10 LVecBase3d 0 141313 10 LVecBase3d 10 LVecBase3d 0 0 0 1 2389 2466 6 3946 3947 3948 3949 3950 3951 76 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 0 0 0 0 1 3624 77
/**
 * This is the base class for all three-component vectors and points.
 */

3624 0 0 794624 12 LVecBase3d:: 0 3623 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3d::num_components 0
3 6 is_int 18 LVecBase3d::is_int 0
0 0 0

3625 10 LVecBase3i 0 141313 10 LVecBase3i 10 LVecBase3i 0 0 0 1 2467 2539 6 3952 3953 3954 3955 3956 3957 71 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 0 0 0 0 1 3626 77
/**
 * This is the base class for all three-component vectors and points.
 */

3626 0 0 794624 12 LVecBase3i:: 0 3625 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3i::num_components 0
3 6 is_int 18 LVecBase3i::is_int 0
1 0 0

3627 16 CoordinateSystem 0 532481 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 21
// Z-Up, Right-handed
1 12 CS_yup_right 12 CS_yup_right 21
// Y-Up, Right-handed
2 11 CS_zup_left 11 CS_zup_left 20
// Z-Up, Left-handed
3 11 CS_yup_left 11 CS_yup_left 20
// Y-Up, Left-handed
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

3628 9 LVector3f 0 141313 9 LVector3f 9 LVector3f 0 0 0 1 2544 2577 3 3958 3959 3960 32 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 0 0 1 0 3621 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3629 9 LVector3d 0 141313 9 LVector3d 9 LVector3d 0 0 0 1 2578 2611 3 3961 3962 3963 32 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 0 0 1 0 3623 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3630 9 LVector3i 0 141313 9 LVector3i 9 LVector3i 0 0 0 1 2612 2637 3 3964 3965 3966 24 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 0 0 1 0 3625 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3631 8 LPoint3f 0 141313 8 LPoint3f 8 LPoint3f 0 0 0 1 2638 2660 3 3967 3968 3969 21 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 0 0 1 0 3621 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3632 8 LPoint3d 0 141313 8 LPoint3d 8 LPoint3d 0 0 0 1 2661 2683 3 3970 3971 3972 21 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 0 0 1 0 3623 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3633 8 LPoint3i 0 141313 8 LPoint3i 8 LPoint3i 0 0 0 1 2684 2704 3 3973 3974 3975 19 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 0 0 1 0 3625 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3634 10 LVecBase4f 0 141313 10 LVecBase4f 10 LVecBase4f 0 0 0 1 2705 2783 5 3976 3977 3978 3979 3980 77 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 0 0 0 0 1 3635 77
/**
 * This is the base class for all three-component vectors and points.
 */

3635 0 0 794624 12 LVecBase4f:: 0 3634 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4f::num_components 0
4 6 is_int 18 LVecBase4f::is_int 0
0 0 0

3636 19 UnalignedLVecBase4f 0 141313 19 UnalignedLVecBase4f 19 UnalignedLVecBase4f 0 0 0 1 2784 2794 0 9 2785 2786 2787 2788 2789 2790 2791 2792 2793 0 0 0 0 1 3637 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3637 0 0 794624 21 UnalignedLVecBase4f:: 0 3636 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4f::num_components 0
4 6 is_int 27 UnalignedLVecBase4f::is_int 0
0 0 0

3638 10 LVecBase4d 0 141313 10 LVecBase4d 10 LVecBase4d 0 0 0 1 2795 2873 5 3981 3982 3983 3984 3985 77 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 0 0 0 0 1 3639 77
/**
 * This is the base class for all three-component vectors and points.
 */

3639 0 0 794624 12 LVecBase4d:: 0 3638 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4d::num_components 0
4 6 is_int 18 LVecBase4d::is_int 0
0 0 0

3640 19 UnalignedLVecBase4d 0 141313 19 UnalignedLVecBase4d 19 UnalignedLVecBase4d 0 0 0 1 2874 2884 0 9 2875 2876 2877 2878 2879 2880 2881 2882 2883 0 0 0 0 1 3641 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3641 0 0 794624 21 UnalignedLVecBase4d:: 0 3640 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4d::num_components 0
4 6 is_int 27 UnalignedLVecBase4d::is_int 0
0 0 0

3642 10 LVecBase4i 0 141313 10 LVecBase4i 10 LVecBase4i 0 0 0 1 2885 2959 5 3986 3987 3988 3989 3990 73 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 0 0 0 0 1 3643 77
/**
 * This is the base class for all three-component vectors and points.
 */

3643 0 0 794624 12 LVecBase4i:: 0 3642 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4i::num_components 0
4 6 is_int 18 LVecBase4i::is_int 0
1 0 0

3644 19 UnalignedLVecBase4i 0 141313 19 UnalignedLVecBase4i 19 UnalignedLVecBase4i 0 0 0 1 2960 2970 0 9 2961 2962 2963 2964 2965 2966 2967 2968 2969 0 0 0 0 1 3645 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3645 0 0 794624 21 UnalignedLVecBase4i:: 0 3644 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4i::num_components 0
4 6 is_int 27 UnalignedLVecBase4i::is_int 0
1 0 0

3646 9 LVector4f 0 141313 9 LVector4f 9 LVector4f 0 0 0 1 2971 2990 2 3991 3992 18 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 0 0 1 0 3634 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3647 9 LVector4d 0 141313 9 LVector4d 9 LVector4d 0 0 0 1 2991 3010 2 3993 3994 18 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 0 0 1 0 3638 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3648 9 LVector4i 0 141313 9 LVector4i 9 LVector4i 0 0 0 1 3011 3028 2 3995 3996 16 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 0 0 1 0 3642 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3649 8 LPoint4f 0 141313 8 LPoint4f 8 LPoint4f 0 0 0 1 3029 3048 2 3997 3998 18 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 0 0 1 0 3634 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3650 8 LPoint4d 0 141313 8 LPoint4d 8 LPoint4d 0 0 0 1 3049 3068 2 3999 4000 18 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 0 0 1 0 3638 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3651 8 LPoint4i 0 141313 8 LPoint4i 8 LPoint4i 0 0 0 1 3069 3086 2 4001 4002 16 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 0 0 1 0 3642 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3652 9 LMatrix3f 0 141313 9 LMatrix3f 9 LMatrix3f 0 0 0 1 3097 3172 2 4003 4004 74 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 4 4011 4012 4013 4014 0 0 0 3 3653 3654 3655 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3653 0 0 794624 11 LMatrix3f:: 0 3652 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3f::num_components 0
9 6 is_int 17 LMatrix3f::is_int 0
0 0 0

3654 3 Row 0 403457 14 LMatrix3f::Row 14 LMatrix3f::Row 3652 0 0 1 3090 3091 0 2 3087 3088 0 1 3089 0 0 0 66
// These helper classes are used to support two-level operator [].

3655 4 CRow 0 403457 15 LMatrix3f::CRow 15 LMatrix3f::CRow 3652 0 0 1 3095 3096 0 2 3092 3093 0 1 3094 0 0 0 0

3656 9 LMatrix4f 0 141313 9 LMatrix4f 9 LMatrix4f 0 0 0 1 3185 3270 2 4005 4006 84 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3 4015 4016 4017 0 0 0 3 3657 3658 3659 45
/**
 * This is a 4-by-4 transform matrix.
 */

3657 0 0 794624 11 LMatrix4f:: 0 3656 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4f::num_components 0
16 6 is_int 17 LMatrix4f::is_int 0
0 0 0

3658 3 Row 0 403457 14 LMatrix4f::Row 14 LMatrix4f::Row 3656 0 0 1 3178 3179 0 2 3175 3176 0 1 3177 0 0 0 66
// These helper classes are used to support two-level operator [].

3659 4 CRow 0 403457 15 LMatrix4f::CRow 15 LMatrix4f::CRow 3656 0 0 1 3183 3184 0 2 3180 3181 0 1 3182 0 0 0 0

3660 18 UnalignedLMatrix4f 0 141313 18 UnalignedLMatrix4f 18 UnalignedLMatrix4f 0 0 0 1 3271 3280 0 8 3272 3273 3274 3275 3276 3277 3278 3279 0 0 0 0 1 3661 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3661 0 0 794624 20 UnalignedLMatrix4f:: 0 3660 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4f::num_components 0
16 0 0

3662 9 LMatrix3d 0 141313 9 LMatrix3d 9 LMatrix3d 0 0 0 1 3291 3366 2 4007 4008 74 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 4 4018 4019 4020 4021 0 0 0 3 3663 3664 3665 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3663 0 0 794624 11 LMatrix3d:: 0 3662 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3d::num_components 0
9 6 is_int 17 LMatrix3d::is_int 0
0 0 0

3664 3 Row 0 403457 14 LMatrix3d::Row 14 LMatrix3d::Row 3662 0 0 1 3284 3285 0 2 3281 3282 0 1 3283 0 0 0 66
// These helper classes are used to support two-level operator [].

3665 4 CRow 0 403457 15 LMatrix3d::CRow 15 LMatrix3d::CRow 3662 0 0 1 3289 3290 0 2 3286 3287 0 1 3288 0 0 0 0

3666 9 LMatrix4d 0 141313 9 LMatrix4d 9 LMatrix4d 0 0 0 1 3377 3462 2 4009 4010 84 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3 4022 4023 4024 0 0 0 3 3667 3668 3669 45
/**
 * This is a 4-by-4 transform matrix.
 */

3667 0 0 794624 11 LMatrix4d:: 0 3666 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4d::num_components 0
16 6 is_int 17 LMatrix4d::is_int 0
0 0 0

3668 3 Row 0 403457 14 LMatrix4d::Row 14 LMatrix4d::Row 3666 0 0 1 3370 3371 0 2 3367 3368 0 1 3369 0 0 0 66
// These helper classes are used to support two-level operator [].

3669 4 CRow 0 403457 15 LMatrix4d::CRow 15 LMatrix4d::CRow 3666 0 0 1 3375 3376 0 2 3372 3373 0 1 3374 0 0 0 0

3670 18 UnalignedLMatrix4d 0 141313 18 UnalignedLMatrix4d 18 UnalignedLMatrix4d 0 0 0 1 3463 3472 0 8 3464 3465 3466 3467 3468 3469 3470 3471 0 0 0 0 1 3671 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3671 0 0 794624 20 UnalignedLMatrix4d:: 0 3670 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4d::num_components 0
16 0 0

3672 12 LQuaternionf 0 141313 12 LQuaternionf 12 LQuaternionf 0 0 0 1 3481 3529 0 47 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 0 0 1 0 3634 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3673 12 LQuaterniond 0 141313 12 LQuaterniond 12 LQuaterniond 0 0 0 1 3530 3578 0 47 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 0 0 1 0 3638 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3674 10 LRotationf 0 141313 10 LRotationf 10 LRotationf 0 0 0 1 3579 3583 0 3 3580 3581 3582 0 0 1 0 3672 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3675 10 LRotationd 0 141313 10 LRotationd 10 LRotationd 0 0 0 1 3584 3588 0 3 3585 3586 3587 0 0 1 0 3673 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3676 13 LOrientationf 0 141313 13 LOrientationf 13 LOrientationf 0 0 0 1 3589 3592 0 2 3590 3591 0 0 1 0 3672 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3677 13 LOrientationd 0 141313 13 LOrientationd 13 LOrientationd 0 0 0 1 3593 3596 0 2 3594 3595 0 0 1 0 3673 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3678 8 LVertexf 0 2105345 8 LVertexf 8 LVertexf 0 0 3631 0 0 0 0 0 0 0 0 0 0

3679 8 LNormalf 0 2105345 8 LNormalf 8 LNormalf 0 0 3628 0 0 0 0 0 0 0 0 0 0

3680 10 LTexCoordf 0 2105345 10 LTexCoordf 10 LTexCoordf 0 0 3618 0 0 0 0 0 0 0 0 0 0

3681 11 LTexCoord3f 0 2105345 11 LTexCoord3f 11 LTexCoord3f 0 0 3631 0 0 0 0 0 0 0 0 0 0

3682 7 LColorf 0 2105345 7 LColorf 7 LColorf 0 0 3634 0 0 0 0 0 0 0 0 0 0

3683 10 LRGBColorf 0 2105345 10 LRGBColorf 10 LRGBColorf 0 0 3621 0 0 0 0 0 0 0 0 0 0

3684 8 LVertexd 0 2105345 8 LVertexd 8 LVertexd 0 0 3632 0 0 0 0 0 0 0 0 0 0

3685 8 LNormald 0 2105345 8 LNormald 8 LNormald 0 0 3629 0 0 0 0 0 0 0 0 0 0

3686 10 LTexCoordd 0 2105345 10 LTexCoordd 10 LTexCoordd 0 0 3619 0 0 0 0 0 0 0 0 0 0

3687 11 LTexCoord3d 0 2105345 11 LTexCoord3d 11 LTexCoord3d 0 0 3632 0 0 0 0 0 0 0 0 0 0

3688 7 LColord 0 2105345 7 LColord 7 LColord 0 0 3638 0 0 0 0 0 0 0 0 0 0

3689 10 LRGBColord 0 2105345 10 LRGBColord 10 LRGBColord 0 0 3623 0 0 0 0 0 0 0 0 0 0

3690 5 Mat4F 0 2105345 5 Mat4F 5 Mat4F 0 0 3656 0 0 0 0 0 0 0 0 0 0

3691 5 Mat3F 0 2105345 5 Mat3F 5 Mat3F 0 0 3652 0 0 0 0 0 0 0 0 0 0

3692 7 VBase4F 0 2105345 7 VBase4F 7 VBase4F 0 0 3634 0 0 0 0 0 0 0 0 0 0

3693 5 Vec4F 0 2105345 5 Vec4F 5 Vec4F 0 0 3646 0 0 0 0 0 0 0 0 0 0

3694 7 Point4F 0 2105345 7 Point4F 7 Point4F 0 0 3649 0 0 0 0 0 0 0 0 0 0

3695 7 VBase3F 0 2105345 7 VBase3F 7 VBase3F 0 0 3621 0 0 0 0 0 0 0 0 0 0

3696 5 Vec3F 0 2105345 5 Vec3F 5 Vec3F 0 0 3628 0 0 0 0 0 0 0 0 0 0

3697 7 Point3F 0 2105345 7 Point3F 7 Point3F 0 0 3631 0 0 0 0 0 0 0 0 0 0

3698 7 VBase2F 0 2105345 7 VBase2F 7 VBase2F 0 0 3606 0 0 0 0 0 0 0 0 0 0

3699 5 Vec2F 0 2105345 5 Vec2F 5 Vec2F 0 0 3615 0 0 0 0 0 0 0 0 0 0

3700 7 Point2F 0 2105345 7 Point2F 7 Point2F 0 0 3618 0 0 0 0 0 0 0 0 0 0

3701 5 QuatF 0 2105345 5 QuatF 5 QuatF 0 0 3672 0 0 0 0 0 0 0 0 0 0

3702 5 Mat4D 0 2105345 5 Mat4D 5 Mat4D 0 0 3666 0 0 0 0 0 0 0 0 0 0

3703 5 Mat3D 0 2105345 5 Mat3D 5 Mat3D 0 0 3662 0 0 0 0 0 0 0 0 0 0

3704 7 VBase4D 0 2105345 7 VBase4D 7 VBase4D 0 0 3638 0 0 0 0 0 0 0 0 0 0

3705 5 Vec4D 0 2105345 5 Vec4D 5 Vec4D 0 0 3647 0 0 0 0 0 0 0 0 0 0

3706 7 Point4D 0 2105345 7 Point4D 7 Point4D 0 0 3650 0 0 0 0 0 0 0 0 0 0

3707 7 VBase3D 0 2105345 7 VBase3D 7 VBase3D 0 0 3623 0 0 0 0 0 0 0 0 0 0

3708 5 Vec3D 0 2105345 5 Vec3D 5 Vec3D 0 0 3629 0 0 0 0 0 0 0 0 0 0

3709 7 Point3D 0 2105345 7 Point3D 7 Point3D 0 0 3632 0 0 0 0 0 0 0 0 0 0

3710 7 VBase2D 0 2105345 7 VBase2D 7 VBase2D 0 0 3609 0 0 0 0 0 0 0 0 0 0

3711 5 Vec2D 0 2105345 5 Vec2D 5 Vec2D 0 0 3616 0 0 0 0 0 0 0 0 0 0

3712 7 Point2D 0 2105345 7 Point2D 7 Point2D 0 0 3619 0 0 0 0 0 0 0 0 0 0

3713 5 QuatD 0 2105345 5 QuatD 5 QuatD 0 0 3673 0 0 0 0 0 0 0 0 0 0

3714 9 LVecBase2 0 2105345 9 LVecBase2 9 LVecBase2 0 0 3606 0 0 0 0 0 0 0 0 0 0

3715 7 LPoint2 0 2105345 7 LPoint2 7 LPoint2 0 0 3618 0 0 0 0 0 0 0 0 0 0

3716 8 LVector2 0 2105345 8 LVector2 8 LVector2 0 0 3615 0 0 0 0 0 0 0 0 0 0

3717 9 LVecBase3 0 2105345 9 LVecBase3 9 LVecBase3 0 0 3621 0 0 0 0 0 0 0 0 0 0

3718 7 LPoint3 0 2105345 7 LPoint3 7 LPoint3 0 0 3631 0 0 0 0 0 0 0 0 0 0

3719 8 LVector3 0 2105345 8 LVector3 8 LVector3 0 0 3628 0 0 0 0 0 0 0 0 0 0

3720 9 LVecBase4 0 2105345 9 LVecBase4 9 LVecBase4 0 0 3634 0 0 0 0 0 0 0 0 0 0

3721 7 LPoint4 0 2105345 7 LPoint4 7 LPoint4 0 0 3649 0 0 0 0 0 0 0 0 0 0

3722 8 LVector4 0 2105345 8 LVector4 8 LVector4 0 0 3646 0 0 0 0 0 0 0 0 0 0

3723 11 LQuaternion 0 2105345 11 LQuaternion 11 LQuaternion 0 0 3672 0 0 0 0 0 0 0 0 0 0

3724 9 LRotation 0 2105345 9 LRotation 9 LRotation 0 0 3674 0 0 0 0 0 0 0 0 0 0

3725 12 LOrientation 0 2105345 12 LOrientation 12 LOrientation 0 0 3676 0 0 0 0 0 0 0 0 0 0

3726 8 LMatrix3 0 2105345 8 LMatrix3 8 LMatrix3 0 0 3652 0 0 0 0 0 0 0 0 0 0

3727 8 LMatrix4 0 2105345 8 LMatrix4 8 LMatrix4 0 0 3656 0 0 0 0 0 0 0 0 0 0

3728 7 LVertex 0 2105345 7 LVertex 7 LVertex 0 0 3678 0 0 0 0 0 0 0 0 0 0

3729 7 LNormal 0 2105345 7 LNormal 7 LNormal 0 0 3679 0 0 0 0 0 0 0 0 0 0

3730 9 LTexCoord 0 2105345 9 LTexCoord 9 LTexCoord 0 0 3680 0 0 0 0 0 0 0 0 0 0

3731 10 LTexCoord3 0 2105345 10 LTexCoord3 10 LTexCoord3 0 0 3681 0 0 0 0 0 0 0 0 0 0

3732 6 LColor 0 2105345 6 LColor 6 LColor 0 0 3682 0 0 0 0 0 0 0 0 0 0

3733 9 LRGBColor 0 2105345 9 LRGBColor 9 LRGBColor 0 0 3683 0 0 0 0 0 0 0 0 0 0

3734 18 UnalignedLVecBase4 0 2105345 18 UnalignedLVecBase4 18 UnalignedLVecBase4 0 0 3636 0 0 0 0 0 0 0 0 0 0

3735 17 UnalignedLMatrix4 0 2105345 17 UnalignedLMatrix4 17 UnalignedLMatrix4 0 0 3660 0 0 0 0 0 0 0 0 0 0

3736 4 Mat4 0 2105345 4 Mat4 4 Mat4 0 0 3656 0 0 0 0 0 0 0 0 0 0

3737 4 Mat3 0 2105345 4 Mat3 4 Mat3 0 0 3652 0 0 0 0 0 0 0 0 0 0

3738 6 VBase4 0 2105345 6 VBase4 6 VBase4 0 0 3634 0 0 0 0 0 0 0 0 0 0

3739 4 Vec4 0 2105345 4 Vec4 4 Vec4 0 0 3646 0 0 0 0 0 0 0 0 0 0

3740 6 Point4 0 2105345 6 Point4 6 Point4 0 0 3649 0 0 0 0 0 0 0 0 0 0

3741 6 VBase3 0 2105345 6 VBase3 6 VBase3 0 0 3621 0 0 0 0 0 0 0 0 0 0

3742 4 Vec3 0 2105345 4 Vec3 4 Vec3 0 0 3628 0 0 0 0 0 0 0 0 0 0

3743 6 Point3 0 2105345 6 Point3 6 Point3 0 0 3631 0 0 0 0 0 0 0 0 0 0

3744 6 VBase2 0 2105345 6 VBase2 6 VBase2 0 0 3606 0 0 0 0 0 0 0 0 0 0

3745 4 Vec2 0 2105345 4 Vec2 4 Vec2 0 0 3615 0 0 0 0 0 0 0 0 0 0

3746 6 Point2 0 2105345 6 Point2 6 Point2 0 0 3618 0 0 0 0 0 0 0 0 0 0

3747 4 Quat 0 2105345 4 Quat 4 Quat 0 0 3672 0 0 0 0 0 0 0 0 0 0

3748 19 ConfigVariableColor 0 141313 19 ConfigVariableColor 19 ConfigVariableColor 0 0 0 1 3597 3604 0 5 3598 3600 3601 3602 3603 0 1 3599 1 0 3749 0 0 0 0 538
/**
 * This is a convenience class to specialize ConfigVariable as a set of
 * floating-point types representing a color value.
 *
 * It interprets the color differently depending on how many words were
 * specified: if only one, it is interpreted as a shade of gray with alpha 1.
 * If two values were specified, a grayscale and alpha pair.  If three, a set
 * of R, G, B values with alpha 1, and if four, a complete RGBA color.
 *
 * This isn't defined in dtool because it relies on the LColor class, which is
 * defined in linmath.
 */

3749 14 ConfigVariable 0 2048 14 ConfigVariable 14 ConfigVariable 0 0 0 0 0 0 0 0 0 0 0 0 415
/**
 * This is a generic, untyped ConfigVariable.  It is also the base class for
 * the typed ConfigVariables, and contains all of the code common to
 * ConfigVariables of all types (except ConfigVariableList, which is a bit of
 * a special case).
 *
 * Mostly, this class serves as a thin wrapper around ConfigVariableCore
 * and/or ConfigDeclaration, more or less duplicating the interface presented
 * there.
 */

3750 13 MathNumbers * 0 8576 13 MathNumbers * 13 MathNumbers * 0 0 3605 0 0 0 0 0 0 0 0 0 0

3751 19 MathNumbers const * 0 8576 19 MathNumbers const * 19 MathNumbers const * 0 0 3752 0 0 0 0 0 0 0 0 0 0

3752 17 MathNumbers const 0 8832 17 MathNumbers const 17 MathNumbers const 0 0 3605 0 0 0 0 0 0 0 0 0 0

3753 12 LVecBase2f * 0 8576 12 LVecBase2f * 12 LVecBase2f * 0 0 3606 0 0 0 0 0 0 0 0 0 0

3754 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3755 0 0 0 0 0 0 0 0 0 0

3755 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3606 0 0 0 0 0 0 0 0 0 0

3756 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3757 0 0 0 0 0 0 0 0 0 0

3757 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

3758 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3759 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3760 0 0 0 0 0 0 0 0 0 0

3760 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3761 0 0 0 0 0 0 0 0 0 0

3761 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3762 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3763 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3764 23 ChecksumHashGenerator * 0 8576 23 ChecksumHashGenerator * 23 ChecksumHashGenerator * 0 0 3765 0 0 0 0 0 0 0 0 0 0

3765 21 ChecksumHashGenerator 0 2048 21 ChecksumHashGenerator 21 ChecksumHashGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This is a specific kind of HashGenerator that simply adds up all of the
 * ints.  Nothing fancy, and pretty quick.
 */

3766 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 3767 0 0 0 0 0 0 0 0 0 0

3767 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3768 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 3769 0 0 0 0 0 0 0 0 0 0

3769 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

3770 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 3771 0 0 0 0 0 0 0 0 0 0

3771 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 365
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 *
 * Note that it is the responsibility of the caller to ensure that the datagram
 * object is not destructed while this DatagramIterator is in use.
 */

3772 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

3773 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3772 0 0 0 0 0 0 0 0 0 0

3774 12 LVecBase2d * 0 8576 12 LVecBase2d * 12 LVecBase2d * 0 0 3609 0 0 0 0 0 0 0 0 0 0

3775 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3776 0 0 0 0 0 0 0 0 0 0

3776 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3609 0 0 0 0 0 0 0 0 0 0

3777 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 3612 0 0 0 0 0 0 0 0 0 0

3778 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3779 0 0 0 0 0 0 0 0 0 0

3779 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3612 0 0 0 0 0 0 0 0 0 0

3780 11 LVector2f * 0 8576 11 LVector2f * 11 LVector2f * 0 0 3615 0 0 0 0 0 0 0 0 0 0

3781 17 LVector2f const * 0 8576 17 LVector2f const * 17 LVector2f const * 0 0 3782 0 0 0 0 0 0 0 0 0 0

3782 15 LVector2f const 0 8832 15 LVector2f const 15 LVector2f const 0 0 3615 0 0 0 0 0 0 0 0 0 0

3783 11 LVector2d * 0 8576 11 LVector2d * 11 LVector2d * 0 0 3616 0 0 0 0 0 0 0 0 0 0

3784 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 3785 0 0 0 0 0 0 0 0 0 0

3785 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 3616 0 0 0 0 0 0 0 0 0 0

3786 11 LVector2i * 0 8576 11 LVector2i * 11 LVector2i * 0 0 3617 0 0 0 0 0 0 0 0 0 0

3787 17 LVector2i const * 0 8576 17 LVector2i const * 17 LVector2i const * 0 0 3788 0 0 0 0 0 0 0 0 0 0

3788 15 LVector2i const 0 8832 15 LVector2i const 15 LVector2i const 0 0 3617 0 0 0 0 0 0 0 0 0 0

3789 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 3618 0 0 0 0 0 0 0 0 0 0

3790 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3791 0 0 0 0 0 0 0 0 0 0

3791 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3618 0 0 0 0 0 0 0 0 0 0

3792 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 3619 0 0 0 0 0 0 0 0 0 0

3793 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 3794 0 0 0 0 0 0 0 0 0 0

3794 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 3619 0 0 0 0 0 0 0 0 0 0

3795 10 LPoint2i * 0 8576 10 LPoint2i * 10 LPoint2i * 0 0 3620 0 0 0 0 0 0 0 0 0 0

3796 16 LPoint2i const * 0 8576 16 LPoint2i const * 16 LPoint2i const * 0 0 3797 0 0 0 0 0 0 0 0 0 0

3797 14 LPoint2i const 0 8832 14 LPoint2i const 14 LPoint2i const 0 0 3620 0 0 0 0 0 0 0 0 0 0

3798 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 3621 0 0 0 0 0 0 0 0 0 0

3799 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3800 0 0 0 0 0 0 0 0 0 0

3800 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3621 0 0 0 0 0 0 0 0 0 0

3801 12 LVecBase3d * 0 8576 12 LVecBase3d * 12 LVecBase3d * 0 0 3623 0 0 0 0 0 0 0 0 0 0

3802 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3803 0 0 0 0 0 0 0 0 0 0

3803 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3623 0 0 0 0 0 0 0 0 0 0

3804 12 LVecBase3i * 0 8576 12 LVecBase3i * 12 LVecBase3i * 0 0 3625 0 0 0 0 0 0 0 0 0 0

3805 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3806 0 0 0 0 0 0 0 0 0 0

3806 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3625 0 0 0 0 0 0 0 0 0 0

3807 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3628 0 0 0 0 0 0 0 0 0 0

3808 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3809 0 0 0 0 0 0 0 0 0 0

3809 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3628 0 0 0 0 0 0 0 0 0 0

3810 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3629 0 0 0 0 0 0 0 0 0 0

3811 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 3812 0 0 0 0 0 0 0 0 0 0

3812 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 3629 0 0 0 0 0 0 0 0 0 0

3813 11 LVector3i * 0 8576 11 LVector3i * 11 LVector3i * 0 0 3630 0 0 0 0 0 0 0 0 0 0

3814 17 LVector3i const * 0 8576 17 LVector3i const * 17 LVector3i const * 0 0 3815 0 0 0 0 0 0 0 0 0 0

3815 15 LVector3i const 0 8832 15 LVector3i const 15 LVector3i const 0 0 3630 0 0 0 0 0 0 0 0 0 0

3816 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3631 0 0 0 0 0 0 0 0 0 0

3817 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3818 0 0 0 0 0 0 0 0 0 0

3818 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3631 0 0 0 0 0 0 0 0 0 0

3819 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3632 0 0 0 0 0 0 0 0 0 0

3820 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 3821 0 0 0 0 0 0 0 0 0 0

3821 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 3632 0 0 0 0 0 0 0 0 0 0

3822 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 3633 0 0 0 0 0 0 0 0 0 0

3823 16 LPoint3i const * 0 8576 16 LPoint3i const * 16 LPoint3i const * 0 0 3824 0 0 0 0 0 0 0 0 0 0

3824 14 LPoint3i const 0 8832 14 LPoint3i const 14 LPoint3i const 0 0 3633 0 0 0 0 0 0 0 0 0 0

3825 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 3634 0 0 0 0 0 0 0 0 0 0

3826 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3827 0 0 0 0 0 0 0 0 0 0

3827 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3634 0 0 0 0 0 0 0 0 0 0

3828 27 UnalignedLVecBase4f const * 0 8576 27 UnalignedLVecBase4f const * 27 UnalignedLVecBase4f const * 0 0 3829 0 0 0 0 0 0 0 0 0 0

3829 25 UnalignedLVecBase4f const 0 8832 25 UnalignedLVecBase4f const 25 UnalignedLVecBase4f const 0 0 3636 0 0 0 0 0 0 0 0 0 0

3830 21 UnalignedLVecBase4f * 0 8576 21 UnalignedLVecBase4f * 21 UnalignedLVecBase4f * 0 0 3636 0 0 0 0 0 0 0 0 0 0

3831 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 3638 0 0 0 0 0 0 0 0 0 0

3832 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3833 0 0 0 0 0 0 0 0 0 0

3833 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3638 0 0 0 0 0 0 0 0 0 0

3834 27 UnalignedLVecBase4d const * 0 8576 27 UnalignedLVecBase4d const * 27 UnalignedLVecBase4d const * 0 0 3835 0 0 0 0 0 0 0 0 0 0

3835 25 UnalignedLVecBase4d const 0 8832 25 UnalignedLVecBase4d const 25 UnalignedLVecBase4d const 0 0 3640 0 0 0 0 0 0 0 0 0 0

3836 21 UnalignedLVecBase4d * 0 8576 21 UnalignedLVecBase4d * 21 UnalignedLVecBase4d * 0 0 3640 0 0 0 0 0 0 0 0 0 0

3837 12 LVecBase4i * 0 8576 12 LVecBase4i * 12 LVecBase4i * 0 0 3642 0 0 0 0 0 0 0 0 0 0

3838 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3839 0 0 0 0 0 0 0 0 0 0

3839 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3642 0 0 0 0 0 0 0 0 0 0

3840 27 UnalignedLVecBase4i const * 0 8576 27 UnalignedLVecBase4i const * 27 UnalignedLVecBase4i const * 0 0 3841 0 0 0 0 0 0 0 0 0 0

3841 25 UnalignedLVecBase4i const 0 8832 25 UnalignedLVecBase4i const 25 UnalignedLVecBase4i const 0 0 3644 0 0 0 0 0 0 0 0 0 0

3842 21 UnalignedLVecBase4i * 0 8576 21 UnalignedLVecBase4i * 21 UnalignedLVecBase4i * 0 0 3644 0 0 0 0 0 0 0 0 0 0

3843 11 LVector4f * 0 8576 11 LVector4f * 11 LVector4f * 0 0 3646 0 0 0 0 0 0 0 0 0 0

3844 17 LVector4f const * 0 8576 17 LVector4f const * 17 LVector4f const * 0 0 3845 0 0 0 0 0 0 0 0 0 0

3845 15 LVector4f const 0 8832 15 LVector4f const 15 LVector4f const 0 0 3646 0 0 0 0 0 0 0 0 0 0

3846 11 LVector4d * 0 8576 11 LVector4d * 11 LVector4d * 0 0 3647 0 0 0 0 0 0 0 0 0 0

3847 17 LVector4d const * 0 8576 17 LVector4d const * 17 LVector4d const * 0 0 3848 0 0 0 0 0 0 0 0 0 0

3848 15 LVector4d const 0 8832 15 LVector4d const 15 LVector4d const 0 0 3647 0 0 0 0 0 0 0 0 0 0

3849 11 LVector4i * 0 8576 11 LVector4i * 11 LVector4i * 0 0 3648 0 0 0 0 0 0 0 0 0 0

3850 17 LVector4i const * 0 8576 17 LVector4i const * 17 LVector4i const * 0 0 3851 0 0 0 0 0 0 0 0 0 0

3851 15 LVector4i const 0 8832 15 LVector4i const 15 LVector4i const 0 0 3648 0 0 0 0 0 0 0 0 0 0

3852 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3649 0 0 0 0 0 0 0 0 0 0

3853 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 3854 0 0 0 0 0 0 0 0 0 0

3854 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 3649 0 0 0 0 0 0 0 0 0 0

3855 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3650 0 0 0 0 0 0 0 0 0 0

3856 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 3857 0 0 0 0 0 0 0 0 0 0

3857 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 3650 0 0 0 0 0 0 0 0 0 0

3858 10 LPoint4i * 0 8576 10 LPoint4i * 10 LPoint4i * 0 0 3651 0 0 0 0 0 0 0 0 0 0

3859 16 LPoint4i const * 0 8576 16 LPoint4i const * 16 LPoint4i const * 0 0 3860 0 0 0 0 0 0 0 0 0 0

3860 14 LPoint4i const 0 8832 14 LPoint4i const 14 LPoint4i const 0 0 3651 0 0 0 0 0 0 0 0 0 0

3861 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3652 0 0 0 0 0 0 0 0 0 0

3862 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3863 0 0 0 0 0 0 0 0 0 0

3863 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3652 0 0 0 0 0 0 0 0 0 0

3864 5 Row * 0 8576 16 LMatrix3f::Row * 16 LMatrix3f::Row * 0 0 3654 0 0 0 0 0 0 0 0 0 0

3865 6 CRow * 0 8576 17 LMatrix3f::CRow * 17 LMatrix3f::CRow * 0 0 3655 0 0 0 0 0 0 0 0 0 0

3866 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3867 0 0 0 0 0 0 0 0 0 0

3867 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3656 0 0 0 0 0 0 0 0 0 0

3868 11 Row const * 0 8576 22 LMatrix3f::Row const * 22 LMatrix3f::Row const * 0 0 3869 0 0 0 0 0 0 0 0 0 0

3869 9 Row const 0 8832 20 LMatrix3f::Row const 20 LMatrix3f::Row const 0 0 3654 0 0 0 0 0 0 0 0 0 0

3870 12 CRow const * 0 8576 23 LMatrix3f::CRow const * 23 LMatrix3f::CRow const * 0 0 3871 0 0 0 0 0 0 0 0 0 0

3871 10 CRow const 0 8832 21 LMatrix3f::CRow const 21 LMatrix3f::CRow const 0 0 3655 0 0 0 0 0 0 0 0 0 0

3872 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3656 0 0 0 0 0 0 0 0 0 0

3873 26 UnalignedLMatrix4f const * 0 8576 26 UnalignedLMatrix4f const * 26 UnalignedLMatrix4f const * 0 0 3874 0 0 0 0 0 0 0 0 0 0

3874 24 UnalignedLMatrix4f const 0 8832 24 UnalignedLMatrix4f const 24 UnalignedLMatrix4f const 0 0 3660 0 0 0 0 0 0 0 0 0 0

3875 5 Row * 0 8576 16 LMatrix4f::Row * 16 LMatrix4f::Row * 0 0 3658 0 0 0 0 0 0 0 0 0 0

3876 6 CRow * 0 8576 17 LMatrix4f::CRow * 17 LMatrix4f::CRow * 0 0 3659 0 0 0 0 0 0 0 0 0 0

3877 11 Row const * 0 8576 22 LMatrix4f::Row const * 22 LMatrix4f::Row const * 0 0 3878 0 0 0 0 0 0 0 0 0 0

3878 9 Row const 0 8832 20 LMatrix4f::Row const 20 LMatrix4f::Row const 0 0 3658 0 0 0 0 0 0 0 0 0 0

3879 12 CRow const * 0 8576 23 LMatrix4f::CRow const * 23 LMatrix4f::CRow const * 0 0 3880 0 0 0 0 0 0 0 0 0 0

3880 10 CRow const 0 8832 21 LMatrix4f::CRow const 21 LMatrix4f::CRow const 0 0 3659 0 0 0 0 0 0 0 0 0 0

3881 20 UnalignedLMatrix4f * 0 8576 20 UnalignedLMatrix4f * 20 UnalignedLMatrix4f * 0 0 3660 0 0 0 0 0 0 0 0 0 0

3882 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3662 0 0 0 0 0 0 0 0 0 0

3883 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3884 0 0 0 0 0 0 0 0 0 0

3884 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3662 0 0 0 0 0 0 0 0 0 0

3885 5 Row * 0 8576 16 LMatrix3d::Row * 16 LMatrix3d::Row * 0 0 3664 0 0 0 0 0 0 0 0 0 0

3886 6 CRow * 0 8576 17 LMatrix3d::CRow * 17 LMatrix3d::CRow * 0 0 3665 0 0 0 0 0 0 0 0 0 0

3887 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3888 0 0 0 0 0 0 0 0 0 0

3888 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3666 0 0 0 0 0 0 0 0 0 0

3889 11 Row const * 0 8576 22 LMatrix3d::Row const * 22 LMatrix3d::Row const * 0 0 3890 0 0 0 0 0 0 0 0 0 0

3890 9 Row const 0 8832 20 LMatrix3d::Row const 20 LMatrix3d::Row const 0 0 3664 0 0 0 0 0 0 0 0 0 0

3891 12 CRow const * 0 8576 23 LMatrix3d::CRow const * 23 LMatrix3d::CRow const * 0 0 3892 0 0 0 0 0 0 0 0 0 0

3892 10 CRow const 0 8832 21 LMatrix3d::CRow const 21 LMatrix3d::CRow const 0 0 3665 0 0 0 0 0 0 0 0 0 0

3893 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3666 0 0 0 0 0 0 0 0 0 0

3894 26 UnalignedLMatrix4d const * 0 8576 26 UnalignedLMatrix4d const * 26 UnalignedLMatrix4d const * 0 0 3895 0 0 0 0 0 0 0 0 0 0

3895 24 UnalignedLMatrix4d const 0 8832 24 UnalignedLMatrix4d const 24 UnalignedLMatrix4d const 0 0 3670 0 0 0 0 0 0 0 0 0 0

3896 5 Row * 0 8576 16 LMatrix4d::Row * 16 LMatrix4d::Row * 0 0 3668 0 0 0 0 0 0 0 0 0 0

3897 6 CRow * 0 8576 17 LMatrix4d::CRow * 17 LMatrix4d::CRow * 0 0 3669 0 0 0 0 0 0 0 0 0 0

3898 11 Row const * 0 8576 22 LMatrix4d::Row const * 22 LMatrix4d::Row const * 0 0 3899 0 0 0 0 0 0 0 0 0 0

3899 9 Row const 0 8832 20 LMatrix4d::Row const 20 LMatrix4d::Row const 0 0 3668 0 0 0 0 0 0 0 0 0 0

3900 12 CRow const * 0 8576 23 LMatrix4d::CRow const * 23 LMatrix4d::CRow const * 0 0 3901 0 0 0 0 0 0 0 0 0 0

3901 10 CRow const 0 8832 21 LMatrix4d::CRow const 21 LMatrix4d::CRow const 0 0 3669 0 0 0 0 0 0 0 0 0 0

3902 20 UnalignedLMatrix4d * 0 8576 20 UnalignedLMatrix4d * 20 UnalignedLMatrix4d * 0 0 3670 0 0 0 0 0 0 0 0 0 0

3903 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3672 0 0 0 0 0 0 0 0 0 0

3904 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 3905 0 0 0 0 0 0 0 0 0 0

3905 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3672 0 0 0 0 0 0 0 0 0 0

3906 14 LQuaterniond * 0 8576 14 LQuaterniond * 14 LQuaterniond * 0 0 3673 0 0 0 0 0 0 0 0 0 0

3907 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 3908 0 0 0 0 0 0 0 0 0 0

3908 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 3673 0 0 0 0 0 0 0 0 0 0

3909 12 LRotationf * 0 8576 12 LRotationf * 12 LRotationf * 0 0 3674 0 0 0 0 0 0 0 0 0 0

3910 18 LRotationf const * 0 8576 18 LRotationf const * 18 LRotationf const * 0 0 3911 0 0 0 0 0 0 0 0 0 0

3911 16 LRotationf const 0 8832 16 LRotationf const 16 LRotationf const 0 0 3674 0 0 0 0 0 0 0 0 0 0

3912 12 LRotationd * 0 8576 12 LRotationd * 12 LRotationd * 0 0 3675 0 0 0 0 0 0 0 0 0 0

3913 18 LRotationd const * 0 8576 18 LRotationd const * 18 LRotationd const * 0 0 3914 0 0 0 0 0 0 0 0 0 0

3914 16 LRotationd const 0 8832 16 LRotationd const 16 LRotationd const 0 0 3675 0 0 0 0 0 0 0 0 0 0

3915 15 LOrientationf * 0 8576 15 LOrientationf * 15 LOrientationf * 0 0 3676 0 0 0 0 0 0 0 0 0 0

3916 21 LOrientationf const * 0 8576 21 LOrientationf const * 21 LOrientationf const * 0 0 3917 0 0 0 0 0 0 0 0 0 0

3917 19 LOrientationf const 0 8832 19 LOrientationf const 19 LOrientationf const 0 0 3676 0 0 0 0 0 0 0 0 0 0

3918 15 LOrientationd * 0 8576 15 LOrientationd * 15 LOrientationd * 0 0 3677 0 0 0 0 0 0 0 0 0 0

3919 21 LOrientationd const * 0 8576 21 LOrientationd const * 21 LOrientationd const * 0 0 3920 0 0 0 0 0 0 0 0 0 0

3920 19 LOrientationd const 0 8832 19 LOrientationd const 19 LOrientationd const 0 0 3677 0 0 0 0 0 0 0 0 0 0

3921 27 ConfigVariableColor const * 0 8576 27 ConfigVariableColor const * 27 ConfigVariableColor const * 0 0 3922 0 0 0 0 0 0 0 0 0 0

3922 25 ConfigVariableColor const 0 8832 25 ConfigVariableColor const 25 ConfigVariableColor const 0 0 3748 0 0 0 0 0 0 0 0 0 0

3923 21 ConfigVariableColor * 0 8576 21 ConfigVariableColor * 21 ConfigVariableColor * 0 0 3748 0 0 0 0 0 0 0 0 0 0

3924 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3925 0 0 0 0 0 0 0 0 0 0

3925 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3732 0 0 0 0 0 0 0 0 0 0

3926 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3608 0 0 0 0 0 0 0 0 0 0

3927 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3732 0 0 0 0 0 0 0 0 0 0

3928 38 double const [::num_matrix_components] 0 4202496 38 double const [::num_matrix_components] 38 double const [::num_matrix_components] 0 0 3929 12 0 0 0 0 0 0 0 0 0 0

3929 12 double const 0 8832 12 double const 12 double const 0 0 3611 0 0 0 0 0 0 0 0 0 0

3930 37 float const [::num_matrix_components] 0 4202496 37 float const [::num_matrix_components] 37 float const [::num_matrix_components] 0 0 3931 12 0 0 0 0 0 0 0 0 0 0

3931 11 float const 0 8832 11 float const 11 float const 0 0 3608 0 0 0 0 0 0 0 0 0 0

3932 32 double [::num_matrix_components] 0 4202496 32 double [::num_matrix_components] 32 double [::num_matrix_components] 0 0 3611 12 0 0 0 0 0 0 0 0 0 0

3933 31 float [::num_matrix_components] 0 4202496 31 float [::num_matrix_components] 31 float [::num_matrix_components] 0 0 3608 12 0 0 0 0 0 0 0 0 0 0

0
77
3934 1 x 0 6 3608 2031 2033 0 0 0 0 0 0 13 LVecBase2f::x 0

3935 1 y 0 6 3608 2032 2034 0 0 0 0 0 0 13 LVecBase2f::y 0

3936 1 x 0 6 3611 2099 2101 0 0 0 0 0 0 13 LVecBase2d::x 0

3937 1 y 0 6 3611 2100 2102 0 0 0 0 0 0 13 LVecBase2d::y 0

3938 1 x 0 6 3614 2167 2169 0 0 0 0 0 0 13 LVecBase2i::x 0

3939 1 y 0 6 3614 2168 2170 0 0 0 0 0 0 13 LVecBase2i::y 0

3940 1 x 0 6 3608 2327 2331 0 0 0 0 0 0 13 LVecBase3f::x 0

3941 1 y 0 6 3608 2328 2332 0 0 0 0 0 0 13 LVecBase3f::y 0

3942 1 z 0 6 3608 2329 2333 0 0 0 0 0 0 13 LVecBase3f::z 0

3943 2 xy 0 2 3606 2334 0 0 0 0 0 0 0 14 LVecBase3f::xy 0

3944 2 xz 0 2 3606 2335 0 0 0 0 0 0 0 14 LVecBase3f::xz 0

3945 2 yz 0 2 3606 2336 0 0 0 0 0 0 0 14 LVecBase3f::yz 0

3946 1 x 0 6 3611 2405 2409 0 0 0 0 0 0 13 LVecBase3d::x 0

3947 1 y 0 6 3611 2406 2410 0 0 0 0 0 0 13 LVecBase3d::y 0

3948 1 z 0 6 3611 2407 2411 0 0 0 0 0 0 13 LVecBase3d::z 0

3949 2 xy 0 2 3609 2412 0 0 0 0 0 0 0 14 LVecBase3d::xy 0

3950 2 xz 0 2 3609 2413 0 0 0 0 0 0 0 14 LVecBase3d::xz 0

3951 2 yz 0 2 3609 2414 0 0 0 0 0 0 0 14 LVecBase3d::yz 0

3952 1 x 0 6 3614 2483 2487 0 0 0 0 0 0 13 LVecBase3i::x 0

3953 1 y 0 6 3614 2484 2488 0 0 0 0 0 0 13 LVecBase3i::y 0

3954 1 z 0 6 3614 2485 2489 0 0 0 0 0 0 13 LVecBase3i::z 0

3955 2 xy 0 2 3612 2490 0 0 0 0 0 0 0 14 LVecBase3i::xy 0

3956 2 xz 0 2 3612 2491 0 0 0 0 0 0 0 14 LVecBase3i::xz 0

3957 2 yz 0 2 3612 2492 0 0 0 0 0 0 0 14 LVecBase3i::yz 0

3958 2 xy 0 2 3615 2551 0 0 0 0 0 0 0 13 LVector3f::xy 0

3959 2 xz 0 2 3615 2552 0 0 0 0 0 0 0 13 LVector3f::xz 0

3960 2 yz 0 2 3615 2553 0 0 0 0 0 0 0 13 LVector3f::yz 0

3961 2 xy 0 2 3616 2585 0 0 0 0 0 0 0 13 LVector3d::xy 0

3962 2 xz 0 2 3616 2586 0 0 0 0 0 0 0 13 LVector3d::xz 0

3963 2 yz 0 2 3616 2587 0 0 0 0 0 0 0 13 LVector3d::yz 0

3964 2 xy 0 2 3617 2619 0 0 0 0 0 0 0 13 LVector3i::xy 0

3965 2 xz 0 2 3617 2620 0 0 0 0 0 0 0 13 LVector3i::xz 0

3966 2 yz 0 2 3617 2621 0 0 0 0 0 0 0 13 LVector3i::yz 0

3967 2 xy 0 2 3618 2645 0 0 0 0 0 0 0 12 LPoint3f::xy 0

3968 2 xz 0 2 3618 2646 0 0 0 0 0 0 0 12 LPoint3f::xz 0

3969 2 yz 0 2 3618 2647 0 0 0 0 0 0 0 12 LPoint3f::yz 0

3970 2 xy 0 2 3619 2668 0 0 0 0 0 0 0 12 LPoint3d::xy 0

3971 2 xz 0 2 3619 2669 0 0 0 0 0 0 0 12 LPoint3d::xz 0

3972 2 yz 0 2 3619 2670 0 0 0 0 0 0 0 12 LPoint3d::yz 0

3973 2 xy 0 2 3620 2691 0 0 0 0 0 0 0 12 LPoint3i::xy 0

3974 2 xz 0 2 3620 2692 0 0 0 0 0 0 0 12 LPoint3i::xz 0

3975 2 yz 0 2 3620 2693 0 0 0 0 0 0 0 12 LPoint3i::yz 0

3976 1 x 0 6 3608 2723 2729 0 0 0 0 0 0 13 LVecBase4f::x 0

3977 1 y 0 6 3608 2724 2730 0 0 0 0 0 0 13 LVecBase4f::y 0

3978 1 z 0 6 3608 2725 2731 0 0 0 0 0 0 13 LVecBase4f::z 0

3979 3 xyz 0 2 3621 2727 0 0 0 0 0 0 0 15 LVecBase4f::xyz 0

3980 2 xy 0 2 3606 2728 0 0 0 0 0 0 0 14 LVecBase4f::xy 0

3981 1 x 0 6 3611 2813 2819 0 0 0 0 0 0 13 LVecBase4d::x 0

3982 1 y 0 6 3611 2814 2820 0 0 0 0 0 0 13 LVecBase4d::y 0

3983 1 z 0 6 3611 2815 2821 0 0 0 0 0 0 13 LVecBase4d::z 0

3984 3 xyz 0 2 3623 2817 0 0 0 0 0 0 0 15 LVecBase4d::xyz 0

3985 2 xy 0 2 3609 2818 0 0 0 0 0 0 0 14 LVecBase4d::xy 0

3986 1 x 0 6 3614 2903 2909 0 0 0 0 0 0 13 LVecBase4i::x 0

3987 1 y 0 6 3614 2904 2910 0 0 0 0 0 0 13 LVecBase4i::y 0

3988 1 z 0 6 3614 2905 2911 0 0 0 0 0 0 13 LVecBase4i::z 0

3989 3 xyz 0 2 3625 2907 0 0 0 0 0 0 0 15 LVecBase4i::xyz 0

3990 2 xy 0 2 3612 2908 0 0 0 0 0 0 0 14 LVecBase4i::xy 0

3991 3 xyz 0 2 3628 2979 0 0 0 0 0 0 0 14 LVector4f::xyz 0

3992 2 xy 0 2 3615 2980 0 0 0 0 0 0 0 13 LVector4f::xy 0

3993 3 xyz 0 2 3629 2999 0 0 0 0 0 0 0 14 LVector4d::xyz 0

3994 2 xy 0 2 3616 3000 0 0 0 0 0 0 0 13 LVector4d::xy 0

3995 3 xyz 0 2 3630 3019 0 0 0 0 0 0 0 14 LVector4i::xyz 0

3996 2 xy 0 2 3617 3020 0 0 0 0 0 0 0 13 LVector4i::xy 0

3997 3 xyz 0 2 3631 3037 0 0 0 0 0 0 0 13 LPoint4f::xyz 0

3998 2 xy 0 2 3618 3038 0 0 0 0 0 0 0 12 LPoint4f::xy 0

3999 3 xyz 0 2 3632 3057 0 0 0 0 0 0 0 13 LPoint4d::xyz 0

4000 2 xy 0 2 3619 3058 0 0 0 0 0 0 0 12 LPoint4d::xy 0

4001 3 xyz 0 2 3633 3077 0 0 0 0 0 0 0 13 LPoint4i::xyz 0

4002 2 xy 0 2 3620 3078 0 0 0 0 0 0 0 12 LPoint4i::xy 0

4003 4 rows 0 70 3621 3109 3107 0 0 0 3106 0 0 15 LMatrix3f::rows 0

4004 4 cols 0 70 3621 3110 3108 0 0 0 3106 0 0 15 LMatrix3f::cols 0

4005 4 rows 0 70 3634 3199 3197 0 0 0 3196 0 0 15 LMatrix4f::rows 0

4006 4 cols 0 70 3634 3200 3198 0 0 0 3196 0 0 15 LMatrix4f::cols 0

4007 4 rows 0 70 3623 3303 3301 0 0 0 3300 0 0 15 LMatrix3d::rows 0

4008 4 cols 0 70 3623 3304 3302 0 0 0 3300 0 0 15 LMatrix3d::cols 0

4009 4 rows 0 70 3638 3391 3389 0 0 0 3388 0 0 15 LMatrix4d::rows 0

4010 4 cols 0 70 3638 3392 3390 0 0 0 3388 0 0 15 LMatrix4d::cols 0

14
4011 8 get_rows 0 3106 3109 19 LMatrix3f::get_rows 0

4012 8 get_cols 0 3106 3110 19 LMatrix3f::get_cols 0

4013 9 get_col2s 0 3106 3112 20 LMatrix3f::get_col2s 0

4014 9 get_row2s 0 3106 3111 20 LMatrix3f::get_row2s 0

4015 8 get_rows 0 3196 3199 19 LMatrix4f::get_rows 0

4016 8 get_cols 0 3196 3200 19 LMatrix4f::get_cols 0

4017 9 get_row3s 0 3196 3201 20 LMatrix4f::get_row3s 0

4018 8 get_rows 0 3300 3303 19 LMatrix3d::get_rows 0

4019 8 get_cols 0 3300 3304 19 LMatrix3d::get_cols 0

4020 9 get_col2s 0 3300 3306 20 LMatrix3d::get_col2s 0

4021 9 get_row2s 0 3300 3305 20 LMatrix3d::get_row2s 0

4022 8 get_rows 0 3388 3391 19 LMatrix4d::get_rows 0

4023 8 get_cols 0 3388 3392 19 LMatrix4d::get_cols 0

4024 9 get_row3s 0 3388 3393 20 LMatrix4d::get_row3s 0

